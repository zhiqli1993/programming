# Go语言并发设计模式

## 📚 学习目标
掌握Go语言的经典并发设计模式，理解并发编程的最佳实践和应用场景。

---

## 1. 生产者-消费者模式

### 1.1 基本实现
```go
package main

import (
    "fmt"
    "time"
)

func producer(ch chan int) {
    for i := 1; i <= 5; i++ {
        fmt.Printf("生产者: 生产数据 %d\n", i)
        ch <- i
        time.Sleep(time.Millisecond * 500)
    }
    close(ch) // 生产完成后关闭Channel
}

func consumer(ch chan int) {
    for value := range ch {
        fmt.Printf("消费者: 消费数据 %d\n", value)
        time.Sleep(time.Millisecond * 800)
    }
}

func main() {
    ch := make(chan int, 3)
    go producer(ch)
    consumer(ch)
}
```

### 1.2 多生产者-多消费者
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func producer(id int, ch chan<- int, wg *sync.WaitGroup) {
    defer wg.Done()
    
    for i := 1; i <= 3; i++ {
        data := i * 10 + id
        fmt.Printf("生产者 %d: 生产数据 %d\n", id, data)
        ch <- data
        time.Sleep(time.Millisecond * 300)
    }
}

func consumer(id int, ch <-chan int, wg *sync.WaitGroup) {
    defer wg.Done()
    
    for value := range ch {
        fmt.Printf("消费者 %d: 消费数据 %d\n", id, value)
        time.Sleep(time.Millisecond * 500)
    }
}

func main() {
    dataChannel := make(chan int, 10)
    
    var producerWg sync.WaitGroup
    var consumerWg sync.WaitGroup
    
    // 启动3个生产者
    for i := 1; i <= 3; i++ {
        producerWg.Add(1)
        go producer(i, dataChannel, &producerWg)
    }
    
    // 启动2个消费者
    for i := 1; i <= 2; i++ {
        consumerWg.Add(1)
        go consumer(i, dataChannel, &consumerWg)
    }
    
    // 等待所有生产者完成，然后关闭通道
    go func() {
        producerWg.Wait()
        close(dataChannel)
    }()
    
    // 等待所有消费者完成
    consumerWg.Wait()
    fmt.Println("所有生产者和消费者已完成")
}
```

### 1.3 带有取消功能的生产者-消费者
```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

func producer(ctx context.Context, ch chan<- int) error {
    for i := 1; ; i++ {
        select {
        case <-ctx.Done():
            return ctx.Err()
        case ch <- i:
            fmt.Printf("生产者: 生产数据 %d\n", i)
            time.Sleep(time.Millisecond * 500)
        }
    }
}

func consumer(ctx context.Context, ch <-chan int, wg *sync.WaitGroup) {
    defer wg.Done()
    
    for {
        select {
        case <-ctx.Done():
            fmt.Println("消费者: 收到取消信号，退出")
            return
        case value, ok := <-ch:
            if !ok {
                return
            }
            fmt.Printf("消费者: 消费数据 %d\n", value)
            time.Sleep(time.Millisecond * 800)
        }
    }
}

func main() {
    // 创建可取消的上下文
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    dataChannel := make(chan int, 5)
    
    var wg sync.WaitGroup
    
    // 启动生产者
    go func() {
        defer close(dataChannel)
        if err := producer(ctx, dataChannel); err != nil {
            fmt.Printf("生产者退出: %v\n", err)
        }
    }()
    
    // 启动2个消费者
    for i := 0; i < 2; i++ {
        wg.Add(1)
        go consumer(ctx, dataChannel, &wg)
    }
    
    // 等待消费者完成
    wg.Wait()
    fmt.Println("程序结束")
}
```

---

## 2. 工作池模式

### 2.1 基本实现
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, tasks <-chan int, wg *sync.WaitGroup) {
    defer wg.Done()
    for task := range tasks {
        fmt.Printf("工人%d处理任务%d\n", id, task)
        time.Sleep(time.Second)
    }
}

func main() {
    const numWorkers = 3
    const numTasks = 10

    tasks := make(chan int, numTasks)
    var wg sync.WaitGroup

    // 创建工人
    for i := 1; i <= numWorkers; i++ {
        wg.Add(1)
        go worker(i, tasks, &wg)
    }

    // 分发任务
    for i := 1; i <= numTasks; i++ {
        tasks <- i
    }
    close(tasks) // 关闭任务Channel

    wg.Wait()
    fmt.Println("所有任务处理完成")
}
```

### 2.2 带结果收集的工作池
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// 任务结构
type Task struct {
    ID     int
    Data   string
    Result chan<- Result
}

// 结果结构
type Result struct {
    TaskID    int
    ProcessBy int
    Data      string
}

// 工作池
func startWorkerPool(numWorkers int, tasks <-chan Task) {
    var wg sync.WaitGroup
    
    for i := 1; i <= numWorkers; i++ {
        wg.Add(1)
        go func(workerID int) {
            defer wg.Done()
            worker(workerID, tasks)
        }(i)
    }
    
    wg.Wait()
}

// 工作者函数
func worker(id int, tasks <-chan Task) {
    for task := range tasks {
        // 模拟处理时间
        time.Sleep(500 * time.Millisecond)
        
        // 处理任务
        result := Result{
            TaskID:    task.ID,
            ProcessBy: id,
            Data:      fmt.Sprintf("已处理: %s", task.Data),
        }
        
        // 发送结果
        task.Result <- result
    }
}

func main() {
    // 创建任务通道
    tasks := make(chan Task, 10)
    
    // 创建结果通道
    results := make(chan Result, 10)
    
    // 启动工作池
    go startWorkerPool(3, tasks)
    
    // 创建和分发任务
    go func() {
        for i := 1; i <= 10; i++ {
            tasks <- Task{
                ID:     i,
                Data:   fmt.Sprintf("任务数据 %d", i),
                Result: results,
            }
        }
        close(tasks)
    }()
    
    // 收集结果
    for i := 1; i <= 10; i++ {
        result := <-results
        fmt.Printf("任务%d由工人%d处理，结果: %s\n", 
            result.TaskID, result.ProcessBy, result.Data)
    }
    
    // 关闭结果通道
    close(results)
}
```

### 2.3 动态扩缩容的工作池
```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
    "time"
)

// 工作池
type WorkerPool struct {
    tasks       chan int
    results     chan int
    workerCount int32
    maxWorkers  int32
    minWorkers  int32
    wg          sync.WaitGroup
    quit        chan struct{}
    statsLock   sync.Mutex
    queueSize   int32
    workersLock sync.Mutex
}

// 创建新工作池
func NewWorkerPool(minWorkers, maxWorkers, queueSize int) *WorkerPool {
    wp := &WorkerPool{
        tasks:      make(chan int, queueSize),
        results:    make(chan int, queueSize),
        minWorkers: int32(minWorkers),
        maxWorkers: int32(maxWorkers),
        quit:       make(chan struct{}),
    }
    
    // 启动最小数量的工作者
    for i := 0; i < minWorkers; i++ {
        wp.addWorker()
    }
    
    // 启动自动扩缩
    go wp.autoScale()
    
    return wp
}

// 添加工作者
func (wp *WorkerPool) addWorker() {
    wp.workersLock.Lock()
    defer wp.workersLock.Unlock()
    
    if atomic.LoadInt32(&wp.workerCount) >= wp.maxWorkers {
        return
    }
    
    wp.wg.Add(1)
    atomic.AddInt32(&wp.workerCount, 1)
    
    go func() {
        defer wp.wg.Done()
        defer atomic.AddInt32(&wp.workerCount, -1)
        
        for {
            select {
            case <-wp.quit:
                return
            case task, ok := <-wp.tasks:
                if !ok {
                    return
                }
                
                // 处理任务
                time.Sleep(500 * time.Millisecond)
                result := task * 2
                
                wp.results <- result
            }
        }
    }()
    
    fmt.Printf("工作者已添加，当前工作者数量: %d\n", atomic.LoadInt32(&wp.workerCount))
}

// 减少工作者
func (wp *WorkerPool) removeWorker() {
    wp.workersLock.Lock()
    defer wp.workersLock.Unlock()
    
    if atomic.LoadInt32(&wp.workerCount) <= wp.minWorkers {
        return
    }
    
    select {
    case wp.quit <- struct{}{}:
        fmt.Printf("工作者已移除，当前工作者数量: %d\n", atomic.LoadInt32(&wp.workerCount)-1)
    default:
    }
}

// 自动扩缩容
func (wp *WorkerPool) autoScale() {
    ticker := time.NewTicker(time.Second)
    defer ticker.Stop()
    
    for {
        <-ticker.C
        
        wp.statsLock.Lock()
        queueSize := int32(len(wp.tasks))
        wp.statsLock.Unlock()
        
        workerCount := atomic.LoadInt32(&wp.workerCount)
        
        // 根据队列长度扩缩容
        if queueSize > workerCount && workerCount < wp.maxWorkers {
            wp.addWorker()
        } else if queueSize == 0 && workerCount > wp.minWorkers {
            wp.removeWorker()
        }
    }
}

// 提交任务
func (wp *WorkerPool) Submit(task int) {
    wp.tasks <- task
}

// 获取结果通道
func (wp *WorkerPool) Results() <-chan int {
    return wp.results
}

// 关闭工作池
func (wp *WorkerPool) Close() {
    close(wp.tasks)
    wp.wg.Wait()
    close(wp.results)
}

func main() {
    // 创建工作池：最小2个，最大5个工作者，队列长度10
    pool := NewWorkerPool(2, 5, 10)
    
    // 收集结果
    go func() {
        for result := range pool.Results() {
            fmt.Printf("收到结果: %d\n", result)
        }
    }()
    
    // 提交任务 - 模拟突发负载
    time.Sleep(2 * time.Second) // 观察初始工作者数量
    
    fmt.Println("提交第一批任务...")
    for i := 1; i <= 10; i++ {
        pool.Submit(i)
    }
    
    time.Sleep(3 * time.Second) // 观察工作者扩容
    
    fmt.Println("提交第二批任务...")
    for i := 11; i <= 15; i++ {
        pool.Submit(i)
    }
    
    time.Sleep(5 * time.Second) // 观察工作者缩容
    
    // 关闭工作池
    pool.Close()
    fmt.Println("工作池已关闭")
}
```

---

## 3. 发布订阅模式

### 3.1 基本实现
```go
package main

import (
    "fmt"
    "sync"
)

type Publisher struct {
    subscribers []chan string
    mux         sync.Mutex
}

func (p *Publisher) Subscribe() chan string {
    p.mux.Lock()
    defer p.mux.Unlock()

    ch := make(chan string)
    p.subscribers = append(p.subscribers, ch)
    return ch
}

func (p *Publisher) Publish(message string) {
    p.mux.Lock()
    defer p.mux.Unlock()

    for _, ch := range p.subscribers {
        ch <- message
    }
}

func main() {
    publisher := &Publisher{}

    sub1 := publisher.Subscribe()
    sub2 := publisher.Subscribe()

    go func() {
        for msg := range sub1 {
            fmt.Printf("订阅者1收到: %s\n", msg)
        }
    }()

    go func() {
        for msg := range sub2 {
            fmt.Printf("订阅者2收到: %s\n", msg)
        }
    }()

    publisher.Publish("消息1")
    publisher.Publish("消息2")
}
```

### 3.2 带主题的发布订阅
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// 消息结构
type Message struct {
    Topic   string
    Content string
}

// 发布者
type TopicPublisher struct {
    subscribers map[string][]chan Message
    mux         sync.RWMutex
}

// 创建发布者
func NewTopicPublisher() *TopicPublisher {
    return &TopicPublisher{
        subscribers: make(map[string][]chan Message),
    }
}

// 订阅主题
func (p *TopicPublisher) Subscribe(topic string) chan Message {
    p.mux.Lock()
    defer p.mux.Unlock()
    
    ch := make(chan Message, 10)
    p.subscribers[topic] = append(p.subscribers[topic], ch)
    return ch
}

// 取消订阅
func (p *TopicPublisher) Unsubscribe(topic string, ch chan Message) {
    p.mux.Lock()
    defer p.mux.Unlock()
    
    if subs, found := p.subscribers[topic]; found {
        var newSubs []chan Message
        for _, sub := range subs {
            if sub != ch {
                newSubs = append(newSubs, sub)
            }
        }
        p.subscribers[topic] = newSubs
    }
}

// 发布消息到主题
func (p *TopicPublisher) Publish(msg Message) {
    p.mux.RLock()
    defer p.mux.RUnlock()
    
    if subs, found := p.subscribers[msg.Topic]; found {
        for _, ch := range subs {
            select {
            case ch <- msg:
                // 消息发送成功
            default:
                // 通道已满，跳过此订阅者
                fmt.Printf("跳过订阅者，通道已满: %s\n", msg.Topic)
            }
        }
    }
}

// 订阅者处理函数
func subscriber(id int, ch chan Message, wg *sync.WaitGroup) {
    defer wg.Done()
    
    for msg := range ch {
        fmt.Printf("订阅者 %d 收到 [%s]: %s\n", 
            id, msg.Topic, msg.Content)
        time.Sleep(100 * time.Millisecond)
    }
}

func main() {
    publisher := NewTopicPublisher()
    
    // 创建主题和订阅者
    topics := []string{"sports", "tech", "weather"}
    var subscribers []chan Message
    var wg sync.WaitGroup
    
    // 订阅不同主题
    for i := 0; i < 5; i++ {
        subID := i + 1
        wg.Add(1)
        
        // 每个订阅者订阅1-2个主题
        topicIndex1 := i % len(topics)
        topicIndex2 := (i + 1) % len(topics)
        
        ch := publisher.Subscribe(topics[topicIndex1])
        
        if i%2 == 0 {
            // 一些订阅者订阅多个主题
            publisher.Subscribe(topics[topicIndex2])
            fmt.Printf("订阅者 %d 订阅了主题 %s 和 %s\n", 
                subID, topics[topicIndex1], topics[topicIndex2])
        } else {
            fmt.Printf("订阅者 %d 订阅了主题 %s\n", 
                subID, topics[topicIndex1])
        }
        
        subscribers = append(subscribers, ch)
        go subscriber(subID, ch, &wg)
    }
    
    // 发布消息
    for i := 0; i < 10; i++ {
        topic := topics[i%len(topics)]
        msg := Message{
            Topic:   topic,
            Content: fmt.Sprintf("消息 %d 关于 %s", i+1, topic),
        }
        
        publisher.Publish(msg)
        time.Sleep(200 * time.Millisecond)
    }
    
    // 关闭所有订阅者通道
    for _, ch := range subscribers {
        close(ch)
    }
    
    // 等待所有订阅者处理完毕
    wg.Wait()
    fmt.Println("程序结束")
}
```

### 3.3 基于Event Bus的实现
```go
package main

import (
    "fmt"
    "reflect"
    "sync"
)

// 事件总线
type EventBus struct {
    subscribers map[string][]interface{}
    mux         sync.RWMutex
}

// 创建事件总线
func NewEventBus() *EventBus {
    return &EventBus{
        subscribers: make(map[string][]interface{}),
    }
}

// 订阅事件
func (bus *EventBus) Subscribe(topic string, fn interface{}) {
    bus.mux.Lock()
    defer bus.mux.Unlock()
    
    bus.subscribers[topic] = append(bus.subscribers[topic], fn)
}

// 发布事件
func (bus *EventBus) Publish(topic string, args ...interface{}) {
    bus.mux.RLock()
    defer bus.mux.RUnlock()
    
    if handlers, found := bus.subscribers[topic]; found {
        for _, handler := range handlers {
            handlerValue := reflect.ValueOf(handler)
            
            // 构建参数
            params := make([]reflect.Value, 0)
            for _, arg := range args {
                params = append(params, reflect.ValueOf(arg))
            }
            
            // 调用处理函数
            go handlerValue.Call(params)
        }
    }
}

// 示例处理函数
func handleUserCreated(id int, name string) {
    fmt.Printf("用户已创建: ID=%d, 名称=%s\n", id, name)
}

func handleUserUpdated(id int, name string) {
    fmt.Printf("用户已更新: ID=%d, 新名称=%s\n", id, name)
}

func handleUserDeleted(id int) {
    fmt.Printf("用户已删除: ID=%d\n", id)
}

func main() {
    // 创建事件总线
    bus := NewEventBus()
    
    // 订阅事件
    bus.Subscribe("user.created", handleUserCreated)
    bus.Subscribe("user.updated", handleUserUpdated)
    bus.Subscribe("user.deleted", handleUserDeleted)
    
    // 自定义处理函数
    bus.Subscribe("user.created", func(id int, name string) {
        fmt.Printf("发送欢迎邮件给: %s\n", name)
    })
    
    // 发布事件
    bus.Publish("user.created", 1, "张三")
    bus.Publish("user.updated", 1, "张三丰")
    bus.Publish("user.deleted", 1)
    
    // 等待事件处理完成
    fmt.Println("等待事件处理...")
    var wg sync.WaitGroup
    wg.Add(1)
    go func() {
        defer wg.Done()
        // 简单等待所有事件处理完成
        time.Sleep(100 * time.Millisecond)
    }()
    wg.Wait()
    
    fmt.Println("所有事件已处理")
}
```

---

## 4. 扇入扇出模式

### 4.1 基本实现
```go
package main

import (
    "fmt"
    "sync"
)

func fanOut(input <-chan int, workers int) []chan int {
    outputs := make([]chan int, workers)
    for i := range outputs {
        outputs[i] = make(chan int)
        go func(ch chan int) {
            for value := range input {
                ch <- value * 2 // 模拟处理
            }
            close(ch)
        }(outputs[i])
    }
    return outputs
}

func fanIn(inputs []chan int) <-chan int {
    output := make(chan int)
    var wg sync.WaitGroup

    for _, ch := range inputs {
        wg.Add(1)
        go func(ch chan int) {
            defer wg.Done()
            for value := range ch {
                output <- value
            }
        }(ch)
    }

    go func() {
        wg.Wait()
        close(output)
    }()

    return output
}

func main() {
    input := make(chan int, 10)
    for i := 1; i <= 10; i++ {
        input <- i
    }
    close(input)

    outputs := fanOut(input, 3)
    result := fanIn(outputs)

    for value := range result {
        fmt.Println("最终结果:", value)
    }
}
```

### 4.2 带错误处理的扇入扇出
```go
package main

import (
    "errors"
    "fmt"
    "math/rand"
    "sync"
    "time"
)

// 处理结果
type Result struct {
    Value int
    Err   error
}

// 工作函数
func worker(in int) Result {
    // 模拟随机处理时间
    processingTime := time.Duration(rand.Intn(500)) * time.Millisecond
    time.Sleep(processingTime)
    
    // 模拟随机失败
    if rand.Intn(10) < 2 {
        return Result{
            Err: errors.New("处理失败"),
        }
    }
    
    return Result{
        Value: in * 2,
        Err:   nil,
    }
}

// 扇出函数
func fanOut(inputs []int, workers int) <-chan Result {
    results := make(chan Result)
    
    var wg sync.WaitGroup
    workCh := make(chan int, len(inputs))
    
    // 启动工作者
    for i := 0; i < workers; i++ {
        wg.Add(1)
        go func(workerId int) {
            defer wg.Done()
            
            for input := range workCh {
                fmt.Printf("工作者 %d 处理输入 %d\n", workerId, input)
                result := worker(input)
                results <- result
            }
        }(i)
    }
    
    // 发送工作
    go func() {
        for _, input := range inputs {
            workCh <- input
        }
        close(workCh)
    }()
    
    // 关闭结果通道
    go func() {
        wg.Wait()
        close(results)
    }()
    
    return results
}

// 主函数
func main() {
    // 设置随机数种子
    rand.Seed(time.Now().UnixNano())
    
    // 准备输入数据
    inputs := make([]int, 20)
    for i := range inputs {
        inputs[i] = i + 1
    }
    
    // 使用5个工作者处理
    results := fanOut(inputs, 5)
    
    // 收集和处理结果
    successful := 0
    failed := 0
    
    for result := range results {
        if result.Err != nil {
            failed++
            fmt.Printf("处理失败: %v\n", result.Err)
        } else {
            successful++
            fmt.Printf("处理成功: %d\n", result.Value)
        }
    }
    
    fmt.Printf("\n总结: 成功=%d, 失败=%d\n", successful, failed)
}
```

### 4.3 处理流水线
```go
package main

import (
    "fmt"
    "sync"
)

// 阶段1: 生成数字序列
func generator(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for _, n := range nums {
            out <- n
        }
    }()
    return out
}

// 阶段2: 平方数字
func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            out <- n * n
        }
    }()
    return out
}

// 阶段3: 过滤偶数
func filterEven(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            if n%2 == 0 {
                out <- n
            }
        }
    }()
    return out
}

// 阶段4: 扇出处理
func fanOut(in <-chan int, n int) []<-chan int {
    // 创建n个输出通道
    outs := make([]<-chan int, n)
    for i := 0; i < n; i++ {
        outs[i] = processWorker(in, i)
    }
    return outs
}

// 工作者
func processWorker(in <-chan int, id int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            fmt.Printf("工作者 %d 处理: %d\n", id, n)
            out <- n * 10 // 简单处理
        }
    }()
    return out
}

// 阶段5: 扇入合并结果
func fanIn(channels ...<-chan int) <-chan int {
    var wg sync.WaitGroup
    out := make(chan int)
    
    // 为每个输入通道启动一个goroutine
    wg.Add(len(channels))
    for _, c := range channels {
        go func(ch <-chan int) {
            defer wg.Done()
            for n := range ch {
                out <- n
            }
        }(c)
    }
    
    // 等待所有通道处理完毕
    go func() {
        wg.Wait()
        close(out)
    }()
    
    return out
}

func main() {
    // 构建处理流水线
    // 阶段1: 生成初始数据
    nums := generator(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    
    // 阶段2: 平方操作
    squares := square(nums)
    
    // 阶段3: 过滤偶数
    evens := filterEven(squares)
    
    // 阶段4: 扇出到3个工作者并行处理
    workers := fanOut(evens, 3)
    
    // 阶段5: 扇入合并结果
    results := fanIn(workers...)
    
    // 收集最终结果
    var finalResults []int
    for n := range results {
        finalResults = append(finalResults, n)
    }
    
    fmt.Println("\n最终结果:", finalResults)
}
```

---

## 5. Future/Promise模式

### 5.1 基本实现
```go
package main

import (
    "fmt"
    "math/rand"
    "time"
)

// Future表示一个未来的值
type Future struct {
    result chan interface{}
    err    chan error
}

// 创建Future
func NewFuture() *Future {
    return &Future{
        result: make(chan interface{}, 1),
        err:    make(chan error, 1),
    }
}

// 设置结果
func (f *Future) SetResult(result interface{}) {
    f.result <- result
    close(f.result)
    close(f.err)
}

// 设置错误
func (f *Future) SetError(err error) {
    f.err <- err
    close(f.result)
    close(f.err)
}

// 获取结果（阻塞）
func (f *Future) Get() (interface{}, error) {
    select {
    case result := <-f.result:
        return result, nil
    case err := <-f.err:
        return nil, err
    }
}

// 异步执行任务并返回Future
func RunAsync(task func() (interface{}, error)) *Future {
    future := NewFuture()
    
    go func() {
        result, err := task()
        if err != nil {
            future.SetError(err)
        } else {
            future.SetResult(result)
        }
    }()
    
    return future
}

// 示例任务
func fetchData(id int) (interface{}, error) {
    // 模拟耗时操作
    duration := time.Duration(1+rand.Intn(3)) * time.Second
    fmt.Printf("任务%d: 开始执行，预计耗时%v\n", id, duration)
    time.Sleep(duration)
    
    // 模拟结果
    data := fmt.Sprintf("数据-%d", id)
    return data, nil
}

func main() {
    rand.Seed(time.Now().UnixNano())
    
    // 启动多个异步任务
    futures := make([]*Future, 3)
    for i := 0; i < 3; i++ {
        taskID := i + 1
        futures[i] = RunAsync(func() (interface{}, error) {
            return fetchData(taskID)
        })
    }
    
    // 等待所有任务完成
    for i, future := range futures {
        fmt.Printf("等待任务%d结果...\n", i+1)
        result, err := future.Get()
        if err != nil {
            fmt.Printf("任务%d失败: %v\n", i+1, err)
        } else {
            fmt.Printf("任务%d成功: %v\n", i+1, result)
        }
    }
    
    fmt.Println("所有任务已完成")
}
```

### 5.2 带超时的Future
```go
package main

import (
    "errors"
    "fmt"
    "math/rand"
    "time"
)

// 带超时的Future
type TimedFuture struct {
    result  chan interface{}
    err     chan error
    timeout time.Duration
}

// 创建带超时的Future
func NewTimedFuture(timeout time.Duration) *TimedFuture {
    return &TimedFuture{
        result:  make(chan interface{}, 1),
        err:     make(chan error, 1),
        timeout: timeout,
    }
}

// 设置结果
func (f *TimedFuture) SetResult(result interface{}) {
    f.result <- result
}

// 设置错误
func (f *TimedFuture) SetError(err error) {
    f.err <- err
}

// 获取结果（带超时）
func (f *TimedFuture) Get() (interface{}, error) {
    select {
    case result := <-f.result:
        return result, nil
    case err := <-f.err:
        return nil, err
    case <-time.After(f.timeout):
        return nil, errors.New("操作超时")
    }
}

// 异步执行任务并返回Future
func RunAsyncWithTimeout(task func() (interface{}, error), timeout time.Duration) *TimedFuture {
    future := NewTimedFuture(timeout)
    
    go func() {
        result, err := task()
        if err != nil {
            future.SetError(err)
        } else {
            future.SetResult(result)
        }
    }()
    
    return future
}

// 模拟耗时操作
func simulateTask(id int, shouldTimeout bool) (interface{}, error) {
    // 决定执行时间
    var duration time.Duration
    if shouldTimeout {
        duration = 3 * time.Second // 故意超时
    } else {
        duration = 1 * time.Second // 正常完成
    }
    
    fmt.Printf("任务%d开始执行，将耗时%v\n", id, duration)
    time.Sleep(duration)
    
    return fmt.Sprintf("任务%d的结果", id), nil
}

func main() {
    // 设置超时为2秒
    timeout := 2 * time.Second
    
    fmt.Printf("启动任务，超时设置为%v\n", timeout)
    
    // 启动一个正常完成的任务
    future1 := RunAsyncWithTimeout(func() (interface{}, error) {
        return simulateTask(1, false)
    }, timeout)
    
    // 启动一个会超时的任务
    future2 := RunAsyncWithTimeout(func() (interface{}, error) {
        return simulateTask(2, true)
    }, timeout)
    
    // 获取结果
    result1, err1 := future1.Get()
    if err1 != nil {
        fmt.Printf("任务1失败: %v\n", err1)
    } else {
        fmt.Printf("任务1成功: %v\n", result1)
    }
    
    result2, err2 := future2.Get()
    if err2 != nil {
        fmt.Printf("任务2失败: %v\n", err2)
    } else {
        fmt.Printf("任务2成功: %v\n", result2)
    }
}
```

---

## 6. 并发控制模式

### 6.1 速率限制（Rate Limiting）
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// 速率限制器
type RateLimiter struct {
    interval time.Duration
    tokens   chan struct{}
    once     sync.Once
}

// 创建速率限制器
func NewRateLimiter(rps int) *RateLimiter {
    return &RateLimiter{
        interval: time.Second / time.Duration(rps),
        tokens:   make(chan struct{}, 1),
    }
}

// 开始令牌生成
func (r *RateLimiter) start() {
    go func() {
        ticker := time.NewTicker(r.interval)
        defer ticker.Stop()
        
        for range ticker.C {
            select {
            case r.tokens <- struct{}{}:
                // 成功放入令牌
            default:
                // 令牌槽已满，丢弃
            }
        }
    }()
}

// 等待令牌
func (r *RateLimiter) Wait() {
    r.once.Do(r.start)
    <-r.tokens
}

// 模拟API请求
func makeRequest(id int, limiter *RateLimiter) {
    limiter.Wait()
    
    fmt.Printf("[%s] 请求 #%d 开始处理\n", 
        time.Now().Format("15:04:05.000"), id)
    
    // 模拟处理时间
    time.Sleep(50 * time.Millisecond)
}

func main() {
    // 创建每秒处理5个请求的限流器
    limiter := NewRateLimiter(5)
    
    var wg sync.WaitGroup
    
    // 模拟20个并发请求
    for i := 1; i <= 20; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            makeRequest(id, limiter)
        }(i)
    }
    
    wg.Wait()
    fmt.Println("所有请求已处理")
}
```

### 6.2 资源池模式
```go
package main

import (
    "errors"
    "fmt"
    "sync"
    "time"
)

// 资源接口
type Resource interface {
    DoWork() error
    Close()
}

// 具体资源实现
type DBConnection struct {
    id int
}

func (db *DBConnection) DoWork() error {
    fmt.Printf("连接 #%d 正在执行工作\n", db.id)
    time.Sleep(100 * time.Millisecond)
    return nil
}

func (db *DBConnection) Close() {
    fmt.Printf("连接 #%d 已关闭\n", db.id)
}

// 资源工厂
type ResourceFactory func() (Resource, error)

// 资源池
type ResourcePool struct {
    resources chan Resource
    factory   ResourceFactory
    closed    bool
    mutex     sync.Mutex
}

// 创建资源池
func NewResourcePool(maxResources int, factory ResourceFactory) (*ResourcePool, error) {
    pool := &ResourcePool{
        resources: make(chan Resource, maxResources),
        factory:   factory,
    }
    
    // 预创建资源
    for i := 0; i < maxResources; i++ {
        resource, err := factory()
        if err != nil {
            pool.Close()
            return nil, fmt.Errorf("初始化资源池失败: %v", err)
        }
        pool.resources <- resource
    }
    
    return pool, nil
}

// 获取资源
func (p *ResourcePool) Acquire() (Resource, error) {
    p.mutex.Lock()
    defer p.mutex.Unlock()
    
    if p.closed {
        return nil, errors.New("资源池已关闭")
    }
    
    select {
    case resource, ok := <-p.resources:
        if !ok {
            return nil, errors.New("资源池已关闭")
        }
        return resource, nil
    default:
        // 创建新资源
        return p.factory()
    }
}

// 释放资源
func (p *ResourcePool) Release(resource Resource) error {
    p.mutex.Lock()
    defer p.mutex.Unlock()
    
    if p.closed {
        resource.Close()
        return errors.New("资源池已关闭")
    }
    
    select {
    case p.resources <- resource:
        return nil
    default:
        // 池已满，关闭资源
        resource.Close()
        return nil
    }
}

// 关闭资源池
func (p *ResourcePool) Close() {
    p.mutex.Lock()
    defer p.mutex.Unlock()
    
    if p.closed {
        return
    }
    
    p.closed = true
    close(p.resources)
    
    // 关闭所有资源
    for resource := range p.resources {
        resource.Close()
    }
}

// 使用资源
func useResource(pool *ResourcePool, id int) error {
    // 获取资源
    resource, err := pool.Acquire()
    if err != nil {
        return err
    }
    
    // 确保资源被释放
    defer pool.Release(resource)
    
    // 使用资源
    fmt.Printf("工作者 %d 获取了资源\n", id)
    return resource.DoWork()
}

func main() {
    // 创建资源工厂
    factory := func() (Resource, error) {
        static := 0
        static++
        return &DBConnection{id: static}, nil
    }
    
    // 创建资源池，最多5个连接
    pool, err := NewResourcePool(5, factory)
    if err != nil {
        fmt.Printf("创建资源池失败: %v\n", err)
        return
    }
    defer pool.Close()
    
    // 模拟20个并发工作者
    var wg sync.WaitGroup
    for i := 1; i <= 20; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            if err := useResource(pool, id); err != nil {
                fmt.Printf("工作者 %d 使用资源失败: %v\n", id, err)
            }
        }(i)
    }
    
    wg.Wait()
    fmt.Println("所有工作已完成")
}
```

### 6.3 熔断器模式
```go
package main

import (
    "errors"
    "fmt"
    "math/rand"
    "sync"
    "time"
)

// 熔断器状态
type CircuitState int

const (
    StateClosed CircuitState = iota // 关闭状态（正常工作）
    StateOpen                        // 开启状态（停止工作）
    StateHalfOpen                    // 半开状态（尝试恢复）
)

// 熔断器配置
type CircuitBreakerConfig struct {
    Timeout           time.Duration // 熔断器开启状态持续时间
    FailureThreshold  int           // 触发熔断的失败次数阈值
    SuccessThreshold  int           // 半开状态下成功次数阈值
    MaxConcurrentCalls int          // 最大并发请求数
}

// 熔断器
type CircuitBreaker struct {
    name              string
    state             CircuitState
    config            CircuitBreakerConfig
    
    mutex             sync.RWMutex
    failures          int       // 连续失败次数
    successes         int       // 半开状态下连续成功次数
    lastStateChange   time.Time // 最后状态变更时间
    activeCalls       int       // 当前活跃请求数
}

// 创建新熔断器
func NewCircuitBreaker(name string, config CircuitBreakerConfig) *CircuitBreaker {
    return &CircuitBreaker{
        name:            name,
        state:           StateClosed,
        config:          config,
        lastStateChange: time.Now(),
    }
}

// 执行受保护的函数
func (cb *CircuitBreaker) Execute(fn func() error) error {
    // 检查是否可以执行
    if err := cb.beforeExecution(); err != nil {
        return err
    }
    
    // 记录活跃请求
    cb.incrementActiveCalls()
    defer cb.decrementActiveCalls()
    
    // 执行函数
    err := fn()
    
    // 处理结果
    cb.afterExecution(err)
    
    return err
}

// 执行前检查
func (cb *CircuitBreaker) beforeExecution() error {
    cb.mutex.RLock()
    defer cb.mutex.RUnlock()
    
    // 检查活跃请求数
    if cb.activeCalls >= cb.config.MaxConcurrentCalls {
        return errors.New("熔断器: 超过最大并发请求数")
    }
    
    // 检查熔断器状态
    switch cb.state {
    case StateOpen:
        // 检查是否应该切换到半开状态
        if time.Since(cb.lastStateChange) > cb.config.Timeout {
            // 允许一个请求尝试
            cb.mutex.RUnlock()
            cb.mutex.Lock()
            if cb.state == StateOpen {
                fmt.Printf("熔断器 '%s': 从开启状态切换到半开状态\n", cb.name)
                cb.state = StateHalfOpen
                cb.lastStateChange = time.Now()
            }
            cb.mutex.Unlock()
            cb.mutex.RLock()
            return nil
        }
        return fmt.Errorf("熔断器 '%s': 开启状态，拒绝请求", cb.name)
        
    case StateHalfOpen:
        // 只允许一个请求通过
        if cb.activeCalls > 0 {
            return fmt.Errorf("熔断器 '%s': 半开状态，已有请求正在处理", cb.name)
        }
        return nil
        
    default: // StateClosed
        return nil
    }
}

// 执行后处理
func (cb *CircuitBreaker) afterExecution(err error) {
    cb.mutex.Lock()
    defer cb.mutex.Unlock()
    
    if err != nil {
        // 处理失败
        cb.failures++
        cb.successes = 0
        
        fmt.Printf("熔断器 '%s': 执行失败 (%d/%d)\n", 
            cb.name, cb.failures, cb.config.FailureThreshold)
        
        if (cb.state == StateClosed && cb.failures >= cb.config.FailureThreshold) ||
           (cb.state == StateHalfOpen) {
            fmt.Printf("熔断器 '%s': 切换到开启状态\n", cb.name)
            cb.state = StateOpen
            cb.lastStateChange = time.Now()
        }
    } else {
        // 处理成功
        cb.failures = 0
        
        if cb.state == StateHalfOpen {
            cb.successes++
            fmt.Printf("熔断器 '%s': 半开状态下成功 (%d/%d)\n", 
                cb.name, cb.successes, cb.config.SuccessThreshold)
            
            if cb.successes >= cb.config.SuccessThreshold {
                fmt.Printf("熔断器 '%s': 切换到关闭状态\n", cb.name)
                cb.state = StateClosed
                cb.lastStateChange = time.Now()
                cb.successes = 0
            }
        }
    }
}

// 增加活跃请求计数
func (cb *CircuitBreaker) incrementActiveCalls() {
    cb.mutex.Lock()
    defer cb.mutex.Unlock()
    cb.activeCalls++
}

// 减少活跃请求计数
func (cb *CircuitBreaker) decrementActiveCalls() {
    cb.mutex.Lock()
    defer cb.mutex.Unlock()
    cb.activeCalls--
}

// 获取当前状态
func (cb *CircuitBreaker) GetState() CircuitState {
    cb.mutex.RLock()
    defer cb.mutex.RUnlock()
    return cb.state
}

// 模拟远程服务调用
func callRemoteService(failRate float64) error {
    // 模拟网络延迟
    time.Sleep(time.Duration(50+rand.Intn(50)) * time.Millisecond)
    
    // 模拟失败
    if rand.Float64() < failRate {
        return errors.New("服务调用失败")
    }
    
    return nil
}

func main() {
    rand.Seed(time.Now().UnixNano())
    
    // 创建熔断器
    cb := NewCircuitBreaker("RemoteService", CircuitBreakerConfig{
        Timeout:           5 * time.Second,  // 熔断器开启5秒后尝试恢复
        FailureThreshold:  3,                // 3次失败后熔断
        SuccessThreshold:  2,                // 半开状态下2次成功后恢复
        MaxConcurrentCalls: 10,              // 最多10个并发请求
    })
    
    // 运行测试
    var wg sync.WaitGroup
    
    // 第一阶段：模拟正常调用，偶尔失败
    fmt.Println("\n=== 阶段1: 正常调用，偶尔失败 ===")
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            err := cb.Execute(func() error {
                return callRemoteService(0.2) // 20%的失败率
            })
            
            if err != nil {
                fmt.Printf("请求 %d 失败: %v\n", id, err)
            } else {
                fmt.Printf("请求 %d 成功\n", id)
            }
        }(i)
        time.Sleep(100 * time.Millisecond)
    }
    wg.Wait()
    
    // 第二阶段：模拟服务故障，高失败率
    fmt.Println("\n=== 阶段2: 服务故障，高失败率 ===")
    for i := 10; i < 20; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            err := cb.Execute(func() error {
                return callRemoteService(0.8) // 80%的失败率
            })
            
            if err != nil {
                fmt.Printf("请求 %d 失败: %v\n", id, err)
            } else {
                fmt.Printf("请求 %d 成功\n", id)
            }
        }(i)
        time.Sleep(100 * time.Millisecond)
    }
    wg.Wait()
    
    // 第三阶段：熔断器开启，请求被拒绝
    fmt.Println("\n=== 阶段3: 熔断器开启，请求被拒绝 ===")
    for i := 20; i < 25; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            err := cb.Execute(func() error {
                return callRemoteService(0.0) // 服务已恢复，但熔断器仍然开启
            })
            
            if err != nil {
                fmt.Printf("请求 %d 失败: %v\n", id, err)
            } else {
                fmt.Printf("请求 %d 成功\n", id)
            }
        }(i)
        time.Sleep(100 * time.Millisecond)
    }
    wg.Wait()
    
    // 第四阶段：等待熔断器进入半开状态
    fmt.Println("\n=== 阶段4: 等待熔断器进入半开状态 ===")
    fmt.Println("等待5秒...")
    time.Sleep(5 * time.Second)
    
    // 第五阶段：熔断器半开，尝试恢复
    fmt.Println("\n=== 阶段5: 熔断器半开，尝试恢复 ===")
    for i := 25; i < 30; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            err := cb.Execute(func() error {
                return callRemoteService(0.0) // 服务已完全恢复
            })
            
            if err != nil {
                fmt.Printf("请求 %d 失败: %v\n", id, err)
            } else {
                fmt.Printf("请求 %d 成功\n", id)
            }
        }(i)
        time.Sleep(500 * time.Millisecond)
    }
    wg.Wait()
    
    fmt.Printf("\n最终熔断器状态: %v\n", cb.GetState())
}
```

---

## 7. 综合案例：异步爬虫系统
```go
package main

import (
    "context"
    "encoding/json"
    "errors"
    "fmt"
    "io"
    "math/rand"
    "net/http"
    "os"
    "sync"
    "time"
)

// URL状态
type URLStatus int

const (
    StatusPending URLStatus = iota
    StatusProcessing
    StatusDone
    StatusError
)

// URL信息
type URLInfo struct {
    URL    string
    Depth  int
    Status URLStatus
    Error  error
}

// 页面数据
type PageData struct {
    URL      string
    Title    string
    Links    []string
    Content  string
    FetchedAt time.Time
}

// 爬虫配置
type CrawlerConfig struct {
    MaxDepth      int
    MaxWorkers    int
    MaxRetries    int
    RequestDelay  time.Duration
    Timeout       time.Duration
    UserAgent     string
}

// 爬虫
type Crawler struct {
    config  CrawlerConfig
    visited sync.Map
    queue   chan URLInfo
    results chan PageData
    errors  chan URLInfo
    wg      sync.WaitGroup
    client  *http.Client
}

// 创建新爬虫
func NewCrawler(config CrawlerConfig) *Crawler {
    client := &http.Client{
        Timeout: config.Timeout,
    }
    
    return &Crawler{
        config:  config,
        queue:   make(chan URLInfo, 1000),
        results: make(chan PageData, 1000),
        errors:  make(chan URLInfo, 1000),
        client:  client,
    }
}

// 添加URL到队列
func (c *Crawler) AddURL(url string, depth int) {
    urlInfo := URLInfo{
        URL:    url,
        Depth:  depth,
        Status: StatusPending,
    }
    
    // 检查是否已访问
    if _, exists := c.visited.LoadOrStore(url, urlInfo); !exists {
        c.queue <- urlInfo
    }
}

// 启动爬虫
func (c *Crawler) Start(ctx context.Context, seeds []string) {
    // 添加种子URL
    for _, url := range seeds {
        c.AddURL(url, 0)
    }
    
    // 启动工作者
    for i := 0; i < c.config.MaxWorkers; i++ {
        c.wg.Add(1)
        go c.worker(ctx, i)
    }
    
    // 启动结果处理器
    c.wg.Add(1)
    go c.resultProcessor(ctx)
    
    // 启动错误处理器
    c.wg.Add(1)
    go c.errorProcessor(ctx)
    
    // 等待所有工作完成
    go func() {
        c.wg.Wait()
        close(c.results)
        close(c.errors)
    }()
}

// 工作者
func (c *Crawler) worker(ctx context.Context, id int) {
    defer c.wg.Done()
    
    for {
        select {
        case <-ctx.Done():
            fmt.Printf("工作者 %d: 收到取消信号，退出\n", id)
            return
            
        case urlInfo, ok := <-c.queue:
            if !ok {
                fmt.Printf("工作者 %d: 队列已关闭，退出\n", id)
                return
            }
            
            // 处理URL
            c.processURL(ctx, urlInfo, id)
            
            // 请求延迟
            select {
            case <-ctx.Done():
                return
            case <-time.After(c.config.RequestDelay):
                // 继续下一个URL
            }
        }
    }
}

// 处理URL
func (c *Crawler) processURL(ctx context.Context, urlInfo URLInfo, workerID int) {
    // 更新状态
    urlInfo.Status = StatusProcessing
    c.visited.Store(urlInfo.URL, urlInfo)
    
    fmt.Printf("工作者 %d: 爬取 %s (深度: %d)\n", workerID, urlInfo.URL, urlInfo.Depth)
    
    var lastError error
    
    // 重试机制
    for attempt := 0; attempt < c.config.MaxRetries; attempt++ {
        // 检查取消
        select {
        case <-ctx.Done():
            return
        default:
            // 继续处理
        }
        
        // 如果是重试，等待一段时间
        if attempt > 0 {
            backoff := time.Duration(attempt*500) * time.Millisecond
            fmt.Printf("工作者 %d: 重试 %s (尝试 %d/%d)，等待 %v\n", 
                workerID, urlInfo.URL, attempt+1, c.config.MaxRetries, backoff)
            time.Sleep(backoff)
        }
        
        // 抓取页面
        pageData, err := c.fetchURL(ctx, urlInfo.URL)
        if err != nil {
            lastError = err
            continue // 重试
        }
        
        // 成功抓取，处理结果
        c.results <- pageData
        
        // 如果未达到最大深度，将链接添加到队列
        if urlInfo.Depth < c.config.MaxDepth {
            for _, link := range pageData.Links {
                c.AddURL(link, urlInfo.Depth+1)
            }
        }
        
        // 更新状态为完成
        urlInfo.Status = StatusDone
        c.visited.Store(urlInfo.URL, urlInfo)
        return
    }
    
    // 所有重试都失败
    urlInfo.Status = StatusError
    urlInfo.Error = lastError
    c.visited.Store(urlInfo.URL, urlInfo)
    c.errors <- urlInfo
}

// 抓取URL（模拟）
func (c *Crawler) fetchURL(ctx context.Context, url string) (PageData, error) {
    // 模拟网络延迟
    time.Sleep(time.Duration(100+rand.Intn(500)) * time.Millisecond)
    
    // 模拟随机失败
    if rand.Float64() < 0.2 {
        return PageData{}, errors.New("随机网络错误")
    }
    
    // 模拟页面数据
    return PageData{
        URL:      url,
        Title:    fmt.Sprintf("页面标题 - %s", url),
        Links:    generateRandomLinks(url, 3+rand.Intn(5)),
        Content:  fmt.Sprintf("页面 %s 的内容", url),
        FetchedAt: time.Now(),
    }, nil
}

// 生成随机链接（模拟）
func generateRandomLinks(baseURL string, count int) []string {
    links := make([]string, count)
    for i := 0; i < count; i++ {
        links[i] = fmt.Sprintf("%s/link-%d", baseURL, rand.Intn(1000))
    }
    return links
}

// 结果处理器
func (c *Crawler) resultProcessor(ctx context.Context) {
    defer c.wg.Done()
    
    // 创建结果文件
    file, err := os.Create("crawler_results.json")
    if err != nil {
        fmt.Printf("创建结果文件失败: %v\n", err)
        return
    }
    defer file.Close()
    
    // 写入文件头
    file.WriteString("[\n")
    
    encoder := json.NewEncoder(file)
    first := true
    
    for {
        select {
        case <-ctx.Done():
            fmt.Println("结果处理器: 收到取消信号，退出")
            file.WriteString("\n]")
            return
            
        case result, ok := <-c.results:
            if !ok {
                fmt.Println("结果处理器: 结果通道已关闭，退出")
                file.WriteString("\n]")
                return
            }
            
            // 写入结果
            if !first {
                file.WriteString(",\n")
            }
            first = false
            encoder.Encode(result)
            
            fmt.Printf("页面已保存: %s (链接数: %d)\n", result.URL, len(result.Links))
        }
    }
}

// 错误处理器
func (c *Crawler) errorProcessor(ctx context.Context) {
    defer c.wg.Done()
    
    // 创建错误日志文件
    file, err := os.Create("crawler_errors.log")
    if err != nil {
        fmt.Printf("创建错误日志文件失败: %v\n", err)
        return
    }
    defer file.Close()
    
    for {
        select {
        case <-ctx.Done():
            fmt.Println("错误处理器: 收到取消信号，退出")
            return
            
        case errorInfo, ok := <-c.errors:
            if !ok {
                fmt.Println("错误处理器: 错误通道已关闭，退出")
                return
            }
            
            // 写入错误日志
            logEntry := fmt.Sprintf("[%s] 爬取 %s 失败: %v\n", 
                time.Now().Format(time.RFC3339), errorInfo.URL, errorInfo.Error)
            file.WriteString(logEntry)
            
            fmt.Printf("错误已记录: %s - %v\n", errorInfo.URL, errorInfo.Error)
        }
    }
}

func main() {
    // 设置随机数种子
    rand.Seed(time.Now().UnixNano())
    
    // 爬虫配置
    config := CrawlerConfig{
        MaxDepth:     3,
        MaxWorkers:   5,
        MaxRetries:   3,
        RequestDelay: 200 * time.Millisecond,
        Timeout:      10 * time.Second,
        UserAgent:    "GoCrawler/1.0",
    }
    
    // 创建爬虫
    crawler := NewCrawler(config)
    
    // 创建可取消的上下文
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    // 启动爬虫
    seeds := []string{
        "https://example.com",
        "https://example.org",
        "https://example.net",
    }
    
    fmt.Println("开始爬取...")
    crawler.Start(ctx, seeds)
    
    // 等待爬取完成或超时
    <-ctx.Done()
    if errors.Is(ctx.Err(), context.DeadlineExceeded) {
        fmt.Println("\n爬取超时")
    } else {
        fmt.Println("\n爬取被取消")
    }
    
    fmt.Println("爬取完成")
}
```

---

## 8. 学习检查点

- [ ] 理解生产者-消费者模式的基本实现和变种
- [ ] 掌握工作池模式的特点和应用场景
- [ ] 能用发布订阅模式实现消息分发和主题订阅
- [ ] 理解扇入扇出模式的设计思想和流水线处理
- [ ] 掌握Future/Promise模式异步处理任务
- [ ] 理解并发控制模式如速率限制、资源池和熔断器
- [ ] 能将多种并发模式组合实现复杂的并发系统

---

并发设计模式是Go语言并发编程的高级应用，掌握这些模式将显著提升程序的设计能力和性能优化水平。每种模式都有其特定的应用场景和优势，在实际项目中可以根据需求灵活组合使用，构建高效、可靠的并发系统。
