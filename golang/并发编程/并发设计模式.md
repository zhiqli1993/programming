# Goè¯­è¨€å¹¶å‘è®¾è®¡æ¨¡å¼

## ğŸ“š å­¦ä¹ ç›®æ ‡
æŒæ¡Goè¯­è¨€çš„ç»å…¸å¹¶å‘è®¾è®¡æ¨¡å¼ï¼Œç†è§£å¹¶å‘ç¼–ç¨‹çš„æœ€ä½³å®è·µå’Œåº”ç”¨åœºæ™¯ã€‚

---

## 1. ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼

### 1.1 åŸºæœ¬å®ç°
```go
package main

import (
    "fmt"
    "time"
)

func producer(ch chan int) {
    for i := 1; i <= 5; i++ {
        fmt.Printf("ç”Ÿäº§è€…: ç”Ÿäº§æ•°æ® %d\n", i)
        ch <- i
        time.Sleep(time.Millisecond * 500)
    }
    close(ch) // ç”Ÿäº§å®Œæˆåå…³é—­Channel
}

func consumer(ch chan int) {
    for value := range ch {
        fmt.Printf("æ¶ˆè´¹è€…: æ¶ˆè´¹æ•°æ® %d\n", value)
        time.Sleep(time.Millisecond * 800)
    }
}

func main() {
    ch := make(chan int, 3)
    go producer(ch)
    consumer(ch)
}
```

### 1.2 å¤šç”Ÿäº§è€…-å¤šæ¶ˆè´¹è€…
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func producer(id int, ch chan<- int, wg *sync.WaitGroup) {
    defer wg.Done()
    
    for i := 1; i <= 3; i++ {
        data := i * 10 + id
        fmt.Printf("ç”Ÿäº§è€… %d: ç”Ÿäº§æ•°æ® %d\n", id, data)
        ch <- data
        time.Sleep(time.Millisecond * 300)
    }
}

func consumer(id int, ch <-chan int, wg *sync.WaitGroup) {
    defer wg.Done()
    
    for value := range ch {
        fmt.Printf("æ¶ˆè´¹è€… %d: æ¶ˆè´¹æ•°æ® %d\n", id, value)
        time.Sleep(time.Millisecond * 500)
    }
}

func main() {
    dataChannel := make(chan int, 10)
    
    var producerWg sync.WaitGroup
    var consumerWg sync.WaitGroup
    
    // å¯åŠ¨3ä¸ªç”Ÿäº§è€…
    for i := 1; i <= 3; i++ {
        producerWg.Add(1)
        go producer(i, dataChannel, &producerWg)
    }
    
    // å¯åŠ¨2ä¸ªæ¶ˆè´¹è€…
    for i := 1; i <= 2; i++ {
        consumerWg.Add(1)
        go consumer(i, dataChannel, &consumerWg)
    }
    
    // ç­‰å¾…æ‰€æœ‰ç”Ÿäº§è€…å®Œæˆï¼Œç„¶åå…³é—­é€šé“
    go func() {
        producerWg.Wait()
        close(dataChannel)
    }()
    
    // ç­‰å¾…æ‰€æœ‰æ¶ˆè´¹è€…å®Œæˆ
    consumerWg.Wait()
    fmt.Println("æ‰€æœ‰ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…å·²å®Œæˆ")
}
```

### 1.3 å¸¦æœ‰å–æ¶ˆåŠŸèƒ½çš„ç”Ÿäº§è€…-æ¶ˆè´¹è€…
```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

func producer(ctx context.Context, ch chan<- int) error {
    for i := 1; ; i++ {
        select {
        case <-ctx.Done():
            return ctx.Err()
        case ch <- i:
            fmt.Printf("ç”Ÿäº§è€…: ç”Ÿäº§æ•°æ® %d\n", i)
            time.Sleep(time.Millisecond * 500)
        }
    }
}

func consumer(ctx context.Context, ch <-chan int, wg *sync.WaitGroup) {
    defer wg.Done()
    
    for {
        select {
        case <-ctx.Done():
            fmt.Println("æ¶ˆè´¹è€…: æ”¶åˆ°å–æ¶ˆä¿¡å·ï¼Œé€€å‡º")
            return
        case value, ok := <-ch:
            if !ok {
                return
            }
            fmt.Printf("æ¶ˆè´¹è€…: æ¶ˆè´¹æ•°æ® %d\n", value)
            time.Sleep(time.Millisecond * 800)
        }
    }
}

func main() {
    // åˆ›å»ºå¯å–æ¶ˆçš„ä¸Šä¸‹æ–‡
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    dataChannel := make(chan int, 5)
    
    var wg sync.WaitGroup
    
    // å¯åŠ¨ç”Ÿäº§è€…
    go func() {
        defer close(dataChannel)
        if err := producer(ctx, dataChannel); err != nil {
            fmt.Printf("ç”Ÿäº§è€…é€€å‡º: %v\n", err)
        }
    }()
    
    // å¯åŠ¨2ä¸ªæ¶ˆè´¹è€…
    for i := 0; i < 2; i++ {
        wg.Add(1)
        go consumer(ctx, dataChannel, &wg)
    }
    
    // ç­‰å¾…æ¶ˆè´¹è€…å®Œæˆ
    wg.Wait()
    fmt.Println("ç¨‹åºç»“æŸ")
}
```

---

## 2. å·¥ä½œæ± æ¨¡å¼

### 2.1 åŸºæœ¬å®ç°
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, tasks <-chan int, wg *sync.WaitGroup) {
    defer wg.Done()
    for task := range tasks {
        fmt.Printf("å·¥äºº%då¤„ç†ä»»åŠ¡%d\n", id, task)
        time.Sleep(time.Second)
    }
}

func main() {
    const numWorkers = 3
    const numTasks = 10

    tasks := make(chan int, numTasks)
    var wg sync.WaitGroup

    // åˆ›å»ºå·¥äºº
    for i := 1; i <= numWorkers; i++ {
        wg.Add(1)
        go worker(i, tasks, &wg)
    }

    // åˆ†å‘ä»»åŠ¡
    for i := 1; i <= numTasks; i++ {
        tasks <- i
    }
    close(tasks) // å…³é—­ä»»åŠ¡Channel

    wg.Wait()
    fmt.Println("æ‰€æœ‰ä»»åŠ¡å¤„ç†å®Œæˆ")
}
```

### 2.2 å¸¦ç»“æœæ”¶é›†çš„å·¥ä½œæ± 
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// ä»»åŠ¡ç»“æ„
type Task struct {
    ID     int
    Data   string
    Result chan<- Result
}

// ç»“æœç»“æ„
type Result struct {
    TaskID    int
    ProcessBy int
    Data      string
}

// å·¥ä½œæ± 
func startWorkerPool(numWorkers int, tasks <-chan Task) {
    var wg sync.WaitGroup
    
    for i := 1; i <= numWorkers; i++ {
        wg.Add(1)
        go func(workerID int) {
            defer wg.Done()
            worker(workerID, tasks)
        }(i)
    }
    
    wg.Wait()
}

// å·¥ä½œè€…å‡½æ•°
func worker(id int, tasks <-chan Task) {
    for task := range tasks {
        // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
        time.Sleep(500 * time.Millisecond)
        
        // å¤„ç†ä»»åŠ¡
        result := Result{
            TaskID:    task.ID,
            ProcessBy: id,
            Data:      fmt.Sprintf("å·²å¤„ç†: %s", task.Data),
        }
        
        // å‘é€ç»“æœ
        task.Result <- result
    }
}

func main() {
    // åˆ›å»ºä»»åŠ¡é€šé“
    tasks := make(chan Task, 10)
    
    // åˆ›å»ºç»“æœé€šé“
    results := make(chan Result, 10)
    
    // å¯åŠ¨å·¥ä½œæ± 
    go startWorkerPool(3, tasks)
    
    // åˆ›å»ºå’Œåˆ†å‘ä»»åŠ¡
    go func() {
        for i := 1; i <= 10; i++ {
            tasks <- Task{
                ID:     i,
                Data:   fmt.Sprintf("ä»»åŠ¡æ•°æ® %d", i),
                Result: results,
            }
        }
        close(tasks)
    }()
    
    // æ”¶é›†ç»“æœ
    for i := 1; i <= 10; i++ {
        result := <-results
        fmt.Printf("ä»»åŠ¡%dç”±å·¥äºº%då¤„ç†ï¼Œç»“æœ: %s\n", 
            result.TaskID, result.ProcessBy, result.Data)
    }
    
    // å…³é—­ç»“æœé€šé“
    close(results)
}
```

### 2.3 åŠ¨æ€æ‰©ç¼©å®¹çš„å·¥ä½œæ± 
```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
    "time"
)

// å·¥ä½œæ± 
type WorkerPool struct {
    tasks       chan int
    results     chan int
    workerCount int32
    maxWorkers  int32
    minWorkers  int32
    wg          sync.WaitGroup
    quit        chan struct{}
    statsLock   sync.Mutex
    queueSize   int32
    workersLock sync.Mutex
}

// åˆ›å»ºæ–°å·¥ä½œæ± 
func NewWorkerPool(minWorkers, maxWorkers, queueSize int) *WorkerPool {
    wp := &WorkerPool{
        tasks:      make(chan int, queueSize),
        results:    make(chan int, queueSize),
        minWorkers: int32(minWorkers),
        maxWorkers: int32(maxWorkers),
        quit:       make(chan struct{}),
    }
    
    // å¯åŠ¨æœ€å°æ•°é‡çš„å·¥ä½œè€…
    for i := 0; i < minWorkers; i++ {
        wp.addWorker()
    }
    
    // å¯åŠ¨è‡ªåŠ¨æ‰©ç¼©
    go wp.autoScale()
    
    return wp
}

// æ·»åŠ å·¥ä½œè€…
func (wp *WorkerPool) addWorker() {
    wp.workersLock.Lock()
    defer wp.workersLock.Unlock()
    
    if atomic.LoadInt32(&wp.workerCount) >= wp.maxWorkers {
        return
    }
    
    wp.wg.Add(1)
    atomic.AddInt32(&wp.workerCount, 1)
    
    go func() {
        defer wp.wg.Done()
        defer atomic.AddInt32(&wp.workerCount, -1)
        
        for {
            select {
            case <-wp.quit:
                return
            case task, ok := <-wp.tasks:
                if !ok {
                    return
                }
                
                // å¤„ç†ä»»åŠ¡
                time.Sleep(500 * time.Millisecond)
                result := task * 2
                
                wp.results <- result
            }
        }
    }()
    
    fmt.Printf("å·¥ä½œè€…å·²æ·»åŠ ï¼Œå½“å‰å·¥ä½œè€…æ•°é‡: %d\n", atomic.LoadInt32(&wp.workerCount))
}

// å‡å°‘å·¥ä½œè€…
func (wp *WorkerPool) removeWorker() {
    wp.workersLock.Lock()
    defer wp.workersLock.Unlock()
    
    if atomic.LoadInt32(&wp.workerCount) <= wp.minWorkers {
        return
    }
    
    select {
    case wp.quit <- struct{}{}:
        fmt.Printf("å·¥ä½œè€…å·²ç§»é™¤ï¼Œå½“å‰å·¥ä½œè€…æ•°é‡: %d\n", atomic.LoadInt32(&wp.workerCount)-1)
    default:
    }
}

// è‡ªåŠ¨æ‰©ç¼©å®¹
func (wp *WorkerPool) autoScale() {
    ticker := time.NewTicker(time.Second)
    defer ticker.Stop()
    
    for {
        <-ticker.C
        
        wp.statsLock.Lock()
        queueSize := int32(len(wp.tasks))
        wp.statsLock.Unlock()
        
        workerCount := atomic.LoadInt32(&wp.workerCount)
        
        // æ ¹æ®é˜Ÿåˆ—é•¿åº¦æ‰©ç¼©å®¹
        if queueSize > workerCount && workerCount < wp.maxWorkers {
            wp.addWorker()
        } else if queueSize == 0 && workerCount > wp.minWorkers {
            wp.removeWorker()
        }
    }
}

// æäº¤ä»»åŠ¡
func (wp *WorkerPool) Submit(task int) {
    wp.tasks <- task
}

// è·å–ç»“æœé€šé“
func (wp *WorkerPool) Results() <-chan int {
    return wp.results
}

// å…³é—­å·¥ä½œæ± 
func (wp *WorkerPool) Close() {
    close(wp.tasks)
    wp.wg.Wait()
    close(wp.results)
}

func main() {
    // åˆ›å»ºå·¥ä½œæ± ï¼šæœ€å°2ä¸ªï¼Œæœ€å¤§5ä¸ªå·¥ä½œè€…ï¼Œé˜Ÿåˆ—é•¿åº¦10
    pool := NewWorkerPool(2, 5, 10)
    
    // æ”¶é›†ç»“æœ
    go func() {
        for result := range pool.Results() {
            fmt.Printf("æ”¶åˆ°ç»“æœ: %d\n", result)
        }
    }()
    
    // æäº¤ä»»åŠ¡ - æ¨¡æ‹Ÿçªå‘è´Ÿè½½
    time.Sleep(2 * time.Second) // è§‚å¯Ÿåˆå§‹å·¥ä½œè€…æ•°é‡
    
    fmt.Println("æäº¤ç¬¬ä¸€æ‰¹ä»»åŠ¡...")
    for i := 1; i <= 10; i++ {
        pool.Submit(i)
    }
    
    time.Sleep(3 * time.Second) // è§‚å¯Ÿå·¥ä½œè€…æ‰©å®¹
    
    fmt.Println("æäº¤ç¬¬äºŒæ‰¹ä»»åŠ¡...")
    for i := 11; i <= 15; i++ {
        pool.Submit(i)
    }
    
    time.Sleep(5 * time.Second) // è§‚å¯Ÿå·¥ä½œè€…ç¼©å®¹
    
    // å…³é—­å·¥ä½œæ± 
    pool.Close()
    fmt.Println("å·¥ä½œæ± å·²å…³é—­")
}
```

---

## 3. å‘å¸ƒè®¢é˜…æ¨¡å¼

### 3.1 åŸºæœ¬å®ç°
```go
package main

import (
    "fmt"
    "sync"
)

type Publisher struct {
    subscribers []chan string
    mux         sync.Mutex
}

func (p *Publisher) Subscribe() chan string {
    p.mux.Lock()
    defer p.mux.Unlock()

    ch := make(chan string)
    p.subscribers = append(p.subscribers, ch)
    return ch
}

func (p *Publisher) Publish(message string) {
    p.mux.Lock()
    defer p.mux.Unlock()

    for _, ch := range p.subscribers {
        ch <- message
    }
}

func main() {
    publisher := &Publisher{}

    sub1 := publisher.Subscribe()
    sub2 := publisher.Subscribe()

    go func() {
        for msg := range sub1 {
            fmt.Printf("è®¢é˜…è€…1æ”¶åˆ°: %s\n", msg)
        }
    }()

    go func() {
        for msg := range sub2 {
            fmt.Printf("è®¢é˜…è€…2æ”¶åˆ°: %s\n", msg)
        }
    }()

    publisher.Publish("æ¶ˆæ¯1")
    publisher.Publish("æ¶ˆæ¯2")
}
```

### 3.2 å¸¦ä¸»é¢˜çš„å‘å¸ƒè®¢é˜…
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// æ¶ˆæ¯ç»“æ„
type Message struct {
    Topic   string
    Content string
}

// å‘å¸ƒè€…
type TopicPublisher struct {
    subscribers map[string][]chan Message
    mux         sync.RWMutex
}

// åˆ›å»ºå‘å¸ƒè€…
func NewTopicPublisher() *TopicPublisher {
    return &TopicPublisher{
        subscribers: make(map[string][]chan Message),
    }
}

// è®¢é˜…ä¸»é¢˜
func (p *TopicPublisher) Subscribe(topic string) chan Message {
    p.mux.Lock()
    defer p.mux.Unlock()
    
    ch := make(chan Message, 10)
    p.subscribers[topic] = append(p.subscribers[topic], ch)
    return ch
}

// å–æ¶ˆè®¢é˜…
func (p *TopicPublisher) Unsubscribe(topic string, ch chan Message) {
    p.mux.Lock()
    defer p.mux.Unlock()
    
    if subs, found := p.subscribers[topic]; found {
        var newSubs []chan Message
        for _, sub := range subs {
            if sub != ch {
                newSubs = append(newSubs, sub)
            }
        }
        p.subscribers[topic] = newSubs
    }
}

// å‘å¸ƒæ¶ˆæ¯åˆ°ä¸»é¢˜
func (p *TopicPublisher) Publish(msg Message) {
    p.mux.RLock()
    defer p.mux.RUnlock()
    
    if subs, found := p.subscribers[msg.Topic]; found {
        for _, ch := range subs {
            select {
            case ch <- msg:
                // æ¶ˆæ¯å‘é€æˆåŠŸ
            default:
                // é€šé“å·²æ»¡ï¼Œè·³è¿‡æ­¤è®¢é˜…è€…
                fmt.Printf("è·³è¿‡è®¢é˜…è€…ï¼Œé€šé“å·²æ»¡: %s\n", msg.Topic)
            }
        }
    }
}

// è®¢é˜…è€…å¤„ç†å‡½æ•°
func subscriber(id int, ch chan Message, wg *sync.WaitGroup) {
    defer wg.Done()
    
    for msg := range ch {
        fmt.Printf("è®¢é˜…è€… %d æ”¶åˆ° [%s]: %s\n", 
            id, msg.Topic, msg.Content)
        time.Sleep(100 * time.Millisecond)
    }
}

func main() {
    publisher := NewTopicPublisher()
    
    // åˆ›å»ºä¸»é¢˜å’Œè®¢é˜…è€…
    topics := []string{"sports", "tech", "weather"}
    var subscribers []chan Message
    var wg sync.WaitGroup
    
    // è®¢é˜…ä¸åŒä¸»é¢˜
    for i := 0; i < 5; i++ {
        subID := i + 1
        wg.Add(1)
        
        // æ¯ä¸ªè®¢é˜…è€…è®¢é˜…1-2ä¸ªä¸»é¢˜
        topicIndex1 := i % len(topics)
        topicIndex2 := (i + 1) % len(topics)
        
        ch := publisher.Subscribe(topics[topicIndex1])
        
        if i%2 == 0 {
            // ä¸€äº›è®¢é˜…è€…è®¢é˜…å¤šä¸ªä¸»é¢˜
            publisher.Subscribe(topics[topicIndex2])
            fmt.Printf("è®¢é˜…è€… %d è®¢é˜…äº†ä¸»é¢˜ %s å’Œ %s\n", 
                subID, topics[topicIndex1], topics[topicIndex2])
        } else {
            fmt.Printf("è®¢é˜…è€… %d è®¢é˜…äº†ä¸»é¢˜ %s\n", 
                subID, topics[topicIndex1])
        }
        
        subscribers = append(subscribers, ch)
        go subscriber(subID, ch, &wg)
    }
    
    // å‘å¸ƒæ¶ˆæ¯
    for i := 0; i < 10; i++ {
        topic := topics[i%len(topics)]
        msg := Message{
            Topic:   topic,
            Content: fmt.Sprintf("æ¶ˆæ¯ %d å…³äº %s", i+1, topic),
        }
        
        publisher.Publish(msg)
        time.Sleep(200 * time.Millisecond)
    }
    
    // å…³é—­æ‰€æœ‰è®¢é˜…è€…é€šé“
    for _, ch := range subscribers {
        close(ch)
    }
    
    // ç­‰å¾…æ‰€æœ‰è®¢é˜…è€…å¤„ç†å®Œæ¯•
    wg.Wait()
    fmt.Println("ç¨‹åºç»“æŸ")
}
```

### 3.3 åŸºäºEvent Busçš„å®ç°
```go
package main

import (
    "fmt"
    "reflect"
    "sync"
)

// äº‹ä»¶æ€»çº¿
type EventBus struct {
    subscribers map[string][]interface{}
    mux         sync.RWMutex
}

// åˆ›å»ºäº‹ä»¶æ€»çº¿
func NewEventBus() *EventBus {
    return &EventBus{
        subscribers: make(map[string][]interface{}),
    }
}

// è®¢é˜…äº‹ä»¶
func (bus *EventBus) Subscribe(topic string, fn interface{}) {
    bus.mux.Lock()
    defer bus.mux.Unlock()
    
    bus.subscribers[topic] = append(bus.subscribers[topic], fn)
}

// å‘å¸ƒäº‹ä»¶
func (bus *EventBus) Publish(topic string, args ...interface{}) {
    bus.mux.RLock()
    defer bus.mux.RUnlock()
    
    if handlers, found := bus.subscribers[topic]; found {
        for _, handler := range handlers {
            handlerValue := reflect.ValueOf(handler)
            
            // æ„å»ºå‚æ•°
            params := make([]reflect.Value, 0)
            for _, arg := range args {
                params = append(params, reflect.ValueOf(arg))
            }
            
            // è°ƒç”¨å¤„ç†å‡½æ•°
            go handlerValue.Call(params)
        }
    }
}

// ç¤ºä¾‹å¤„ç†å‡½æ•°
func handleUserCreated(id int, name string) {
    fmt.Printf("ç”¨æˆ·å·²åˆ›å»º: ID=%d, åç§°=%s\n", id, name)
}

func handleUserUpdated(id int, name string) {
    fmt.Printf("ç”¨æˆ·å·²æ›´æ–°: ID=%d, æ–°åç§°=%s\n", id, name)
}

func handleUserDeleted(id int) {
    fmt.Printf("ç”¨æˆ·å·²åˆ é™¤: ID=%d\n", id)
}

func main() {
    // åˆ›å»ºäº‹ä»¶æ€»çº¿
    bus := NewEventBus()
    
    // è®¢é˜…äº‹ä»¶
    bus.Subscribe("user.created", handleUserCreated)
    bus.Subscribe("user.updated", handleUserUpdated)
    bus.Subscribe("user.deleted", handleUserDeleted)
    
    // è‡ªå®šä¹‰å¤„ç†å‡½æ•°
    bus.Subscribe("user.created", func(id int, name string) {
        fmt.Printf("å‘é€æ¬¢è¿é‚®ä»¶ç»™: %s\n", name)
    })
    
    // å‘å¸ƒäº‹ä»¶
    bus.Publish("user.created", 1, "å¼ ä¸‰")
    bus.Publish("user.updated", 1, "å¼ ä¸‰ä¸°")
    bus.Publish("user.deleted", 1)
    
    // ç­‰å¾…äº‹ä»¶å¤„ç†å®Œæˆ
    fmt.Println("ç­‰å¾…äº‹ä»¶å¤„ç†...")
    var wg sync.WaitGroup
    wg.Add(1)
    go func() {
        defer wg.Done()
        // ç®€å•ç­‰å¾…æ‰€æœ‰äº‹ä»¶å¤„ç†å®Œæˆ
        time.Sleep(100 * time.Millisecond)
    }()
    wg.Wait()
    
    fmt.Println("æ‰€æœ‰äº‹ä»¶å·²å¤„ç†")
}
```

---

## 4. æ‰‡å…¥æ‰‡å‡ºæ¨¡å¼

### 4.1 åŸºæœ¬å®ç°
```go
package main

import (
    "fmt"
    "sync"
)

func fanOut(input <-chan int, workers int) []chan int {
    outputs := make([]chan int, workers)
    for i := range outputs {
        outputs[i] = make(chan int)
        go func(ch chan int) {
            for value := range input {
                ch <- value * 2 // æ¨¡æ‹Ÿå¤„ç†
            }
            close(ch)
        }(outputs[i])
    }
    return outputs
}

func fanIn(inputs []chan int) <-chan int {
    output := make(chan int)
    var wg sync.WaitGroup

    for _, ch := range inputs {
        wg.Add(1)
        go func(ch chan int) {
            defer wg.Done()
            for value := range ch {
                output <- value
            }
        }(ch)
    }

    go func() {
        wg.Wait()
        close(output)
    }()

    return output
}

func main() {
    input := make(chan int, 10)
    for i := 1; i <= 10; i++ {
        input <- i
    }
    close(input)

    outputs := fanOut(input, 3)
    result := fanIn(outputs)

    for value := range result {
        fmt.Println("æœ€ç»ˆç»“æœ:", value)
    }
}
```

### 4.2 å¸¦é”™è¯¯å¤„ç†çš„æ‰‡å…¥æ‰‡å‡º
```go
package main

import (
    "errors"
    "fmt"
    "math/rand"
    "sync"
    "time"
)

// å¤„ç†ç»“æœ
type Result struct {
    Value int
    Err   error
}

// å·¥ä½œå‡½æ•°
func worker(in int) Result {
    // æ¨¡æ‹Ÿéšæœºå¤„ç†æ—¶é—´
    processingTime := time.Duration(rand.Intn(500)) * time.Millisecond
    time.Sleep(processingTime)
    
    // æ¨¡æ‹Ÿéšæœºå¤±è´¥
    if rand.Intn(10) < 2 {
        return Result{
            Err: errors.New("å¤„ç†å¤±è´¥"),
        }
    }
    
    return Result{
        Value: in * 2,
        Err:   nil,
    }
}

// æ‰‡å‡ºå‡½æ•°
func fanOut(inputs []int, workers int) <-chan Result {
    results := make(chan Result)
    
    var wg sync.WaitGroup
    workCh := make(chan int, len(inputs))
    
    // å¯åŠ¨å·¥ä½œè€…
    for i := 0; i < workers; i++ {
        wg.Add(1)
        go func(workerId int) {
            defer wg.Done()
            
            for input := range workCh {
                fmt.Printf("å·¥ä½œè€… %d å¤„ç†è¾“å…¥ %d\n", workerId, input)
                result := worker(input)
                results <- result
            }
        }(i)
    }
    
    // å‘é€å·¥ä½œ
    go func() {
        for _, input := range inputs {
            workCh <- input
        }
        close(workCh)
    }()
    
    // å…³é—­ç»“æœé€šé“
    go func() {
        wg.Wait()
        close(results)
    }()
    
    return results
}

// ä¸»å‡½æ•°
func main() {
    // è®¾ç½®éšæœºæ•°ç§å­
    rand.Seed(time.Now().UnixNano())
    
    // å‡†å¤‡è¾“å…¥æ•°æ®
    inputs := make([]int, 20)
    for i := range inputs {
        inputs[i] = i + 1
    }
    
    // ä½¿ç”¨5ä¸ªå·¥ä½œè€…å¤„ç†
    results := fanOut(inputs, 5)
    
    // æ”¶é›†å’Œå¤„ç†ç»“æœ
    successful := 0
    failed := 0
    
    for result := range results {
        if result.Err != nil {
            failed++
            fmt.Printf("å¤„ç†å¤±è´¥: %v\n", result.Err)
        } else {
            successful++
            fmt.Printf("å¤„ç†æˆåŠŸ: %d\n", result.Value)
        }
    }
    
    fmt.Printf("\næ€»ç»“: æˆåŠŸ=%d, å¤±è´¥=%d\n", successful, failed)
}
```

### 4.3 å¤„ç†æµæ°´çº¿
```go
package main

import (
    "fmt"
    "sync"
)

// é˜¶æ®µ1: ç”Ÿæˆæ•°å­—åºåˆ—
func generator(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for _, n := range nums {
            out <- n
        }
    }()
    return out
}

// é˜¶æ®µ2: å¹³æ–¹æ•°å­—
func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            out <- n * n
        }
    }()
    return out
}

// é˜¶æ®µ3: è¿‡æ»¤å¶æ•°
func filterEven(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            if n%2 == 0 {
                out <- n
            }
        }
    }()
    return out
}

// é˜¶æ®µ4: æ‰‡å‡ºå¤„ç†
func fanOut(in <-chan int, n int) []<-chan int {
    // åˆ›å»ºnä¸ªè¾“å‡ºé€šé“
    outs := make([]<-chan int, n)
    for i := 0; i < n; i++ {
        outs[i] = processWorker(in, i)
    }
    return outs
}

// å·¥ä½œè€…
func processWorker(in <-chan int, id int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            fmt.Printf("å·¥ä½œè€… %d å¤„ç†: %d\n", id, n)
            out <- n * 10 // ç®€å•å¤„ç†
        }
    }()
    return out
}

// é˜¶æ®µ5: æ‰‡å…¥åˆå¹¶ç»“æœ
func fanIn(channels ...<-chan int) <-chan int {
    var wg sync.WaitGroup
    out := make(chan int)
    
    // ä¸ºæ¯ä¸ªè¾“å…¥é€šé“å¯åŠ¨ä¸€ä¸ªgoroutine
    wg.Add(len(channels))
    for _, c := range channels {
        go func(ch <-chan int) {
            defer wg.Done()
            for n := range ch {
                out <- n
            }
        }(c)
    }
    
    // ç­‰å¾…æ‰€æœ‰é€šé“å¤„ç†å®Œæ¯•
    go func() {
        wg.Wait()
        close(out)
    }()
    
    return out
}

func main() {
    // æ„å»ºå¤„ç†æµæ°´çº¿
    // é˜¶æ®µ1: ç”Ÿæˆåˆå§‹æ•°æ®
    nums := generator(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    
    // é˜¶æ®µ2: å¹³æ–¹æ“ä½œ
    squares := square(nums)
    
    // é˜¶æ®µ3: è¿‡æ»¤å¶æ•°
    evens := filterEven(squares)
    
    // é˜¶æ®µ4: æ‰‡å‡ºåˆ°3ä¸ªå·¥ä½œè€…å¹¶è¡Œå¤„ç†
    workers := fanOut(evens, 3)
    
    // é˜¶æ®µ5: æ‰‡å…¥åˆå¹¶ç»“æœ
    results := fanIn(workers...)
    
    // æ”¶é›†æœ€ç»ˆç»“æœ
    var finalResults []int
    for n := range results {
        finalResults = append(finalResults, n)
    }
    
    fmt.Println("\næœ€ç»ˆç»“æœ:", finalResults)
}
```

---

## 5. Future/Promiseæ¨¡å¼

### 5.1 åŸºæœ¬å®ç°
```go
package main

import (
    "fmt"
    "math/rand"
    "time"
)

// Futureè¡¨ç¤ºä¸€ä¸ªæœªæ¥çš„å€¼
type Future struct {
    result chan interface{}
    err    chan error
}

// åˆ›å»ºFuture
func NewFuture() *Future {
    return &Future{
        result: make(chan interface{}, 1),
        err:    make(chan error, 1),
    }
}

// è®¾ç½®ç»“æœ
func (f *Future) SetResult(result interface{}) {
    f.result <- result
    close(f.result)
    close(f.err)
}

// è®¾ç½®é”™è¯¯
func (f *Future) SetError(err error) {
    f.err <- err
    close(f.result)
    close(f.err)
}

// è·å–ç»“æœï¼ˆé˜»å¡ï¼‰
func (f *Future) Get() (interface{}, error) {
    select {
    case result := <-f.result:
        return result, nil
    case err := <-f.err:
        return nil, err
    }
}

// å¼‚æ­¥æ‰§è¡Œä»»åŠ¡å¹¶è¿”å›Future
func RunAsync(task func() (interface{}, error)) *Future {
    future := NewFuture()
    
    go func() {
        result, err := task()
        if err != nil {
            future.SetError(err)
        } else {
            future.SetResult(result)
        }
    }()
    
    return future
}

// ç¤ºä¾‹ä»»åŠ¡
func fetchData(id int) (interface{}, error) {
    // æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ
    duration := time.Duration(1+rand.Intn(3)) * time.Second
    fmt.Printf("ä»»åŠ¡%d: å¼€å§‹æ‰§è¡Œï¼Œé¢„è®¡è€—æ—¶%v\n", id, duration)
    time.Sleep(duration)
    
    // æ¨¡æ‹Ÿç»“æœ
    data := fmt.Sprintf("æ•°æ®-%d", id)
    return data, nil
}

func main() {
    rand.Seed(time.Now().UnixNano())
    
    // å¯åŠ¨å¤šä¸ªå¼‚æ­¥ä»»åŠ¡
    futures := make([]*Future, 3)
    for i := 0; i < 3; i++ {
        taskID := i + 1
        futures[i] = RunAsync(func() (interface{}, error) {
            return fetchData(taskID)
        })
    }
    
    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    for i, future := range futures {
        fmt.Printf("ç­‰å¾…ä»»åŠ¡%dç»“æœ...\n", i+1)
        result, err := future.Get()
        if err != nil {
            fmt.Printf("ä»»åŠ¡%då¤±è´¥: %v\n", i+1, err)
        } else {
            fmt.Printf("ä»»åŠ¡%dæˆåŠŸ: %v\n", i+1, result)
        }
    }
    
    fmt.Println("æ‰€æœ‰ä»»åŠ¡å·²å®Œæˆ")
}
```

### 5.2 å¸¦è¶…æ—¶çš„Future
```go
package main

import (
    "errors"
    "fmt"
    "math/rand"
    "time"
)

// å¸¦è¶…æ—¶çš„Future
type TimedFuture struct {
    result  chan interface{}
    err     chan error
    timeout time.Duration
}

// åˆ›å»ºå¸¦è¶…æ—¶çš„Future
func NewTimedFuture(timeout time.Duration) *TimedFuture {
    return &TimedFuture{
        result:  make(chan interface{}, 1),
        err:     make(chan error, 1),
        timeout: timeout,
    }
}

// è®¾ç½®ç»“æœ
func (f *TimedFuture) SetResult(result interface{}) {
    f.result <- result
}

// è®¾ç½®é”™è¯¯
func (f *TimedFuture) SetError(err error) {
    f.err <- err
}

// è·å–ç»“æœï¼ˆå¸¦è¶…æ—¶ï¼‰
func (f *TimedFuture) Get() (interface{}, error) {
    select {
    case result := <-f.result:
        return result, nil
    case err := <-f.err:
        return nil, err
    case <-time.After(f.timeout):
        return nil, errors.New("æ“ä½œè¶…æ—¶")
    }
}

// å¼‚æ­¥æ‰§è¡Œä»»åŠ¡å¹¶è¿”å›Future
func RunAsyncWithTimeout(task func() (interface{}, error), timeout time.Duration) *TimedFuture {
    future := NewTimedFuture(timeout)
    
    go func() {
        result, err := task()
        if err != nil {
            future.SetError(err)
        } else {
            future.SetResult(result)
        }
    }()
    
    return future
}

// æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ
func simulateTask(id int, shouldTimeout bool) (interface{}, error) {
    // å†³å®šæ‰§è¡Œæ—¶é—´
    var duration time.Duration
    if shouldTimeout {
        duration = 3 * time.Second // æ•…æ„è¶…æ—¶
    } else {
        duration = 1 * time.Second // æ­£å¸¸å®Œæˆ
    }
    
    fmt.Printf("ä»»åŠ¡%då¼€å§‹æ‰§è¡Œï¼Œå°†è€—æ—¶%v\n", id, duration)
    time.Sleep(duration)
    
    return fmt.Sprintf("ä»»åŠ¡%dçš„ç»“æœ", id), nil
}

func main() {
    // è®¾ç½®è¶…æ—¶ä¸º2ç§’
    timeout := 2 * time.Second
    
    fmt.Printf("å¯åŠ¨ä»»åŠ¡ï¼Œè¶…æ—¶è®¾ç½®ä¸º%v\n", timeout)
    
    // å¯åŠ¨ä¸€ä¸ªæ­£å¸¸å®Œæˆçš„ä»»åŠ¡
    future1 := RunAsyncWithTimeout(func() (interface{}, error) {
        return simulateTask(1, false)
    }, timeout)
    
    // å¯åŠ¨ä¸€ä¸ªä¼šè¶…æ—¶çš„ä»»åŠ¡
    future2 := RunAsyncWithTimeout(func() (interface{}, error) {
        return simulateTask(2, true)
    }, timeout)
    
    // è·å–ç»“æœ
    result1, err1 := future1.Get()
    if err1 != nil {
        fmt.Printf("ä»»åŠ¡1å¤±è´¥: %v\n", err1)
    } else {
        fmt.Printf("ä»»åŠ¡1æˆåŠŸ: %v\n", result1)
    }
    
    result2, err2 := future2.Get()
    if err2 != nil {
        fmt.Printf("ä»»åŠ¡2å¤±è´¥: %v\n", err2)
    } else {
        fmt.Printf("ä»»åŠ¡2æˆåŠŸ: %v\n", result2)
    }
}
```

---

## 6. å¹¶å‘æ§åˆ¶æ¨¡å¼

### 6.1 é€Ÿç‡é™åˆ¶ï¼ˆRate Limitingï¼‰
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// é€Ÿç‡é™åˆ¶å™¨
type RateLimiter struct {
    interval time.Duration
    tokens   chan struct{}
    once     sync.Once
}

// åˆ›å»ºé€Ÿç‡é™åˆ¶å™¨
func NewRateLimiter(rps int) *RateLimiter {
    return &RateLimiter{
        interval: time.Second / time.Duration(rps),
        tokens:   make(chan struct{}, 1),
    }
}

// å¼€å§‹ä»¤ç‰Œç”Ÿæˆ
func (r *RateLimiter) start() {
    go func() {
        ticker := time.NewTicker(r.interval)
        defer ticker.Stop()
        
        for range ticker.C {
            select {
            case r.tokens <- struct{}{}:
                // æˆåŠŸæ”¾å…¥ä»¤ç‰Œ
            default:
                // ä»¤ç‰Œæ§½å·²æ»¡ï¼Œä¸¢å¼ƒ
            }
        }
    }()
}

// ç­‰å¾…ä»¤ç‰Œ
func (r *RateLimiter) Wait() {
    r.once.Do(r.start)
    <-r.tokens
}

// æ¨¡æ‹ŸAPIè¯·æ±‚
func makeRequest(id int, limiter *RateLimiter) {
    limiter.Wait()
    
    fmt.Printf("[%s] è¯·æ±‚ #%d å¼€å§‹å¤„ç†\n", 
        time.Now().Format("15:04:05.000"), id)
    
    // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
    time.Sleep(50 * time.Millisecond)
}

func main() {
    // åˆ›å»ºæ¯ç§’å¤„ç†5ä¸ªè¯·æ±‚çš„é™æµå™¨
    limiter := NewRateLimiter(5)
    
    var wg sync.WaitGroup
    
    // æ¨¡æ‹Ÿ20ä¸ªå¹¶å‘è¯·æ±‚
    for i := 1; i <= 20; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            makeRequest(id, limiter)
        }(i)
    }
    
    wg.Wait()
    fmt.Println("æ‰€æœ‰è¯·æ±‚å·²å¤„ç†")
}
```

### 6.2 èµ„æºæ± æ¨¡å¼
```go
package main

import (
    "errors"
    "fmt"
    "sync"
    "time"
)

// èµ„æºæ¥å£
type Resource interface {
    DoWork() error
    Close()
}

// å…·ä½“èµ„æºå®ç°
type DBConnection struct {
    id int
}

func (db *DBConnection) DoWork() error {
    fmt.Printf("è¿æ¥ #%d æ­£åœ¨æ‰§è¡Œå·¥ä½œ\n", db.id)
    time.Sleep(100 * time.Millisecond)
    return nil
}

func (db *DBConnection) Close() {
    fmt.Printf("è¿æ¥ #%d å·²å…³é—­\n", db.id)
}

// èµ„æºå·¥å‚
type ResourceFactory func() (Resource, error)

// èµ„æºæ± 
type ResourcePool struct {
    resources chan Resource
    factory   ResourceFactory
    closed    bool
    mutex     sync.Mutex
}

// åˆ›å»ºèµ„æºæ± 
func NewResourcePool(maxResources int, factory ResourceFactory) (*ResourcePool, error) {
    pool := &ResourcePool{
        resources: make(chan Resource, maxResources),
        factory:   factory,
    }
    
    // é¢„åˆ›å»ºèµ„æº
    for i := 0; i < maxResources; i++ {
        resource, err := factory()
        if err != nil {
            pool.Close()
            return nil, fmt.Errorf("åˆå§‹åŒ–èµ„æºæ± å¤±è´¥: %v", err)
        }
        pool.resources <- resource
    }
    
    return pool, nil
}

// è·å–èµ„æº
func (p *ResourcePool) Acquire() (Resource, error) {
    p.mutex.Lock()
    defer p.mutex.Unlock()
    
    if p.closed {
        return nil, errors.New("èµ„æºæ± å·²å…³é—­")
    }
    
    select {
    case resource, ok := <-p.resources:
        if !ok {
            return nil, errors.New("èµ„æºæ± å·²å…³é—­")
        }
        return resource, nil
    default:
        // åˆ›å»ºæ–°èµ„æº
        return p.factory()
    }
}

// é‡Šæ”¾èµ„æº
func (p *ResourcePool) Release(resource Resource) error {
    p.mutex.Lock()
    defer p.mutex.Unlock()
    
    if p.closed {
        resource.Close()
        return errors.New("èµ„æºæ± å·²å…³é—­")
    }
    
    select {
    case p.resources <- resource:
        return nil
    default:
        // æ± å·²æ»¡ï¼Œå…³é—­èµ„æº
        resource.Close()
        return nil
    }
}

// å…³é—­èµ„æºæ± 
func (p *ResourcePool) Close() {
    p.mutex.Lock()
    defer p.mutex.Unlock()
    
    if p.closed {
        return
    }
    
    p.closed = true
    close(p.resources)
    
    // å…³é—­æ‰€æœ‰èµ„æº
    for resource := range p.resources {
        resource.Close()
    }
}

// ä½¿ç”¨èµ„æº
func useResource(pool *ResourcePool, id int) error {
    // è·å–èµ„æº
    resource, err := pool.Acquire()
    if err != nil {
        return err
    }
    
    // ç¡®ä¿èµ„æºè¢«é‡Šæ”¾
    defer pool.Release(resource)
    
    // ä½¿ç”¨èµ„æº
    fmt.Printf("å·¥ä½œè€… %d è·å–äº†èµ„æº\n", id)
    return resource.DoWork()
}

func main() {
    // åˆ›å»ºèµ„æºå·¥å‚
    factory := func() (Resource, error) {
        static := 0
        static++
        return &DBConnection{id: static}, nil
    }
    
    // åˆ›å»ºèµ„æºæ± ï¼Œæœ€å¤š5ä¸ªè¿æ¥
    pool, err := NewResourcePool(5, factory)
    if err != nil {
        fmt.Printf("åˆ›å»ºèµ„æºæ± å¤±è´¥: %v\n", err)
        return
    }
    defer pool.Close()
    
    // æ¨¡æ‹Ÿ20ä¸ªå¹¶å‘å·¥ä½œè€…
    var wg sync.WaitGroup
    for i := 1; i <= 20; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            if err := useResource(pool, id); err != nil {
                fmt.Printf("å·¥ä½œè€… %d ä½¿ç”¨èµ„æºå¤±è´¥: %v\n", id, err)
            }
        }(i)
    }
    
    wg.Wait()
    fmt.Println("æ‰€æœ‰å·¥ä½œå·²å®Œæˆ")
}
```

### 6.3 ç†”æ–­å™¨æ¨¡å¼
```go
package main

import (
    "errors"
    "fmt"
    "math/rand"
    "sync"
    "time"
)

// ç†”æ–­å™¨çŠ¶æ€
type CircuitState int

const (
    StateClosed CircuitState = iota // å…³é—­çŠ¶æ€ï¼ˆæ­£å¸¸å·¥ä½œï¼‰
    StateOpen                        // å¼€å¯çŠ¶æ€ï¼ˆåœæ­¢å·¥ä½œï¼‰
    StateHalfOpen                    // åŠå¼€çŠ¶æ€ï¼ˆå°è¯•æ¢å¤ï¼‰
)

// ç†”æ–­å™¨é…ç½®
type CircuitBreakerConfig struct {
    Timeout           time.Duration // ç†”æ–­å™¨å¼€å¯çŠ¶æ€æŒç»­æ—¶é—´
    FailureThreshold  int           // è§¦å‘ç†”æ–­çš„å¤±è´¥æ¬¡æ•°é˜ˆå€¼
    SuccessThreshold  int           // åŠå¼€çŠ¶æ€ä¸‹æˆåŠŸæ¬¡æ•°é˜ˆå€¼
    MaxConcurrentCalls int          // æœ€å¤§å¹¶å‘è¯·æ±‚æ•°
}

// ç†”æ–­å™¨
type CircuitBreaker struct {
    name              string
    state             CircuitState
    config            CircuitBreakerConfig
    
    mutex             sync.RWMutex
    failures          int       // è¿ç»­å¤±è´¥æ¬¡æ•°
    successes         int       // åŠå¼€çŠ¶æ€ä¸‹è¿ç»­æˆåŠŸæ¬¡æ•°
    lastStateChange   time.Time // æœ€åçŠ¶æ€å˜æ›´æ—¶é—´
    activeCalls       int       // å½“å‰æ´»è·ƒè¯·æ±‚æ•°
}

// åˆ›å»ºæ–°ç†”æ–­å™¨
func NewCircuitBreaker(name string, config CircuitBreakerConfig) *CircuitBreaker {
    return &CircuitBreaker{
        name:            name,
        state:           StateClosed,
        config:          config,
        lastStateChange: time.Now(),
    }
}

// æ‰§è¡Œå—ä¿æŠ¤çš„å‡½æ•°
func (cb *CircuitBreaker) Execute(fn func() error) error {
    // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ‰§è¡Œ
    if err := cb.beforeExecution(); err != nil {
        return err
    }
    
    // è®°å½•æ´»è·ƒè¯·æ±‚
    cb.incrementActiveCalls()
    defer cb.decrementActiveCalls()
    
    // æ‰§è¡Œå‡½æ•°
    err := fn()
    
    // å¤„ç†ç»“æœ
    cb.afterExecution(err)
    
    return err
}

// æ‰§è¡Œå‰æ£€æŸ¥
func (cb *CircuitBreaker) beforeExecution() error {
    cb.mutex.RLock()
    defer cb.mutex.RUnlock()
    
    // æ£€æŸ¥æ´»è·ƒè¯·æ±‚æ•°
    if cb.activeCalls >= cb.config.MaxConcurrentCalls {
        return errors.New("ç†”æ–­å™¨: è¶…è¿‡æœ€å¤§å¹¶å‘è¯·æ±‚æ•°")
    }
    
    // æ£€æŸ¥ç†”æ–­å™¨çŠ¶æ€
    switch cb.state {
    case StateOpen:
        // æ£€æŸ¥æ˜¯å¦åº”è¯¥åˆ‡æ¢åˆ°åŠå¼€çŠ¶æ€
        if time.Since(cb.lastStateChange) > cb.config.Timeout {
            // å…è®¸ä¸€ä¸ªè¯·æ±‚å°è¯•
            cb.mutex.RUnlock()
            cb.mutex.Lock()
            if cb.state == StateOpen {
                fmt.Printf("ç†”æ–­å™¨ '%s': ä»å¼€å¯çŠ¶æ€åˆ‡æ¢åˆ°åŠå¼€çŠ¶æ€\n", cb.name)
                cb.state = StateHalfOpen
                cb.lastStateChange = time.Now()
            }
            cb.mutex.Unlock()
            cb.mutex.RLock()
            return nil
        }
        return fmt.Errorf("ç†”æ–­å™¨ '%s': å¼€å¯çŠ¶æ€ï¼Œæ‹’ç»è¯·æ±‚", cb.name)
        
    case StateHalfOpen:
        // åªå…è®¸ä¸€ä¸ªè¯·æ±‚é€šè¿‡
        if cb.activeCalls > 0 {
            return fmt.Errorf("ç†”æ–­å™¨ '%s': åŠå¼€çŠ¶æ€ï¼Œå·²æœ‰è¯·æ±‚æ­£åœ¨å¤„ç†", cb.name)
        }
        return nil
        
    default: // StateClosed
        return nil
    }
}

// æ‰§è¡Œåå¤„ç†
func (cb *CircuitBreaker) afterExecution(err error) {
    cb.mutex.Lock()
    defer cb.mutex.Unlock()
    
    if err != nil {
        // å¤„ç†å¤±è´¥
        cb.failures++
        cb.successes = 0
        
        fmt.Printf("ç†”æ–­å™¨ '%s': æ‰§è¡Œå¤±è´¥ (%d/%d)\n", 
            cb.name, cb.failures, cb.config.FailureThreshold)
        
        if (cb.state == StateClosed && cb.failures >= cb.config.FailureThreshold) ||
           (cb.state == StateHalfOpen) {
            fmt.Printf("ç†”æ–­å™¨ '%s': åˆ‡æ¢åˆ°å¼€å¯çŠ¶æ€\n", cb.name)
            cb.state = StateOpen
            cb.lastStateChange = time.Now()
        }
    } else {
        // å¤„ç†æˆåŠŸ
        cb.failures = 0
        
        if cb.state == StateHalfOpen {
            cb.successes++
            fmt.Printf("ç†”æ–­å™¨ '%s': åŠå¼€çŠ¶æ€ä¸‹æˆåŠŸ (%d/%d)\n", 
                cb.name, cb.successes, cb.config.SuccessThreshold)
            
            if cb.successes >= cb.config.SuccessThreshold {
                fmt.Printf("ç†”æ–­å™¨ '%s': åˆ‡æ¢åˆ°å…³é—­çŠ¶æ€\n", cb.name)
                cb.state = StateClosed
                cb.lastStateChange = time.Now()
                cb.successes = 0
            }
        }
    }
}

// å¢åŠ æ´»è·ƒè¯·æ±‚è®¡æ•°
func (cb *CircuitBreaker) incrementActiveCalls() {
    cb.mutex.Lock()
    defer cb.mutex.Unlock()
    cb.activeCalls++
}

// å‡å°‘æ´»è·ƒè¯·æ±‚è®¡æ•°
func (cb *CircuitBreaker) decrementActiveCalls() {
    cb.mutex.Lock()
    defer cb.mutex.Unlock()
    cb.activeCalls--
}

// è·å–å½“å‰çŠ¶æ€
func (cb *CircuitBreaker) GetState() CircuitState {
    cb.mutex.RLock()
    defer cb.mutex.RUnlock()
    return cb.state
}

// æ¨¡æ‹Ÿè¿œç¨‹æœåŠ¡è°ƒç”¨
func callRemoteService(failRate float64) error {
    // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
    time.Sleep(time.Duration(50+rand.Intn(50)) * time.Millisecond)
    
    // æ¨¡æ‹Ÿå¤±è´¥
    if rand.Float64() < failRate {
        return errors.New("æœåŠ¡è°ƒç”¨å¤±è´¥")
    }
    
    return nil
}

func main() {
    rand.Seed(time.Now().UnixNano())
    
    // åˆ›å»ºç†”æ–­å™¨
    cb := NewCircuitBreaker("RemoteService", CircuitBreakerConfig{
        Timeout:           5 * time.Second,  // ç†”æ–­å™¨å¼€å¯5ç§’åå°è¯•æ¢å¤
        FailureThreshold:  3,                // 3æ¬¡å¤±è´¥åç†”æ–­
        SuccessThreshold:  2,                // åŠå¼€çŠ¶æ€ä¸‹2æ¬¡æˆåŠŸåæ¢å¤
        MaxConcurrentCalls: 10,              // æœ€å¤š10ä¸ªå¹¶å‘è¯·æ±‚
    })
    
    // è¿è¡Œæµ‹è¯•
    var wg sync.WaitGroup
    
    // ç¬¬ä¸€é˜¶æ®µï¼šæ¨¡æ‹Ÿæ­£å¸¸è°ƒç”¨ï¼Œå¶å°”å¤±è´¥
    fmt.Println("\n=== é˜¶æ®µ1: æ­£å¸¸è°ƒç”¨ï¼Œå¶å°”å¤±è´¥ ===")
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            err := cb.Execute(func() error {
                return callRemoteService(0.2) // 20%çš„å¤±è´¥ç‡
            })
            
            if err != nil {
                fmt.Printf("è¯·æ±‚ %d å¤±è´¥: %v\n", id, err)
            } else {
                fmt.Printf("è¯·æ±‚ %d æˆåŠŸ\n", id)
            }
        }(i)
        time.Sleep(100 * time.Millisecond)
    }
    wg.Wait()
    
    // ç¬¬äºŒé˜¶æ®µï¼šæ¨¡æ‹ŸæœåŠ¡æ•…éšœï¼Œé«˜å¤±è´¥ç‡
    fmt.Println("\n=== é˜¶æ®µ2: æœåŠ¡æ•…éšœï¼Œé«˜å¤±è´¥ç‡ ===")
    for i := 10; i < 20; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            err := cb.Execute(func() error {
                return callRemoteService(0.8) // 80%çš„å¤±è´¥ç‡
            })
            
            if err != nil {
                fmt.Printf("è¯·æ±‚ %d å¤±è´¥: %v\n", id, err)
            } else {
                fmt.Printf("è¯·æ±‚ %d æˆåŠŸ\n", id)
            }
        }(i)
        time.Sleep(100 * time.Millisecond)
    }
    wg.Wait()
    
    // ç¬¬ä¸‰é˜¶æ®µï¼šç†”æ–­å™¨å¼€å¯ï¼Œè¯·æ±‚è¢«æ‹’ç»
    fmt.Println("\n=== é˜¶æ®µ3: ç†”æ–­å™¨å¼€å¯ï¼Œè¯·æ±‚è¢«æ‹’ç» ===")
    for i := 20; i < 25; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            err := cb.Execute(func() error {
                return callRemoteService(0.0) // æœåŠ¡å·²æ¢å¤ï¼Œä½†ç†”æ–­å™¨ä»ç„¶å¼€å¯
            })
            
            if err != nil {
                fmt.Printf("è¯·æ±‚ %d å¤±è´¥: %v\n", id, err)
            } else {
                fmt.Printf("è¯·æ±‚ %d æˆåŠŸ\n", id)
            }
        }(i)
        time.Sleep(100 * time.Millisecond)
    }
    wg.Wait()
    
    // ç¬¬å››é˜¶æ®µï¼šç­‰å¾…ç†”æ–­å™¨è¿›å…¥åŠå¼€çŠ¶æ€
    fmt.Println("\n=== é˜¶æ®µ4: ç­‰å¾…ç†”æ–­å™¨è¿›å…¥åŠå¼€çŠ¶æ€ ===")
    fmt.Println("ç­‰å¾…5ç§’...")
    time.Sleep(5 * time.Second)
    
    // ç¬¬äº”é˜¶æ®µï¼šç†”æ–­å™¨åŠå¼€ï¼Œå°è¯•æ¢å¤
    fmt.Println("\n=== é˜¶æ®µ5: ç†”æ–­å™¨åŠå¼€ï¼Œå°è¯•æ¢å¤ ===")
    for i := 25; i < 30; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            err := cb.Execute(func() error {
                return callRemoteService(0.0) // æœåŠ¡å·²å®Œå…¨æ¢å¤
            })
            
            if err != nil {
                fmt.Printf("è¯·æ±‚ %d å¤±è´¥: %v\n", id, err)
            } else {
                fmt.Printf("è¯·æ±‚ %d æˆåŠŸ\n", id)
            }
        }(i)
        time.Sleep(500 * time.Millisecond)
    }
    wg.Wait()
    
    fmt.Printf("\næœ€ç»ˆç†”æ–­å™¨çŠ¶æ€: %v\n", cb.GetState())
}
```

---

## 7. ç»¼åˆæ¡ˆä¾‹ï¼šå¼‚æ­¥çˆ¬è™«ç³»ç»Ÿ
```go
package main

import (
    "context"
    "encoding/json"
    "errors"
    "fmt"
    "io"
    "math/rand"
    "net/http"
    "os"
    "sync"
    "time"
)

// URLçŠ¶æ€
type URLStatus int

const (
    StatusPending URLStatus = iota
    StatusProcessing
    StatusDone
    StatusError
)

// URLä¿¡æ¯
type URLInfo struct {
    URL    string
    Depth  int
    Status URLStatus
    Error  error
}

// é¡µé¢æ•°æ®
type PageData struct {
    URL      string
    Title    string
    Links    []string
    Content  string
    FetchedAt time.Time
}

// çˆ¬è™«é…ç½®
type CrawlerConfig struct {
    MaxDepth      int
    MaxWorkers    int
    MaxRetries    int
    RequestDelay  time.Duration
    Timeout       time.Duration
    UserAgent     string
}

// çˆ¬è™«
type Crawler struct {
    config  CrawlerConfig
    visited sync.Map
    queue   chan URLInfo
    results chan PageData
    errors  chan URLInfo
    wg      sync.WaitGroup
    client  *http.Client
}

// åˆ›å»ºæ–°çˆ¬è™«
func NewCrawler(config CrawlerConfig) *Crawler {
    client := &http.Client{
        Timeout: config.Timeout,
    }
    
    return &Crawler{
        config:  config,
        queue:   make(chan URLInfo, 1000),
        results: make(chan PageData, 1000),
        errors:  make(chan URLInfo, 1000),
        client:  client,
    }
}

// æ·»åŠ URLåˆ°é˜Ÿåˆ—
func (c *Crawler) AddURL(url string, depth int) {
    urlInfo := URLInfo{
        URL:    url,
        Depth:  depth,
        Status: StatusPending,
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²è®¿é—®
    if _, exists := c.visited.LoadOrStore(url, urlInfo); !exists {
        c.queue <- urlInfo
    }
}

// å¯åŠ¨çˆ¬è™«
func (c *Crawler) Start(ctx context.Context, seeds []string) {
    // æ·»åŠ ç§å­URL
    for _, url := range seeds {
        c.AddURL(url, 0)
    }
    
    // å¯åŠ¨å·¥ä½œè€…
    for i := 0; i < c.config.MaxWorkers; i++ {
        c.wg.Add(1)
        go c.worker(ctx, i)
    }
    
    // å¯åŠ¨ç»“æœå¤„ç†å™¨
    c.wg.Add(1)
    go c.resultProcessor(ctx)
    
    // å¯åŠ¨é”™è¯¯å¤„ç†å™¨
    c.wg.Add(1)
    go c.errorProcessor(ctx)
    
    // ç­‰å¾…æ‰€æœ‰å·¥ä½œå®Œæˆ
    go func() {
        c.wg.Wait()
        close(c.results)
        close(c.errors)
    }()
}

// å·¥ä½œè€…
func (c *Crawler) worker(ctx context.Context, id int) {
    defer c.wg.Done()
    
    for {
        select {
        case <-ctx.Done():
            fmt.Printf("å·¥ä½œè€… %d: æ”¶åˆ°å–æ¶ˆä¿¡å·ï¼Œé€€å‡º\n", id)
            return
            
        case urlInfo, ok := <-c.queue:
            if !ok {
                fmt.Printf("å·¥ä½œè€… %d: é˜Ÿåˆ—å·²å…³é—­ï¼Œé€€å‡º\n", id)
                return
            }
            
            // å¤„ç†URL
            c.processURL(ctx, urlInfo, id)
            
            // è¯·æ±‚å»¶è¿Ÿ
            select {
            case <-ctx.Done():
                return
            case <-time.After(c.config.RequestDelay):
                // ç»§ç»­ä¸‹ä¸€ä¸ªURL
            }
        }
    }
}

// å¤„ç†URL
func (c *Crawler) processURL(ctx context.Context, urlInfo URLInfo, workerID int) {
    // æ›´æ–°çŠ¶æ€
    urlInfo.Status = StatusProcessing
    c.visited.Store(urlInfo.URL, urlInfo)
    
    fmt.Printf("å·¥ä½œè€… %d: çˆ¬å– %s (æ·±åº¦: %d)\n", workerID, urlInfo.URL, urlInfo.Depth)
    
    var lastError error
    
    // é‡è¯•æœºåˆ¶
    for attempt := 0; attempt < c.config.MaxRetries; attempt++ {
        // æ£€æŸ¥å–æ¶ˆ
        select {
        case <-ctx.Done():
            return
        default:
            // ç»§ç»­å¤„ç†
        }
        
        // å¦‚æœæ˜¯é‡è¯•ï¼Œç­‰å¾…ä¸€æ®µæ—¶é—´
        if attempt > 0 {
            backoff := time.Duration(attempt*500) * time.Millisecond
            fmt.Printf("å·¥ä½œè€… %d: é‡è¯• %s (å°è¯• %d/%d)ï¼Œç­‰å¾… %v\n", 
                workerID, urlInfo.URL, attempt+1, c.config.MaxRetries, backoff)
            time.Sleep(backoff)
        }
        
        // æŠ“å–é¡µé¢
        pageData, err := c.fetchURL(ctx, urlInfo.URL)
        if err != nil {
            lastError = err
            continue // é‡è¯•
        }
        
        // æˆåŠŸæŠ“å–ï¼Œå¤„ç†ç»“æœ
        c.results <- pageData
        
        // å¦‚æœæœªè¾¾åˆ°æœ€å¤§æ·±åº¦ï¼Œå°†é“¾æ¥æ·»åŠ åˆ°é˜Ÿåˆ—
        if urlInfo.Depth < c.config.MaxDepth {
            for _, link := range pageData.Links {
                c.AddURL(link, urlInfo.Depth+1)
            }
        }
        
        // æ›´æ–°çŠ¶æ€ä¸ºå®Œæˆ
        urlInfo.Status = StatusDone
        c.visited.Store(urlInfo.URL, urlInfo)
        return
    }
    
    // æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥
    urlInfo.Status = StatusError
    urlInfo.Error = lastError
    c.visited.Store(urlInfo.URL, urlInfo)
    c.errors <- urlInfo
}

// æŠ“å–URLï¼ˆæ¨¡æ‹Ÿï¼‰
func (c *Crawler) fetchURL(ctx context.Context, url string) (PageData, error) {
    // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
    time.Sleep(time.Duration(100+rand.Intn(500)) * time.Millisecond)
    
    // æ¨¡æ‹Ÿéšæœºå¤±è´¥
    if rand.Float64() < 0.2 {
        return PageData{}, errors.New("éšæœºç½‘ç»œé”™è¯¯")
    }
    
    // æ¨¡æ‹Ÿé¡µé¢æ•°æ®
    return PageData{
        URL:      url,
        Title:    fmt.Sprintf("é¡µé¢æ ‡é¢˜ - %s", url),
        Links:    generateRandomLinks(url, 3+rand.Intn(5)),
        Content:  fmt.Sprintf("é¡µé¢ %s çš„å†…å®¹", url),
        FetchedAt: time.Now(),
    }, nil
}

// ç”Ÿæˆéšæœºé“¾æ¥ï¼ˆæ¨¡æ‹Ÿï¼‰
func generateRandomLinks(baseURL string, count int) []string {
    links := make([]string, count)
    for i := 0; i < count; i++ {
        links[i] = fmt.Sprintf("%s/link-%d", baseURL, rand.Intn(1000))
    }
    return links
}

// ç»“æœå¤„ç†å™¨
func (c *Crawler) resultProcessor(ctx context.Context) {
    defer c.wg.Done()
    
    // åˆ›å»ºç»“æœæ–‡ä»¶
    file, err := os.Create("crawler_results.json")
    if err != nil {
        fmt.Printf("åˆ›å»ºç»“æœæ–‡ä»¶å¤±è´¥: %v\n", err)
        return
    }
    defer file.Close()
    
    // å†™å…¥æ–‡ä»¶å¤´
    file.WriteString("[\n")
    
    encoder := json.NewEncoder(file)
    first := true
    
    for {
        select {
        case <-ctx.Done():
            fmt.Println("ç»“æœå¤„ç†å™¨: æ”¶åˆ°å–æ¶ˆä¿¡å·ï¼Œé€€å‡º")
            file.WriteString("\n]")
            return
            
        case result, ok := <-c.results:
            if !ok {
                fmt.Println("ç»“æœå¤„ç†å™¨: ç»“æœé€šé“å·²å…³é—­ï¼Œé€€å‡º")
                file.WriteString("\n]")
                return
            }
            
            // å†™å…¥ç»“æœ
            if !first {
                file.WriteString(",\n")
            }
            first = false
            encoder.Encode(result)
            
            fmt.Printf("é¡µé¢å·²ä¿å­˜: %s (é“¾æ¥æ•°: %d)\n", result.URL, len(result.Links))
        }
    }
}

// é”™è¯¯å¤„ç†å™¨
func (c *Crawler) errorProcessor(ctx context.Context) {
    defer c.wg.Done()
    
    // åˆ›å»ºé”™è¯¯æ—¥å¿—æ–‡ä»¶
    file, err := os.Create("crawler_errors.log")
    if err != nil {
        fmt.Printf("åˆ›å»ºé”™è¯¯æ—¥å¿—æ–‡ä»¶å¤±è´¥: %v\n", err)
        return
    }
    defer file.Close()
    
    for {
        select {
        case <-ctx.Done():
            fmt.Println("é”™è¯¯å¤„ç†å™¨: æ”¶åˆ°å–æ¶ˆä¿¡å·ï¼Œé€€å‡º")
            return
            
        case errorInfo, ok := <-c.errors:
            if !ok {
                fmt.Println("é”™è¯¯å¤„ç†å™¨: é”™è¯¯é€šé“å·²å…³é—­ï¼Œé€€å‡º")
                return
            }
            
            // å†™å…¥é”™è¯¯æ—¥å¿—
            logEntry := fmt.Sprintf("[%s] çˆ¬å– %s å¤±è´¥: %v\n", 
                time.Now().Format(time.RFC3339), errorInfo.URL, errorInfo.Error)
            file.WriteString(logEntry)
            
            fmt.Printf("é”™è¯¯å·²è®°å½•: %s - %v\n", errorInfo.URL, errorInfo.Error)
        }
    }
}

func main() {
    // è®¾ç½®éšæœºæ•°ç§å­
    rand.Seed(time.Now().UnixNano())
    
    // çˆ¬è™«é…ç½®
    config := CrawlerConfig{
        MaxDepth:     3,
        MaxWorkers:   5,
        MaxRetries:   3,
        RequestDelay: 200 * time.Millisecond,
        Timeout:      10 * time.Second,
        UserAgent:    "GoCrawler/1.0",
    }
    
    // åˆ›å»ºçˆ¬è™«
    crawler := NewCrawler(config)
    
    // åˆ›å»ºå¯å–æ¶ˆçš„ä¸Šä¸‹æ–‡
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    // å¯åŠ¨çˆ¬è™«
    seeds := []string{
        "https://example.com",
        "https://example.org",
        "https://example.net",
    }
    
    fmt.Println("å¼€å§‹çˆ¬å–...")
    crawler.Start(ctx, seeds)
    
    // ç­‰å¾…çˆ¬å–å®Œæˆæˆ–è¶…æ—¶
    <-ctx.Done()
    if errors.Is(ctx.Err(), context.DeadlineExceeded) {
        fmt.Println("\nçˆ¬å–è¶…æ—¶")
    } else {
        fmt.Println("\nçˆ¬å–è¢«å–æ¶ˆ")
    }
    
    fmt.Println("çˆ¬å–å®Œæˆ")
}
```

---

## 8. å­¦ä¹ æ£€æŸ¥ç‚¹

- [ ] ç†è§£ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼çš„åŸºæœ¬å®ç°å’Œå˜ç§
- [ ] æŒæ¡å·¥ä½œæ± æ¨¡å¼çš„ç‰¹ç‚¹å’Œåº”ç”¨åœºæ™¯
- [ ] èƒ½ç”¨å‘å¸ƒè®¢é˜…æ¨¡å¼å®ç°æ¶ˆæ¯åˆ†å‘å’Œä¸»é¢˜è®¢é˜…
- [ ] ç†è§£æ‰‡å…¥æ‰‡å‡ºæ¨¡å¼çš„è®¾è®¡æ€æƒ³å’Œæµæ°´çº¿å¤„ç†
- [ ] æŒæ¡Future/Promiseæ¨¡å¼å¼‚æ­¥å¤„ç†ä»»åŠ¡
- [ ] ç†è§£å¹¶å‘æ§åˆ¶æ¨¡å¼å¦‚é€Ÿç‡é™åˆ¶ã€èµ„æºæ± å’Œç†”æ–­å™¨
- [ ] èƒ½å°†å¤šç§å¹¶å‘æ¨¡å¼ç»„åˆå®ç°å¤æ‚çš„å¹¶å‘ç³»ç»Ÿ

---

å¹¶å‘è®¾è®¡æ¨¡å¼æ˜¯Goè¯­è¨€å¹¶å‘ç¼–ç¨‹çš„é«˜çº§åº”ç”¨ï¼ŒæŒæ¡è¿™äº›æ¨¡å¼å°†æ˜¾è‘—æå‡ç¨‹åºçš„è®¾è®¡èƒ½åŠ›å’Œæ€§èƒ½ä¼˜åŒ–æ°´å¹³ã€‚æ¯ç§æ¨¡å¼éƒ½æœ‰å…¶ç‰¹å®šçš„åº”ç”¨åœºæ™¯å’Œä¼˜åŠ¿ï¼Œåœ¨å®é™…é¡¹ç›®ä¸­å¯ä»¥æ ¹æ®éœ€æ±‚çµæ´»ç»„åˆä½¿ç”¨ï¼Œæ„å»ºé«˜æ•ˆã€å¯é çš„å¹¶å‘ç³»ç»Ÿã€‚
