# Go语言并发设计模式

## 📚 学习目标
掌握Go语言的经典并发设计模式，理解并发编程的最佳实践。

---

## 1. 生产者-消费者模式

### 1.1 基本实现
```go
package main

import (
    "fmt"
    "time"
)

func producer(ch chan int) {
    for i := 1; i <= 5; i++ {
        fmt.Printf("生产者: 生产数据 %d\n", i)
        ch <- i
        time.Sleep(time.Millisecond * 500)
    }
    close(ch) // 生产完成后关闭Channel
}

func consumer(ch chan int) {
    for value := range ch {
        fmt.Printf("消费者: 消费数据 %d\n", value)
        time.Sleep(time.Millisecond * 800)
    }
}

func main() {
    ch := make(chan int, 3)
    go producer(ch)
    consumer(ch)
}
```

---

## 2. 工作池模式

### 2.1 基本实现
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, tasks <-chan int, wg *sync.WaitGroup) {
    defer wg.Done()
    for task := range tasks {
        fmt.Printf("工人%d处理任务%d\n", id, task)
        time.Sleep(time.Second)
    }
}

func main() {
    const numWorkers = 3
    const numTasks = 10

    tasks := make(chan int, numTasks)
    var wg sync.WaitGroup

    // 创建工人
    for i := 1; i <= numWorkers; i++ {
        wg.Add(1)
        go worker(i, tasks, &wg)
    }

    // 分发任务
    for i := 1; i <= numTasks; i++ {
        tasks <- i
    }
    close(tasks) // 关闭任务Channel

    wg.Wait()
    fmt.Println("所有任务处理完成")
}
```

---

## 3. 发布订阅模式

### 3.1 基本实现
```go
package main

import (
    "fmt"
    "sync"
)

type Publisher struct {
    subscribers []chan string
    mux         sync.Mutex
}

func (p *Publisher) Subscribe() chan string {
    p.mux.Lock()
    defer p.mux.Unlock()

    ch := make(chan string)
    p.subscribers = append(p.subscribers, ch)
    return ch
}

func (p *Publisher) Publish(message string) {
    p.mux.Lock()
    defer p.mux.Unlock()

    for _, ch := range p.subscribers {
        ch <- message
    }
}

func main() {
    publisher := &Publisher{}

    sub1 := publisher.Subscribe()
    sub2 := publisher.Subscribe()

    go func() {
        for msg := range sub1 {
            fmt.Printf("订阅者1收到: %s\n", msg)
        }
    }()

    go func() {
        for msg := range sub2 {
            fmt.Printf("订阅者2收到: %s\n", msg)
        }
    }()

    publisher.Publish("消息1")
    publisher.Publish("消息2")
}
```

---

## 4. 扇入扇出模式

### 4.1 基本实现
```go
package main

import (
    "fmt"
    "sync"
)

func fanOut(input <-chan int, workers int) []chan int {
    outputs := make([]chan int, workers)
    for i := range outputs {
        outputs[i] = make(chan int)
        go func(ch chan int) {
            for value := range input {
                ch <- value * 2 // 模拟处理
            }
            close(ch)
        }(outputs[i])
    }
    return outputs
}

func fanIn(inputs []chan int) <-chan int {
    output := make(chan int)
    var wg sync.WaitGroup

    for _, ch := range inputs {
        wg.Add(1)
        go func(ch chan int) {
            defer wg.Done()
            for value := range ch {
                output <- value
            }
        }(ch)
    }

    go func() {
        wg.Wait()
        close(output)
    }()

    return output
}

func main() {
    input := make(chan int, 10)
    for i := 1; i <= 10; i++ {
        input <- i
    }
    close(input)

    outputs := fanOut(input, 3)
    result := fanIn(outputs)

    for value := range result {
        fmt.Println("最终结果:", value)
    }
}
```

---

## 5. 综合案例：任务调度系统
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type Task struct {
    ID   int
    Name string
}

func worker(id int, tasks <-chan Task, wg *sync.WaitGroup) {
    defer wg.Done()
    for task := range tasks {
        fmt.Printf("工人%d处理任务%d: %s\n", id, task.ID, task.Name)
        time.Sleep(time.Second)
    }
}

func main() {
    const numWorkers = 3
    const numTasks = 10

    tasks := make(chan Task, numTasks)
    var wg sync.WaitGroup

    // 创建工人
    for i := 1; i <= numWorkers; i++ {
        wg.Add(1)
        go worker(i, tasks, &wg)
    }

    // 分发任务
    for i := 1; i <= numTasks; i++ {
        tasks <- Task{ID: i, Name: fmt.Sprintf("任务%d", i)}
    }
    close(tasks) // 关闭任务Channel

    wg.Wait()
    fmt.Println("所有任务处理完成")
}
```

---

## 6. 学习检查点

- [ ] 理解生产者-消费者模式的基本实现
- [ ] 掌握工作池模式的特点和应用场景
- [ ] 能用发布订阅模式实现消息分发
- [ ] 理解扇入扇出模式的设计思想
- [ ] 能用并发设计模式实现复杂的任务调度

---

并发设计模式是Go语言并发编程的高级应用，掌握这些模式将显著提升程序的设计能力和性能优化水平。
