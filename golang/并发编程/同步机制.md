# Goè¯­è¨€åŒæ­¥æœºåˆ¶

## ğŸ“š å­¦ä¹ ç›®æ ‡
æŒæ¡Goè¯­è¨€çš„åŒæ­¥æœºåˆ¶ï¼ŒåŒ…æ‹¬äº’æ–¥é”ã€è¯»å†™é”ã€æ¡ä»¶å˜é‡ç­‰ï¼Œç†è§£å¹¶å‘å®‰å…¨çš„å®ç°æ–¹å¼ã€‚

---

## 1. äº’æ–¥é”

### 1.1 ä½¿ç”¨`sync.Mutex`å®ç°äº’æ–¥
```go
package main

import (
    "fmt"
    "sync"
)

var (
    counter int
    mutex   sync.Mutex
)

func increment() {
    for i := 0; i < 1000; i++ {
        mutex.Lock()   // åŠ é”
        counter++
        mutex.Unlock() // è§£é”
    }
}

func main() {
    var wg sync.WaitGroup
    wg.Add(2)

    go func() {
        defer wg.Done()
        increment()
    }()

    go func() {
        defer wg.Done()
        increment()
    }()

    wg.Wait()
    fmt.Println("æœ€ç»ˆè®¡æ•°å™¨å€¼:", counter)
}
```

---

## 2. è¯»å†™é”

### 2.1 ä½¿ç”¨`sync.RWMutex`å®ç°è¯»å†™é”
```go
package main

import (
    "fmt"
    "sync"
)

var (
    data  int
    rwMux sync.RWMutex
)

func readData() {
    rwMux.RLock() // åŠ è¯»é”
    fmt.Println("è¯»å–æ•°æ®:", data)
    rwMux.RUnlock() // è§£è¯»é”
}

func writeData(value int) {
    rwMux.Lock() // åŠ å†™é”
    data = value
    fmt.Println("å†™å…¥æ•°æ®:", data)
    rwMux.Unlock() // è§£å†™é”
}

func main() {
    var wg sync.WaitGroup
    wg.Add(3)

    go func() {
        defer wg.Done()
        writeData(42)
    }()

    go func() {
        defer wg.Done()
        readData()
    }()

    go func() {
        defer wg.Done()
        readData()
    }()

    wg.Wait()
}
```

---

## 3. æ¡ä»¶å˜é‡

### 3.1 ä½¿ç”¨`sync.Cond`å®ç°æ¡ä»¶å˜é‡
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

var (
    ready bool
    cond  = sync.NewCond(&sync.Mutex{})
)

func worker(id int) {
    cond.L.Lock()
    for !ready {
        cond.Wait() // ç­‰å¾…æ¡ä»¶æ»¡è¶³
    }
    fmt.Printf("å·¥äºº%då¼€å§‹å·¥ä½œ\n", id)
    cond.L.Unlock()
}

func main() {
    for i := 1; i <= 3; i++ {
        go worker(i)
    }

    time.Sleep(time.Second)
    cond.L.Lock()
    ready = true
    cond.L.Unlock()
    cond.Broadcast() // é€šçŸ¥æ‰€æœ‰ç­‰å¾…çš„åç¨‹
}
```

---

## 4. åŸå­æ“ä½œ

### 4.1 ä½¿ç”¨`sync/atomic`å®ç°åŸå­æ“ä½œ
```go
package main

import (
    "fmt"
    "sync/atomic"
)

var counter int64

func increment() {
    for i := 0; i < 1000; i++ {
        atomic.AddInt64(&counter, 1) // åŸå­åŠ æ“ä½œ
    }
}

func main() {
    var wg sync.WaitGroup
    wg.Add(2)

    go func() {
        defer wg.Done()
        increment()
    }()

    go func() {
        defer wg.Done()
        increment()
    }()

    wg.Wait()
    fmt.Println("æœ€ç»ˆè®¡æ•°å™¨å€¼:", counter)
}
```

---

## 5. ç»¼åˆæ¡ˆä¾‹ï¼šå¹¶å‘å®‰å…¨çš„ç¼“å­˜
```go
package main

import (
    "fmt"
    "sync"
)

type Cache struct {
    data map[string]string
    mux  sync.RWMutex
}

func (c *Cache) Get(key string) string {
    c.mux.RLock()
    defer c.mux.RUnlock()
    return c.data[key]
}

func (c *Cache) Set(key, value string) {
    c.mux.Lock()
    defer c.mux.Unlock()
    c.data[key] = value
}

func main() {
    cache := Cache{data: make(map[string]string)}

    var wg sync.WaitGroup
    wg.Add(2)

    go func() {
        defer wg.Done()
        cache.Set("name", "Goè¯­è¨€")
    }()

    go func() {
        defer wg.Done()
        fmt.Println("è¯»å–ç¼“å­˜:", cache.Get("name"))
    }()

    wg.Wait()
}
```

---

## 6. å­¦ä¹ æ£€æŸ¥ç‚¹

- [ ] ç†è§£äº’æ–¥é”çš„åŸºæœ¬æ¦‚å¿µå’Œä½¿ç”¨æ–¹å¼
- [ ] æŒæ¡è¯»å†™é”çš„ç‰¹ç‚¹å’Œåº”ç”¨åœºæ™¯
- [ ] èƒ½ç”¨æ¡ä»¶å˜é‡å®ç°å¤æ‚çš„åŒæ­¥é€»è¾‘
- [ ] ç†è§£åŸå­æ“ä½œçš„æ€§èƒ½ä¼˜åŠ¿
- [ ] èƒ½ç”¨åŒæ­¥æœºåˆ¶å®ç°å¹¶å‘å®‰å…¨çš„ç¨‹åº

---

åŒæ­¥æœºåˆ¶æ˜¯Goè¯­è¨€å¹¶å‘ç¼–ç¨‹çš„é‡è¦å·¥å…·ï¼ŒæŒæ¡è¿™äº›åŸºç¡€å°†ä¸ºåç»­çš„å¹¶å‘è®¾è®¡æ¨¡å¼å­¦ä¹ æ‰“ä¸‹åšå®åŸºç¡€ã€‚
