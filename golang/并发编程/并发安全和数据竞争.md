# Goè¯­è¨€å¹¶å‘å®‰å…¨å’Œæ•°æ®ç«äº‰

## ğŸ“š å­¦ä¹ ç›®æ ‡
ç†è§£å¹¶å‘ç¼–ç¨‹ä¸­çš„å®‰å…¨é—®é¢˜ï¼Œå­¦ä¼šè¯†åˆ«å’Œé¿å…æ•°æ®ç«äº‰ï¼Œç¼–å†™çº¿ç¨‹å®‰å…¨çš„Goç¨‹åºã€‚

---

## 1. æ•°æ®ç«äº‰æ¦‚å¿µ

### 1.1 ä»€ä¹ˆæ˜¯æ•°æ®ç«äº‰
æ•°æ®ç«äº‰æ˜¯æŒ‡ä¸¤ä¸ªæˆ–å¤šä¸ªgoroutineåŒæ—¶è®¿é—®åŒä¸€å—å†…å­˜ï¼Œå¹¶ä¸”è‡³å°‘æœ‰ä¸€ä¸ªgoroutineæ‰§è¡Œå†™æ“ä½œæ—¶ï¼Œç”±äºç¼ºä¹åŒæ­¥æœºåˆ¶è€Œå¯¼è‡´çš„ä¸ç¡®å®šè¡Œä¸ºã€‚

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    counter := 0
    var wg sync.WaitGroup
    
    // å¯åŠ¨1000ä¸ªgoroutine
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter++ // è¿™é‡Œå­˜åœ¨æ•°æ®ç«äº‰
        }()
    }
    
    wg.Wait()
    fmt.Println("æœ€ç»ˆè®¡æ•°:", counter) // ç»“æœä¸ç¡®å®šï¼Œå°äº1000
}
```

### 1.2 ç«äº‰æ¡ä»¶çš„å½¢å¼
1. **è¯»-å†™ç«äº‰**ï¼šä¸€ä¸ªgoroutineè¯»å–å˜é‡ï¼Œå¦ä¸€ä¸ªåŒæ—¶å†™å…¥
2. **å†™-å†™ç«äº‰**ï¼šå¤šä¸ªgoroutineåŒæ—¶å†™å…¥åŒä¸€å˜é‡
3. **æœªåˆå§‹åŒ–çš„å†…å­˜è®¿é—®**ï¼šè®¿é—®å°šæœªåˆå§‹åŒ–çš„å†…å­˜

### 1.3 å†…å­˜å¯è§æ€§é—®é¢˜
å†…å­˜å¯è§æ€§æ˜¯æŒ‡ä¸€ä¸ªgoroutineå¯¹å…±äº«å˜é‡çš„ä¿®æ”¹ä½•æ—¶å¯¹å…¶ä»–goroutineå¯è§ã€‚

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    done := false
    
    // å¯åŠ¨ä¸€ä¸ªå·¥ä½œgoroutine
    go func() {
        time.Sleep(100 * time.Millisecond)
        done = true // å¯èƒ½å¯¹ä¸»goroutineä¸å¯è§
    }()
    
    // ä¸»goroutineæ£€æŸ¥doneæ ‡å¿—
    for !done {
        // å¿™ç­‰å¾…ï¼Œå¯èƒ½æ°¸è¿œä¸ä¼šé€€å‡º
        // å› ä¸ºä¸»goroutineå¯èƒ½æ°¸è¿œçœ‹ä¸åˆ°doneçš„æ›´æ–°
    }
    
    fmt.Println("å·¥ä½œå®Œæˆ")
}
```

### 1.4 Happens-beforeå…³ç³»
Happens-beforeæ˜¯ä¸€ç§ç¡®ä¿å†…å­˜æ“ä½œé¡ºåºçš„å…³ç³»ï¼ŒGoçš„å†…å­˜æ¨¡å‹å®šä¹‰äº†å‡ ç§å»ºç«‹happens-beforeå…³ç³»çš„æ–¹å¼ï¼š

1. **åˆå§‹åŒ–**ï¼šåŒ…çš„initå‡½æ•°åœ¨mainå‡½æ•°ä¹‹å‰æ‰§è¡Œ
2. **goroutineåˆ›å»º**ï¼šgoè¯­å¥happens-beforeå…¶åˆ›å»ºçš„goroutineçš„æ‰§è¡Œ
3. **goroutineé€€å‡º**ï¼šgoroutineçš„é€€å‡ºä¸ä¿è¯happens-beforeä»»ä½•äº‹ä»¶
4. **channelé€šä¿¡**ï¼šchannelå‘é€happens-beforeå¯¹åº”çš„æ¥æ”¶å®Œæˆ
5. **é”**ï¼šUnlock happens-beforeä¹‹åå¯¹åŒä¸€ä¸ªäº’æ–¥é”çš„Lock
6. **Once**ï¼šonce.Do(f)ä¸­çš„fçš„è¿”å›happens-beforeä»»ä½•å…¶ä»–once.Do(f)çš„è¿”å›

---

## 2. æ£€æµ‹æ•°æ®ç«äº‰

### 2.1 ä½¿ç”¨Go Race Detector
Goå†…ç½®äº†ä¸€ä¸ªæ•°æ®ç«äº‰æ£€æµ‹å™¨ï¼Œå¯ä»¥åœ¨ç¼–è¯‘ã€æµ‹è¯•æˆ–è¿è¡Œæ—¶å¯ç”¨ï¼š

```bash
# è¿è¡Œæ—¶å¯ç”¨race detector
go run -race main.go

# æµ‹è¯•æ—¶å¯ç”¨race detector
go test -race ./...

# ç¼–è¯‘æ—¶å¯ç”¨race detector
go build -race main.go
```

åœ¨æ•°æ®ç«äº‰å‘ç”Ÿæ—¶ï¼ŒRace Detectorä¼šè¾“å‡ºç±»ä¼¼ä»¥ä¸‹çš„æŠ¥å‘Šï¼š

```
==================
WARNING: DATA RACE
Read at 0x00c0000b4010 by goroutine 7:
  main.main.func1()
      /path/to/file.go:12 +0x44

Previous write at 0x00c0000b4010 by goroutine 6:
  main.main.func1()
      /path/to/file.go:12 +0x44

Goroutine 7 (running) created at:
  main.main()
      /path/to/file.go:11 +0xc4

Goroutine 6 (finished) created at:
  main.main()
      /path/to/file.go:11 +0xc4
==================
```

### 2.2 Race Detectorå·¥ä½œåŸç†
Race DetectoråŸºäºThreadSanitizerå®ç°ï¼Œé€šè¿‡ä»¥ä¸‹æ–¹å¼å·¥ä½œï¼š
1. è·Ÿè¸ªç¨‹åºæ‰§è¡Œä¸­çš„æ‰€æœ‰å†…å­˜è®¿é—®
2. ç›‘æ§æ‰€æœ‰åŒæ­¥äº‹ä»¶ï¼ˆå¦‚äº’æ–¥é”æ“ä½œã€channelé€šä¿¡ï¼‰
3. æ£€æµ‹è¿åhappens-beforeå…³ç³»çš„å†…å­˜è®¿é—®
4. äº§ç”Ÿè¿åæƒ…å†µçš„è¯¦ç»†æŠ¥å‘Š

### 2.3 é™æ€åˆ†æå·¥å…·
é™¤äº†Race Detectorï¼Œè¿˜æœ‰ä¸€äº›é™æ€åˆ†æå·¥å…·å¯ä»¥å¸®åŠ©æ£€æµ‹æ½œåœ¨çš„å¹¶å‘é—®é¢˜ï¼š

- **go vet**ï¼šGoå†…ç½®çš„é™æ€åˆ†æå·¥å…·
- **golangci-lint**ï¼šé›†æˆäº†å¤šç§linterçš„å·¥å…·
- **staticcheck**ï¼šé«˜çº§é™æ€åˆ†æå·¥å…·

```bash
# ä½¿ç”¨go vetæ£€æŸ¥
go vet ./...

# ä½¿ç”¨golangci-lint
golangci-lint run
```

### 2.4 Race Detectorçš„å±€é™æ€§
Race Detectorå¹¶éä¸‡èƒ½ï¼š
1. ä»…èƒ½æ£€æµ‹åˆ°æ‰§è¡Œè¿‡ç¨‹ä¸­å®é™…å‘ç”Ÿçš„æ•°æ®ç«äº‰
2. å¢åŠ ç¨‹åºçš„å†…å­˜ä½¿ç”¨ï¼ˆ5-10å€ï¼‰å’Œæ‰§è¡Œæ—¶é—´ï¼ˆ2-20å€ï¼‰
3. ä¸èƒ½æ£€æµ‹æ‰€æœ‰ç±»å‹çš„å¹¶å‘é—®é¢˜ï¼ˆå¦‚æ­»é”ï¼‰

---

## 3. é¿å…æ•°æ®ç«äº‰çš„ç­–ç•¥

### 3.1 ä½¿ç”¨äº’æ–¥é”
äº’æ–¥é”ï¼ˆMutexï¼‰æ˜¯é¿å…æ•°æ®ç«äº‰æœ€ç›´æ¥çš„æ–¹æ³•ï¼š

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    counter := 0
    var mu sync.Mutex
    var wg sync.WaitGroup
    
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            
            mu.Lock()
            counter++ // å®‰å…¨è®¿é—®
            mu.Unlock()
        }()
    }
    
    wg.Wait()
    fmt.Println("æœ€ç»ˆè®¡æ•°:", counter) // æ€»æ˜¯1000
}
```

### 3.2 ä½¿ç”¨è¯»å†™é”
å½“è¯»æ“ä½œè¿œå¤šäºå†™æ“ä½œæ—¶ï¼Œè¯»å†™é”æ›´é«˜æ•ˆï¼š

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    var data map[string]string = make(map[string]string)
    var rwmu sync.RWMutex
    var wg sync.WaitGroup
    
    // å†™æ“ä½œ
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            
            rwmu.Lock() // ç‹¬å é”
            data[fmt.Sprintf("key-%d", i)] = fmt.Sprintf("value-%d", i)
            rwmu.Unlock()
        }(i)
    }
    
    // è¯»æ“ä½œ
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            
            rwmu.RLock() // å…±äº«é”
            for k, v := range data {
                _ = k
                _ = v
            }
            rwmu.RUnlock()
        }()
    }
    
    wg.Wait()
    
    rwmu.RLock()
    fmt.Println("æ•°æ®é¡¹æ•°:", len(data))
    rwmu.RUnlock()
}
```

### 3.3 ä½¿ç”¨åŸå­æ“ä½œ
å¯¹äºç®€å•çš„è®¡æ•°å™¨ç­‰æ“ä½œï¼Œå¯ä»¥ä½¿ç”¨åŸå­æ“ä½œï¼š

```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

func main() {
    var counter int64
    var wg sync.WaitGroup
    
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            
            atomic.AddInt64(&counter, 1) // åŸå­é€’å¢
        }()
    }
    
    wg.Wait()
    
    fmt.Println("æœ€ç»ˆè®¡æ•°:", atomic.LoadInt64(&counter)) // æ€»æ˜¯1000
}
```

### 3.4 ä½¿ç”¨Channelé€šä¿¡
éµå¾ª"é€šè¿‡é€šä¿¡å…±äº«å†…å­˜ï¼Œè€Œä¸æ˜¯é€šè¿‡å…±äº«å†…å­˜é€šä¿¡"çš„åŸåˆ™ï¼š

```go
package main

import (
    "fmt"
)

func worker(id int, jobs <-chan int, results chan<- int) {
    for job := range jobs {
        // å¤„ç†ä»»åŠ¡
        result := job * 2
        results <- result
    }
}

func main() {
    jobs := make(chan int, 100)
    results := make(chan int, 100)
    
    // å¯åŠ¨3ä¸ªworker
    for w := 1; w <= 3; w++ {
        go worker(w, jobs, results)
    }
    
    // å‘é€ä»»åŠ¡
    for j := 1; j <= 9; j++ {
        jobs <- j
    }
    close(jobs)
    
    // æ”¶é›†ç»“æœ
    for a := 1; a <= 9; a++ {
        <-results
    }
}
```

### 3.5 ä¸å¯å˜æ•°æ®
ä½¿ç”¨ä¸å¯å˜æ•°æ®å¯ä»¥é¿å…æ•°æ®ç«äº‰ï¼š

```go
package main

import (
    "fmt"
    "sync"
)

// ä¸å¯å˜ç»“æ„
type ImmutableData struct {
    values []int
}

// åˆ›å»ºæ–°çš„ä¸å¯å˜å®ä¾‹
func NewImmutableData(values []int) *ImmutableData {
    copied := make([]int, len(values))
    copy(copied, values)
    return &ImmutableData{values: copied}
}

// è¿”å›æ•°å€¼æ‹·è´
func (d *ImmutableData) Get(index int) int {
    if index < 0 || index >= len(d.values) {
        return 0
    }
    return d.values[index]
}

// è¿”å›æ–°çš„ä¿®æ”¹åçš„å®ä¾‹
func (d *ImmutableData) Set(index int, value int) *ImmutableData {
    if index < 0 || index >= len(d.values) {
        return d
    }
    
    copied := make([]int, len(d.values))
    copy(copied, d.values)
    copied[index] = value
    
    return &ImmutableData{values: copied}
}

func main() {
    data := NewImmutableData([]int{1, 2, 3, 4, 5})
    
    var wg sync.WaitGroup
    
    // è¯»å–ä¸éœ€è¦åŒæ­¥
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            value := data.Get(i % 5)
            fmt.Printf("è¯»å–ç´¢å¼• %d: %d\n", i%5, value)
        }(i)
    }
    
    // ä¿®æ”¹è¿”å›æ–°å®ä¾‹ï¼Œä¸æ”¹å˜åŸå§‹æ•°æ®
    newData := data.Set(0, 100)
    fmt.Println("åŸå§‹data[0]:", data.Get(0))
    fmt.Println("æ–°data[0]:", newData.Get(0))
    
    wg.Wait()
}
```

---

## 4. å¸¸è§å¹¶å‘é—®é¢˜

### 4.1 æ­»é”
æ­»é”æ˜¯æŒ‡ä¸¤ä¸ªæˆ–å¤šä¸ªgoroutineäº’ç›¸ç­‰å¾…å¯¹æ–¹æŒæœ‰çš„é”ï¼Œå¯¼è‡´ç¨‹åºæ°¸è¿œæ— æ³•ç»§ç»­æ‰§è¡Œã€‚

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func main() {
    var mu1, mu2 sync.Mutex
    
    // goroutine 1
    go func() {
        mu1.Lock()
        fmt.Println("goroutine 1: è·å–äº†mu1")
        time.Sleep(time.Second) // æ•…æ„å»¶è¿Ÿï¼Œå¢åŠ æ­»é”å¯èƒ½æ€§
        
        fmt.Println("goroutine 1: å°è¯•è·å–mu2")
        mu2.Lock() // å¯èƒ½æ­»é”
        defer mu2.Unlock()
        
        defer mu1.Unlock()
        fmt.Println("goroutine 1: å®Œæˆ")
    }()
    
    // goroutine 2
    go func() {
        mu2.Lock()
        fmt.Println("goroutine 2: è·å–äº†mu2")
        time.Sleep(time.Second) // æ•…æ„å»¶è¿Ÿï¼Œå¢åŠ æ­»é”å¯èƒ½æ€§
        
        fmt.Println("goroutine 2: å°è¯•è·å–mu1")
        mu1.Lock() // å¯èƒ½æ­»é”
        defer mu1.Unlock()
        
        defer mu2.Unlock()
        fmt.Println("goroutine 2: å®Œæˆ")
    }()
    
    time.Sleep(3 * time.Second)
    fmt.Println("ç¨‹åºé€€å‡º")
}
```

é¿å…æ­»é”çš„ç­–ç•¥ï¼š
1. æŒ‰å›ºå®šé¡ºåºè·å–é”
2. ä½¿ç”¨å¸¦è¶…æ—¶çš„é”è·å–
3. ä½¿ç”¨tryLockæ¨¡å¼
4. ä½¿ç”¨é€šé“æ›¿ä»£é”

### 4.2 æ´»é”
æ´»é”æ˜¯æŒ‡ç¨‹åºçœ‹èµ·æ¥åœ¨æ‰§è¡Œï¼Œä½†å®é™…ä¸Šæ²¡æœ‰è¿›å±•ã€‚

```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
    "time"
)

func main() {
    var wg sync.WaitGroup
    var resource int32 = 0
    var leftCount, rightCount int32
    
    // å·¦ä¾§goroutine
    wg.Add(1)
    go func() {
        defer wg.Done()
        for i := 0; i < 10; i++ {
            for {
                // æ£€æŸ¥èµ„æºæ˜¯å¦å¯ç”¨
                if atomic.CompareAndSwapInt32(&resource, 0, 1) {
                    // ä½¿ç”¨èµ„æº
                    atomic.AddInt32(&leftCount, 1)
                    time.Sleep(time.Millisecond)
                    
                    // é‡Šæ”¾èµ„æº
                    atomic.StoreInt32(&resource, 0)
                    time.Sleep(time.Millisecond) // ç¤¼è²Œæ€§åœ°è®©å‡ºèµ„æº
                    break
                }
                
                // å¦‚æœèµ„æºä¸å¯ç”¨ï¼Œç¤¼è²Œæ€§åœ°ç­‰å¾…
                fmt.Println("å·¦ä¾§ç­‰å¾…...")
                time.Sleep(time.Millisecond)
            }
        }
    }()
    
    // å³ä¾§goroutine
    wg.Add(1)
    go func() {
        defer wg.Done()
        for i := 0; i < 10; i++ {
            for {
                // æ£€æŸ¥èµ„æºæ˜¯å¦å¯ç”¨
                if atomic.CompareAndSwapInt32(&resource, 0, 2) {
                    // ä½¿ç”¨èµ„æº
                    atomic.AddInt32(&rightCount, 1)
                    time.Sleep(time.Millisecond)
                    
                    // é‡Šæ”¾èµ„æº
                    atomic.StoreInt32(&resource, 0)
                    time.Sleep(time.Millisecond) // ç¤¼è²Œæ€§åœ°è®©å‡ºèµ„æº
                    break
                }
                
                // å¦‚æœèµ„æºä¸å¯ç”¨ï¼Œç¤¼è²Œæ€§åœ°ç­‰å¾…
                fmt.Println("å³ä¾§ç­‰å¾…...")
                time.Sleep(time.Millisecond)
            }
        }
    }()
    
    wg.Wait()
    fmt.Printf("å·¦ä¾§: %d, å³ä¾§: %d\n", leftCount, rightCount)
}
```

é¿å…æ´»é”çš„ç­–ç•¥ï¼š
1. å¼•å…¥éšæœºå»¶è¿Ÿ
2. é€€é¿ç®—æ³•
3. ä¼˜å…ˆçº§æœºåˆ¶

### 4.3 é¥¥é¥¿
é¥¥é¥¿æ˜¯æŒ‡æŸäº›goroutineæ— æ³•è·å¾—æ‰€éœ€èµ„æºï¼Œå¯¼è‡´æ— æ³•å–å¾—è¿›å±•ã€‚

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func main() {
    var mu sync.Mutex
    var wg sync.WaitGroup
    const workers = 10
    counts := make([]int, workers)
    
    for i := 0; i < workers; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            for j := 0; j < 100; j++ {
                // ä½ä¼˜å…ˆçº§å·¥ä½œè€…ï¼Œå¤§éƒ¨åˆ†æ—¶é—´åœ¨ç­‰å¾…
                if id > 0 {
                    time.Sleep(time.Millisecond)
                }
                
                mu.Lock()
                counts[id]++
                
                // é«˜ä¼˜å…ˆçº§å·¥ä½œè€…0å ç”¨é”è¾ƒé•¿æ—¶é—´
                if id == 0 {
                    time.Sleep(time.Millisecond)
                }
                
                mu.Unlock()
            }
        }(i)
    }
    
    wg.Wait()
    
    // æ£€æŸ¥å·¥ä½œå®Œæˆæƒ…å†µ
    fmt.Println("å·¥ä½œè€…å®Œæˆè®¡æ•°:")
    for i, count := range counts {
        fmt.Printf("å·¥ä½œè€… %d: %d\n", i, count)
    }
}
```

é¿å…é¥¥é¥¿çš„ç­–ç•¥ï¼š
1. å…¬å¹³é”
2. é™åˆ¶ä¸´ç•ŒåŒºæ—¶é—´
3. èµ„æºé¢„ç•™
4. ä¼˜å…ˆçº§è°ƒæ•´

### 4.4 ABAé—®é¢˜
ABAé—®é¢˜æ˜¯æŒ‡ä¸€ä¸ªå€¼ä»Aå˜æˆBï¼Œåˆå˜å›Aï¼Œå¯èƒ½å¯¼è‡´CASæ“ä½œæ— æ³•æ£€æµ‹åˆ°å˜åŒ–ã€‚

```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
    "time"
)

type Node struct {
    value int
    next  *Node
}

func main() {
    // åˆå§‹é“¾è¡¨: A -> B -> C
    head := &Node{value: 1, next: &Node{value: 2, next: &Node{value: 3}}}
    
    var wg sync.WaitGroup
    
    // goroutine 1: å°è¯•åˆ é™¤èŠ‚ç‚¹A
    wg.Add(1)
    go func() {
        defer wg.Done()
        
        // ä¿å­˜åˆå§‹å¤´ç»“ç‚¹æŒ‡é’ˆ
        oldHead := head
        
        // æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ
        time.Sleep(100 * time.Millisecond)
        
        // ä½¿ç”¨CASå°è¯•æ›´æ–°å¤´ç»“ç‚¹ä¸ºä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        // å‡è®¾æ²¡æœ‰ABAé—®é¢˜ï¼Œæ­¤æ“ä½œåº”è¯¥æˆåŠŸ
        if atomic.CompareAndSwapPointer(
            (*unsafe.Pointer)(unsafe.Pointer(&head)),
            unsafe.Pointer(oldHead),
            unsafe.Pointer(oldHead.next),
        ) {
            fmt.Println("goroutine 1: æˆåŠŸåˆ é™¤èŠ‚ç‚¹A")
        } else {
            fmt.Println("goroutine 1: æ“ä½œå¤±è´¥ï¼Œå¤´ç»“ç‚¹å·²å˜åŒ–")
        }
    }()
    
    // goroutine 2: åˆ é™¤Aï¼Œç„¶åæ·»åŠ æ–°çš„A
    wg.Add(1)
    go func() {
        defer wg.Done()
        
        // åˆ é™¤èŠ‚ç‚¹A
        oldHead := head
        head = oldHead.next
        fmt.Println("goroutine 2: åˆ é™¤äº†èŠ‚ç‚¹A")
        
        // åˆ é™¤èŠ‚ç‚¹B
        nodeB := head
        head = nodeB.next
        fmt.Println("goroutine 2: åˆ é™¤äº†èŠ‚ç‚¹B")
        
        // æ·»åŠ æ–°èŠ‚ç‚¹A'
        newNode := &Node{value: 1}
        newNode.next = head
        head = newNode
        fmt.Println("goroutine 2: æ·»åŠ äº†æ–°èŠ‚ç‚¹A'")
    }()
    
    wg.Wait()
    
    // æ‰“å°æœ€ç»ˆé“¾è¡¨
    fmt.Println("æœ€ç»ˆé“¾è¡¨:")
    current := head
    for current != nil {
        fmt.Printf("%d -> ", current.value)
        current = current.next
    }
    fmt.Println("nil")
}
```

é¿å…ABAé—®é¢˜çš„ç­–ç•¥ï¼š
1. ä½¿ç”¨ç‰ˆæœ¬å·æˆ–æ—¶é—´æˆ³
2. å†…å­˜å±éšœ
3. åŒé‡æ£€æŸ¥

---

## 5. å¹¶å‘å®‰å…¨è®¾è®¡

### 5.1 çº¿ç¨‹å®‰å…¨çš„æ•°æ®ç»“æ„
è®¾è®¡å¹¶å‘å®‰å…¨çš„æ•°æ®ç»“æ„éœ€è¦è€ƒè™‘ï¼š
1. è®¿é—®æ§åˆ¶ï¼šé€šè¿‡é”æˆ–é€šé“æ§åˆ¶è®¿é—®
2. å†…éƒ¨åŒæ­¥ï¼šæ‰€æœ‰æ“ä½œå†…éƒ¨ä¿è¯åŒæ­¥
3. ä¸å˜é‡ç»´æŠ¤ï¼šä¿æŒæ•°æ®ç»“æ„çš„ä¸€è‡´æ€§

```go
package main

import (
    "fmt"
    "sync"
)

// çº¿ç¨‹å®‰å…¨çš„é˜Ÿåˆ—
type ConcurrentQueue struct {
    data []interface{}
    mu   sync.Mutex
}

// åˆ›å»ºæ–°é˜Ÿåˆ—
func NewConcurrentQueue() *ConcurrentQueue {
    return &ConcurrentQueue{
        data: make([]interface{}, 0),
    }
}

// å…¥é˜Ÿ
func (q *ConcurrentQueue) Enqueue(item interface{}) {
    q.mu.Lock()
    defer q.mu.Unlock()
    
    q.data = append(q.data, item)
}

// å‡ºé˜Ÿ
func (q *ConcurrentQueue) Dequeue() (interface{}, bool) {
    q.mu.Lock()
    defer q.mu.Unlock()
    
    if len(q.data) == 0 {
        return nil, false
    }
    
    item := q.data[0]
    q.data = q.data[1:]
    return item, true
}

// æŸ¥çœ‹é˜Ÿé¦–å…ƒç´ 
func (q *ConcurrentQueue) Peek() (interface{}, bool) {
    q.mu.Lock()
    defer q.mu.Unlock()
    
    if len(q.data) == 0 {
        return nil, false
    }
    
    return q.data[0], true
}

// è·å–é˜Ÿåˆ—é•¿åº¦
func (q *ConcurrentQueue) Size() int {
    q.mu.Lock()
    defer q.mu.Unlock()
    
    return len(q.data)
}

func main() {
    queue := NewConcurrentQueue()
    var wg sync.WaitGroup
    
    // å¹¶å‘å…¥é˜Ÿ
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(val int) {
            defer wg.Done()
            queue.Enqueue(val)
            fmt.Printf("å…¥é˜Ÿ: %d\n", val)
        }(i)
    }
    
    // å¹¶å‘å‡ºé˜Ÿ
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            if val, ok := queue.Dequeue(); ok {
                fmt.Printf("å‡ºé˜Ÿ: %v\n", val)
            }
        }()
    }
    
    wg.Wait()
    fmt.Printf("æœ€ç»ˆé˜Ÿåˆ—å¤§å°: %d\n", queue.Size())
}
```

### 5.2 çº¿ç¨‹å°é—­
çº¿ç¨‹å°é—­æ˜¯æŒ‡ç¡®ä¿æ•°æ®åªè¢«ä¸€ä¸ªgoroutineè®¿é—®ï¼Œä»è€Œé¿å…åŒæ­¥ï¼š

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    // æ¯ä¸ªgoroutineæ‹¥æœ‰è‡ªå·±çš„è®¡æ•°å™¨
    var wg sync.WaitGroup
    
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            // å±€éƒ¨å˜é‡ï¼Œåªåœ¨æ­¤goroutineä¸­è®¿é—®
            localCounter := 0
            
            for j := 0; j < 1000; j++ {
                localCounter++ // å®‰å…¨ï¼Œä¸éœ€è¦åŒæ­¥
            }
            
            fmt.Printf("goroutine %d: è®¡æ•° = %d\n", id, localCounter)
        }(i)
    }
    
    wg.Wait()
}
```

### 5.3 å¹¶å‘å®‰å…¨åŸåˆ™
ç¼–å†™å¹¶å‘å®‰å…¨ä»£ç çš„å…³é”®åŸåˆ™ï¼š

1. **æœ€å°åŒ–å…±äº«**ï¼šå°½é‡å‡å°‘goroutineä¹‹é—´å…±äº«çš„æ•°æ®ã€‚
2. **ä¸å¯å˜æ•°æ®**ï¼šä¼˜å…ˆä½¿ç”¨ä¸å¯å˜æ•°æ®ç»“æ„ã€‚
3. **æ˜ç¡®æ‰€æœ‰æƒ**ï¼šæ¸…æ™°å®šä¹‰æ•°æ®çš„æ‰€æœ‰æƒå’Œè®¿é—®è§„åˆ™ã€‚
4. **æ‹·è´è€Œéå…±äº«**ï¼šå½“æ•°æ®é‡ä¸å¤§æ—¶ï¼Œè€ƒè™‘ä½¿ç”¨æ‹·è´ã€‚
5. **æ–‡æ¡£åŒ–**ï¼šæ˜ç¡®è®°å½•å¹¶å‘è®¿é—®çš„å‡è®¾å’Œè§„åˆ™ã€‚

```go
package main

import (
    "fmt"
    "sync"
)

// SafeCounteræ˜¯ä¸€ä¸ªçº¿ç¨‹å®‰å…¨çš„è®¡æ•°å™¨
type SafeCounter struct {
    mu    sync.Mutex
    value int
}

// Incæ–¹æ³•å®‰å…¨åœ°å¢åŠ è®¡æ•°å™¨å€¼
func (c *SafeCounter) Inc() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}

// Valueæ–¹æ³•è¿”å›è®¡æ•°å™¨å½“å‰å€¼
func (c *SafeCounter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.value
}

func main() {
    counter := SafeCounter{}
    var wg sync.WaitGroup
    
    // å¹¶å‘é€’å¢
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter.Inc() // çº¿ç¨‹å®‰å…¨
        }()
    }
    
    wg.Wait()
    fmt.Println("è®¡æ•°å™¨æœ€ç»ˆå€¼:", counter.Value())
}
```

### 5.4 å¹¶å‘å®¹å™¨
Goæä¾›äº†ä¸€äº›å†…ç½®çš„å¹¶å‘å®‰å…¨å®¹å™¨ï¼š

1. **sync.Map**ï¼šé€‚ç”¨äºè¯»å¤šå†™å°‘çš„åœºæ™¯ï¼Œå†…éƒ¨ä¼˜åŒ–äº†è¯»é”å¼€é”€ã€‚
2. **channels**ï¼šå¯ä»¥ç”¨ä½œé˜Ÿåˆ—ã€ä¿¡å·é‡ç­‰å¹¶å‘åŸè¯­ã€‚

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    // ä½¿ç”¨sync.Map
    var m sync.Map
    var wg sync.WaitGroup
    
    // å¹¶å‘å†™å…¥
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            key := fmt.Sprintf("key-%d", i)
            m.Store(key, i)
        }(i)
    }
    
    // å¹¶å‘è¯»å–
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            key := fmt.Sprintf("key-%d", i)
            if val, ok := m.Load(key); ok {
                _ = val
                // fmt.Printf("è¯»å– %s: %v\n", key, val)
            }
        }(i)
    }
    
    wg.Wait()
    
    // ç»Ÿè®¡å­˜å‚¨çš„é”®å€¼å¯¹æ•°é‡
    count := 0
    m.Range(func(key, value interface{}) bool {
        count++
        return true
    })
    
    fmt.Println("å­˜å‚¨çš„é”®å€¼å¯¹æ•°é‡:", count)
}
```

---

## 6. å¹¶å‘æ€§èƒ½ä¼˜åŒ–

### 6.1 å‡å°‘é”ç²’åº¦
é”ç²’åº¦è¶Šç»†ï¼Œå¹¶å‘æ€§èƒ½è¶Šå¥½ï¼š

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// ç²—ç²’åº¦é”å®š
type CoarseMap struct {
    mu   sync.Mutex
    data map[string]string
}

func (m *CoarseMap) Get(key string) (string, bool) {
    m.mu.Lock()
    defer m.mu.Unlock()
    val, ok := m.data[key]
    return val, ok
}

func (m *CoarseMap) Set(key, val string) {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.data[key] = val
}

// ç»†ç²’åº¦é”å®š
type FineMap struct {
    shards    []*mapShard
    shardMask int
}

type mapShard struct {
    mu   sync.Mutex
    data map[string]string
}

func NewFineMap(shardCount int) *FineMap {
    shards := make([]*mapShard, shardCount)
    for i := 0; i < shardCount; i++ {
        shards[i] = &mapShard{
            data: make(map[string]string),
        }
    }
    return &FineMap{
        shards:    shards,
        shardMask: shardCount - 1,
    }
}

func (m *FineMap) getShard(key string) *mapShard {
    // ç®€å•å“ˆå¸Œç®—æ³•ï¼Œæ ¹æ®keyçš„ç¬¬ä¸€ä¸ªå­—ç¬¦é€‰æ‹©åˆ†ç‰‡
    hash := int(key[0])
    return m.shards[hash&m.shardMask]
}

func (m *FineMap) Get(key string) (string, bool) {
    shard := m.getShard(key)
    shard.mu.Lock()
    defer shard.mu.Unlock()
    val, ok := shard.data[key]
    return val, ok
}

func (m *FineMap) Set(key, val string) {
    shard := m.getShard(key)
    shard.mu.Lock()
    defer shard.mu.Unlock()
    shard.data[key] = val
}

func main() {
    // æµ‹è¯•å‚æ•°
    const numGoroutines = 100
    const numOperations = 1000
    
    // åˆå§‹åŒ–ä¸¤ç§Map
    coarseMap := &CoarseMap{data: make(map[string]string)}
    fineMap := NewFineMap(16) // 16ä¸ªåˆ†ç‰‡
    
    // æµ‹è¯•ç²—ç²’åº¦é”Map
    startCoarse := time.Now()
    var wg sync.WaitGroup
    
    for i := 0; i < numGoroutines; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            for j := 0; j < numOperations; j++ {
                key := fmt.Sprintf("key-%d-%d", id, j)
                value := fmt.Sprintf("value-%d-%d", id, j)
                
                coarseMap.Set(key, value)
                _, _ = coarseMap.Get(key)
            }
        }(i)
    }
    
    wg.Wait()
    coarseTime := time.Since(startCoarse)
    fmt.Printf("ç²—ç²’åº¦é”Mapè€—æ—¶: %v\n", coarseTime)
    
    // æµ‹è¯•ç»†ç²’åº¦é”Map
    startFine := time.Now()
    
    for i := 0; i < numGoroutines; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            for j := 0; j < numOperations; j++ {
                key := fmt.Sprintf("key-%d-%d", id, j)
                value := fmt.Sprintf("value-%d-%d", id, j)
                
                fineMap.Set(key, value)
                _, _ = fineMap.Get(key)
            }
        }(i)
    }
    
    wg.Wait()
    fineTime := time.Since(startFine)
    fmt.Printf("ç»†ç²’åº¦é”Mapè€—æ—¶: %v\n", fineTime)
    fmt.Printf("æ€§èƒ½æå‡: %.2få€\n", float64(coarseTime)/float64(fineTime))
}
```

### 6.2 æ— é”ç¼–ç¨‹
æŸäº›åœºæ™¯ä¸‹ï¼Œå¯ä»¥ä½¿ç”¨æ— é”æŠ€æœ¯æé«˜æ€§èƒ½ï¼š

```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

// ä½¿ç”¨åŸå­æ“ä½œå®ç°ç®€å•è®¡æ•°å™¨
type AtomicCounter struct {
    value int64
}

func (c *AtomicCounter) Inc() {
    atomic.AddInt64(&c.value, 1)
}

func (c *AtomicCounter) Value() int64 {
    return atomic.LoadInt64(&c.value)
}

// ä½¿ç”¨é”å®ç°è®¡æ•°å™¨
type MutexCounter struct {
    mu    sync.Mutex
    value int64
}

func (c *MutexCounter) Inc() {
    c.mu.Lock()
    c.value++
    c.mu.Unlock()
}

func (c *MutexCounter) Value() int64 {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.value
}

func main() {
    const numGoroutines = 1000
    const numIncrements = 1000
    
    // æµ‹è¯•åŸå­è®¡æ•°å™¨
    atomicCounter := AtomicCounter{}
    var wg sync.WaitGroup
    
    start := time.Now()
    
    for i := 0; i < numGoroutines; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            
            for j := 0; j < numIncrements; j++ {
                atomicCounter.Inc()
            }
        }()
    }
    
    wg.Wait()
    atomicTime := time.Since(start)
    
    fmt.Printf("åŸå­è®¡æ•°å™¨æœ€ç»ˆå€¼: %d, è€—æ—¶: %v\n",
        atomicCounter.Value(), atomicTime)
    
    // æµ‹è¯•é”è®¡æ•°å™¨
    mutexCounter := MutexCounter{}
    
    start = time.Now()
    
    for i := 0; i < numGoroutines; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            
            for j := 0; j < numIncrements; j++ {
                mutexCounter.Inc()
            }
        }()
    }
    
    wg.Wait()
    mutexTime := time.Since(start)
    
    fmt.Printf("é”è®¡æ•°å™¨æœ€ç»ˆå€¼: %d, è€—æ—¶: %v\n",
        mutexCounter.Value(), mutexTime)
    
    fmt.Printf("æ€§èƒ½æå‡: %.2få€\n", float64(mutexTime)/float64(atomicTime))
}
```

### 6.3 å‡å°‘å…±äº«çŠ¶æ€
é€šè¿‡é¿å…å…±äº«çŠ¶æ€æ¥æé«˜å¹¶å‘æ€§èƒ½ï¼š

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// åŸºäºå…±äº«çŠ¶æ€çš„è®¾è®¡
func sharedStateDesign() time.Duration {
    start := time.Now()
    
    const numWorkers = 100
    const numTasks = 1000
    
    results := make([]int, numTasks)
    var mu sync.Mutex
    var wg sync.WaitGroup
    
    // åˆ†é…ä»»åŠ¡
    tasks := make(chan int, numTasks)
    for i := 0; i < numTasks; i++ {
        tasks <- i
    }
    close(tasks)
    
    // å¯åŠ¨å·¥ä½œè€…
    for i := 0; i < numWorkers; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            
            for task := range tasks {
                // å¤„ç†ä»»åŠ¡
                result := task * 2
                
                // æ›´æ–°å…±äº«çŠ¶æ€
                mu.Lock()
                results[task] = result
                mu.Unlock()
            }
        }()
    }
    
    wg.Wait()
    return time.Since(start)
}

// åŸºäºæ¶ˆæ¯ä¼ é€’çš„è®¾è®¡
func messagePassingDesign() time.Duration {
    start := time.Now()
    
    const numWorkers = 100
    const numTasks = 1000
    
    // åˆ†é…ä»»åŠ¡
    tasks := make(chan int, numTasks)
    for i := 0; i < numTasks; i++ {
        tasks <- i
    }
    close(tasks)
    
    // æ”¶é›†ç»“æœ
    type result struct {
        taskID int
        value  int
    }
    
    results := make(chan result, numTasks)
    
    // å¯åŠ¨å·¥ä½œè€…
    var wg sync.WaitGroup
    for i := 0; i < numWorkers; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            
            for task := range tasks {
                // å¤„ç†ä»»åŠ¡
                value := task * 2
                
                // å‘é€ç»“æœ
                results <- result{taskID: task, value: value}
            }
        }()
    }
    
    // å…³é—­ç»“æœé€šé“
    go func() {
        wg.Wait()
        close(results)
    }()
    
    // æ”¶é›†ç»“æœ
    finalResults := make([]int, numTasks)
    for r := range results {
        finalResults[r.taskID] = r.value
    }
    
    return time.Since(start)
}

func main() {
    // çƒ­èº«
    sharedStateDesign()
    messagePassingDesign()
    
    // å®é™…æµ‹é‡
    sharedTime := sharedStateDesign()
    fmt.Printf("å…±äº«çŠ¶æ€è®¾è®¡è€—æ—¶: %v\n", sharedTime)
    
    messageTime := messagePassingDesign()
    fmt.Printf("æ¶ˆæ¯ä¼ é€’è®¾è®¡è€—æ—¶: %v\n", messageTime)
    
    speedup := float64(sharedTime) / float64(messageTime)
    fmt.Printf("æ€§èƒ½æå‡: %.2få€\n", speedup)
}
```

---

## 7. å­¦ä¹ æ£€æŸ¥ç‚¹

- [ ] ç†è§£æ•°æ®ç«äº‰çš„æ¦‚å¿µå’Œæ£€æµ‹æ–¹æ³•
- [ ] æŒæ¡Go Race Detectorçš„ä½¿ç”¨
- [ ] èƒ½ä½¿ç”¨ä¸åŒçš„åŒæ­¥æœºåˆ¶é¿å…æ•°æ®ç«äº‰
- [ ] ç†è§£å¹¶å‘é—®é¢˜ï¼šæ­»é”ã€æ´»é”ã€é¥¥é¥¿å’ŒABAé—®é¢˜
- [ ] èƒ½è®¾è®¡å¹¶å‘å®‰å…¨çš„æ•°æ®ç»“æ„
- [ ] æŒæ¡å¹¶å‘æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯

---

æ•°æ®ç«äº‰æ˜¯å¹¶å‘ç¼–ç¨‹ä¸­æœ€å¸¸è§ä¹Ÿæœ€éš¾è°ƒè¯•çš„é—®é¢˜ä¹‹ä¸€ã€‚é€šè¿‡ç†è§£Goçš„å†…å­˜æ¨¡å‹ï¼Œä½¿ç”¨é€‚å½“çš„åŒæ­¥æœºåˆ¶ï¼Œè®¾è®¡è‰¯å¥½çš„å¹¶å‘æ¨¡å¼ï¼Œå¯ä»¥ç¼–å†™æ—¢æ­£ç¡®åˆé«˜æ•ˆçš„å¹¶å‘ç¨‹åºã€‚è®°ä½ï¼Œå¯¹äºå¹¶å‘ç¨‹åºï¼Œæ­£ç¡®æ€§æ˜¯é¦–è¦ç›®æ ‡ï¼Œæ€§èƒ½æ˜¯æ¬¡è¦è€ƒè™‘ã€‚
