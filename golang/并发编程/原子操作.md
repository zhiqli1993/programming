# Goè¯­è¨€åŸå­æ“ä½œ

## ğŸ“š å­¦ä¹ ç›®æ ‡
æŒæ¡sync/atomicåŒ…æä¾›çš„åŸå­æ“ä½œï¼Œå­¦ä¼šå®ç°æ— é”æ•°æ®ç»“æ„å’Œé«˜æ€§èƒ½å¹¶å‘ç¨‹åºã€‚

---

## 1. åŸå­æ“ä½œåŸºç¡€

### 1.1 ä»€ä¹ˆæ˜¯åŸå­æ“ä½œ
åŸå­æ“ä½œæ˜¯æŒ‡ä¸ä¼šè¢«çº¿ç¨‹è°ƒåº¦æœºåˆ¶ä¸­æ–­çš„æ“ä½œï¼Œè¿™ç§æ“ä½œä¸€æ—¦å¼€å§‹ï¼Œå°±ä¼šä¸€ç›´è¿è¡Œåˆ°ç»“æŸï¼Œä¸­é—´ä¸ä¼šæœ‰ä»»ä½•ä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚

### 1.2 ä¸ºä»€ä¹ˆéœ€è¦åŸå­æ“ä½œ
åœ¨å¹¶å‘ç¼–ç¨‹ä¸­ï¼Œå¤šä¸ªgoroutineå¯èƒ½åŒæ—¶è®¿é—®å’Œä¿®æ”¹å…±äº«æ•°æ®ï¼Œå¯¼è‡´æ•°æ®ç«äº‰ã€‚åŸå­æ“ä½œå¯ä»¥ç¡®ä¿è¿™äº›æ“ä½œä»¥ä¸å¯åˆ†å‰²çš„æ–¹å¼æ‰§è¡Œï¼Œä»è€Œé¿å…æ•°æ®ç«äº‰ã€‚

ç›¸æ¯”äº’æ–¥é”ï¼ŒåŸå­æ“ä½œé€šå¸¸å…·æœ‰æ›´ä½çš„å¼€é”€ï¼Œç‰¹åˆ«æ˜¯å¯¹äºç®€å•çš„æ“ä½œï¼Œå¦‚è®¡æ•°å™¨å¢å‡ã€æ ‡å¿—ä½è®¾ç½®ç­‰ã€‚

### 1.3 Goçš„åŸå­æ“ä½œåŒ…
Goè¯­è¨€é€šè¿‡`sync/atomic`åŒ…æä¾›åŸå­æ“ä½œæ”¯æŒï¼š

```go
package main

import (
    "fmt"
    "sync/atomic"
)

func main() {
    var counter int64 = 0
    
    // åŸå­åŠ æ³•
    atomic.AddInt64(&counter, 1)
    
    // åŸå­åŠ è½½
    value := atomic.LoadInt64(&counter)
    fmt.Println("è®¡æ•°å™¨å€¼:", value) // è¾“å‡º: è®¡æ•°å™¨å€¼: 1
}
```

### 1.4 å†…å­˜æ¨¡å‹ä¿è¯
åŸå­æ“ä½œæ»¡è¶³Goå†…å­˜æ¨¡å‹å®šä¹‰çš„happens-beforeå…³ç³»ï¼Œç¡®ä¿æ“ä½œå¯¹æ‰€æœ‰goroutineå¯è§ã€‚

ä¾‹å¦‚ï¼Œå¦‚æœgoroutine Aæ‰§è¡Œä¸€ä¸ªåŸå­å­˜å‚¨æ“ä½œï¼Œè€Œgoroutine Bæ‰§è¡Œç›¸åº”çš„åŸå­åŠ è½½æ“ä½œï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªæ“ä½œä¹‹é—´å­˜åœ¨happens-beforeå…³ç³»ï¼Œç¡®ä¿Bèƒ½çœ‹åˆ°Açš„ä¿®æ”¹ã€‚

---

## 2. åŸºæœ¬åŸå­æ“ä½œ

### 2.1 Loadæ“ä½œ
Loadæ“ä½œåŸå­åœ°åŠ è½½å¹¶è¿”å›æŒ‡å®šåœ°å€çš„å€¼ã€‚

```go
package main

import (
    "fmt"
    "sync/atomic"
    "time"
)

func main() {
    var flag int32 = 0
    
    // å¯åŠ¨ä¸€ä¸ªgoroutineåœ¨ä¸€ç§’åè®¾ç½®æ ‡å¿—
    go func() {
        time.Sleep(time.Second)
        fmt.Println("è®¾ç½®æ ‡å¿—")
        atomic.StoreInt32(&flag, 1)
    }()
    
    // ä¸»goroutineç­‰å¾…æ ‡å¿—å˜ä¸º1
    for atomic.LoadInt32(&flag) == 0 {
        fmt.Println("ç­‰å¾…æ ‡å¿—...")
        time.Sleep(200 * time.Millisecond)
    }
    
    fmt.Println("æ ‡å¿—å·²è®¾ç½®ï¼Œç»§ç»­æ‰§è¡Œ")
}
```

### 2.2 Storeæ“ä½œ
Storeæ“ä½œåŸå­åœ°å°†å€¼å­˜å‚¨åˆ°æŒ‡å®šåœ°å€ã€‚

```go
package main

import (
    "fmt"
    "sync/atomic"
    "sync"
)

func main() {
    var flag int32 = 0
    var wg sync.WaitGroup
    
    // å¯åŠ¨10ä¸ªgoroutineï¼Œæ¯ä¸ªç­‰å¾…æ ‡å¿—è®¾ç½®
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for atomic.LoadInt32(&flag) == 0 {
                // å¿™ç­‰å¾…
            }
            fmt.Printf("goroutine %d çœ‹åˆ°æ ‡å¿—å·²è®¾ç½®\n", id)
        }(i)
    }
    
    // è®¾ç½®æ ‡å¿—ï¼Œé€šçŸ¥æ‰€æœ‰goroutine
    fmt.Println("å³å°†è®¾ç½®æ ‡å¿—...")
    atomic.StoreInt32(&flag, 1)
    
    wg.Wait()
    fmt.Println("æ‰€æœ‰goroutineå·²å®Œæˆ")
}
```

### 2.3 Addæ“ä½œ
Addæ“ä½œåŸå­åœ°å°†å¢é‡æ·»åŠ åˆ°æŒ‡å®šåœ°å€çš„å€¼ï¼Œå¹¶è¿”å›æ–°å€¼ã€‚

```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

func main() {
    var counter int64 = 0
    var wg sync.WaitGroup
    
    // å¯åŠ¨1000ä¸ªgoroutineï¼Œæ¯ä¸ªé€’å¢è®¡æ•°å™¨10æ¬¡
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j < 10; j++ {
                atomic.AddInt64(&counter, 1)
            }
        }()
    }
    
    wg.Wait()
    fmt.Println("æœ€ç»ˆè®¡æ•°:", atomic.LoadInt64(&counter)) // åº”è¯¥æ˜¯10000
}
```

### 2.4 Swapæ“ä½œ
Swapæ“ä½œåŸå­åœ°å°†æ–°å€¼å­˜å‚¨åˆ°æŒ‡å®šåœ°å€å¹¶è¿”å›æ—§å€¼ã€‚

```go
package main

import (
    "fmt"
    "sync/atomic"
)

func main() {
    var status int32 = 0 // 0è¡¨ç¤ºç©ºé—²ï¼Œ1è¡¨ç¤ºå¿™ç¢Œ
    
    // å°è¯•å°†çŠ¶æ€ä»ç©ºé—²æ”¹ä¸ºå¿™ç¢Œ
    oldStatus := atomic.SwapInt32(&status, 1)
    
    if oldStatus == 0 {
        fmt.Println("æˆåŠŸè·å–èµ„æºï¼Œä¹‹å‰çŠ¶æ€ä¸ºç©ºé—²")
    } else {
        fmt.Println("èµ„æºå·²è¢«å ç”¨ï¼Œä¹‹å‰çŠ¶æ€ä¸ºå¿™ç¢Œ")
    }
    
    // å†æ¬¡å°è¯•è·å–èµ„æº
    oldStatus = atomic.SwapInt32(&status, 1)
    
    if oldStatus == 0 {
        fmt.Println("æˆåŠŸè·å–èµ„æºï¼Œä¹‹å‰çŠ¶æ€ä¸ºç©ºé—²")
    } else {
        fmt.Println("èµ„æºå·²è¢«å ç”¨ï¼Œä¹‹å‰çŠ¶æ€ä¸ºå¿™ç¢Œ")
    }
}
```

### 2.5 CompareAndSwap (CAS)
CASæ“ä½œä¼šæ¯”è¾ƒæŒ‡å®šåœ°å€çš„å€¼ä¸æœŸæœ›å€¼ï¼Œåªæœ‰å®ƒä»¬ç›¸ç­‰æ—¶æ‰ä¼šå°†æ–°å€¼å­˜å‚¨åˆ°è¯¥åœ°å€ï¼Œå¹¶è¿”å›æ˜¯å¦æˆåŠŸã€‚

```go
package main

import (
    "fmt"
    "sync/atomic"
    "sync"
)

// å®ç°è‡ªæ—‹é”
type SpinLock struct {
    locked int32
}

// å°è¯•è·å–é”
func (l *SpinLock) Lock() {
    // ä¸æ–­å°è¯•ç›´åˆ°æˆåŠŸ
    for !atomic.CompareAndSwapInt32(&l.locked, 0, 1) {
        // å¿™ç­‰å¾…ï¼ˆè‡ªæ—‹ï¼‰
    }
}

// é‡Šæ”¾é”
func (l *SpinLock) Unlock() {
    atomic.StoreInt32(&l.locked, 0)
}

func main() {
    var lock SpinLock
    var counter int
    var wg sync.WaitGroup
    
    // å¯åŠ¨10ä¸ªgoroutineï¼Œæ¯ä¸ªé€’å¢è®¡æ•°å™¨100æ¬¡
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            
            for j := 0; j < 100; j++ {
                lock.Lock()
                counter++
                lock.Unlock()
            }
        }()
    }
    
    wg.Wait()
    fmt.Println("æœ€ç»ˆè®¡æ•°:", counter) // åº”è¯¥æ˜¯1000
}
```

---

## 3. åŸå­æ“ä½œç±»å‹

### 3.1 æ•´æ•°ç±»å‹åŸå­æ“ä½œ
`sync/atomic`åŒ…æ”¯æŒå¯¹ä»¥ä¸‹æ•´æ•°ç±»å‹çš„åŸå­æ“ä½œï¼š
- `int32`ã€`uint32`
- `int64`ã€`uint64`
- `uintptr`

```go
package main

import (
    "fmt"
    "sync/atomic"
    "sync"
)

func main() {
    var (
        i32 int32 = 0
        u32 uint32 = 0
        i64 int64 = 0
        u64 uint64 = 0
        uptr uintptr = 0
    )
    
    var wg sync.WaitGroup
    wg.Add(5)
    
    // å¯¹int32çš„åŸå­æ“ä½œ
    go func() {
        defer wg.Done()
        atomic.AddInt32(&i32, 10)
        fmt.Println("int32:", atomic.LoadInt32(&i32))
    }()
    
    // å¯¹uint32çš„åŸå­æ“ä½œ
    go func() {
        defer wg.Done()
        atomic.AddUint32(&u32, 10)
        fmt.Println("uint32:", atomic.LoadUint32(&u32))
    }()
    
    // å¯¹int64çš„åŸå­æ“ä½œ
    go func() {
        defer wg.Done()
        atomic.AddInt64(&i64, 10)
        fmt.Println("int64:", atomic.LoadInt64(&i64))
    }()
    
    // å¯¹uint64çš„åŸå­æ“ä½œ
    go func() {
        defer wg.Done()
        atomic.AddUint64(&u64, 10)
        fmt.Println("uint64:", atomic.LoadUint64(&u64))
    }()
    
    // å¯¹uintptrçš„åŸå­æ“ä½œ
    go func() {
        defer wg.Done()
        atomic.AddUintptr(&uptr, 10)
        fmt.Println("uintptr:", atomic.LoadUintptr(&uptr))
    }()
    
    wg.Wait()
}
```

### 3.2 æŒ‡é’ˆç±»å‹åŸå­æ“ä½œ
`sync/atomic`åŒ…æä¾›äº†å¯¹æŒ‡é’ˆçš„åŸå­æ“ä½œï¼Œä½†éœ€è¦ä½¿ç”¨`unsafe.Pointer`ï¼š

```go
package main

import (
    "fmt"
    "sync/atomic"
    "unsafe"
)

type User struct {
    Name string
    Age  int
}

func main() {
    // åˆå§‹ç”¨æˆ·
    user := &User{Name: "Alice", Age: 25}
    var userPtr unsafe.Pointer = unsafe.Pointer(user)
    
    // åŠ è½½ç”¨æˆ·
    currentUser := (*User)(atomic.LoadPointer(&userPtr))
    fmt.Printf("å½“å‰ç”¨æˆ·: %+v\n", currentUser)
    
    // åˆ›å»ºæ–°ç”¨æˆ·
    newUser := &User{Name: "Bob", Age: 30}
    
    // åŸå­äº¤æ¢ç”¨æˆ·
    atomic.StorePointer(&userPtr, unsafe.Pointer(newUser))
    
    // åŠ è½½æ–°ç”¨æˆ·
    currentUser = (*User)(atomic.LoadPointer(&userPtr))
    fmt.Printf("å½“å‰ç”¨æˆ·: %+v\n", currentUser)
}
```

### 3.3 Valueç±»å‹
`atomic.Value`ç±»å‹æä¾›å¯¹ä»»æ„ç±»å‹çš„åŸå­æ“ä½œï¼š

```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
    "time"
)

type Config struct {
    MaxConnections int
    Timeout        time.Duration
}

func main() {
    // åˆ›å»ºåŸå­å€¼
    var config atomic.Value
    
    // å­˜å‚¨åˆå§‹é…ç½®
    initialConfig := Config{
        MaxConnections: 100,
        Timeout:        time.Second * 5,
    }
    config.Store(initialConfig)
    
    var wg sync.WaitGroup
    
    // å¯åŠ¨è¯»å–å™¨goroutine
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            // è¯»å–é…ç½®
            for j := 0; j < 3; j++ {
                time.Sleep(100 * time.Millisecond)
                cfg := config.Load().(Config)
                fmt.Printf("è¯»å–å™¨ %d: é…ç½® = %+v\n", id, cfg)
            }
        }(i)
    }
    
    // å¯åŠ¨æ›´æ–°å™¨goroutine
    wg.Add(1)
    go func() {
        defer wg.Done()
        
        // æ›´æ–°é…ç½®
        time.Sleep(300 * time.Millisecond)
        newConfig := Config{
            MaxConnections: 200,
            Timeout:        time.Second * 10,
        }
        fmt.Println("æ›´æ–°é…ç½®...")
        config.Store(newConfig)
    }()
    
    wg.Wait()
}
```

### 3.4 unsafe.Pointerä¸åŸå­æ“ä½œ
`unsafe.Pointer`å¯ä»¥ä¸åŸå­æ“ä½œç»“åˆï¼Œå®ç°å¯¹å¤æ‚æ•°æ®ç»“æ„çš„åŸå­è®¿é—®ï¼š

```go
package main

import (
    "fmt"
    "sync/atomic"
    "unsafe"
)

type Data struct {
    Counter int
    Flag    bool
}

func main() {
    // åˆ›å»ºåˆå§‹æ•°æ®
    data := &Data{Counter: 0, Flag: false}
    var dataPtr unsafe.Pointer = unsafe.Pointer(data)
    
    // åŸå­åŠ è½½æ•°æ®
    currentData := (*Data)(atomic.LoadPointer(&dataPtr))
    fmt.Printf("åˆå§‹æ•°æ®: %+v\n", currentData)
    
    // åˆ›å»ºæ–°æ•°æ®
    newData := &Data{Counter: 42, Flag: true}
    
    // ä½¿ç”¨CASåŸå­åœ°æ›¿æ¢æ•°æ®
    success := atomic.CompareAndSwapPointer(
        &dataPtr,
        unsafe.Pointer(data),
        unsafe.Pointer(newData),
    )
    
    if success {
        fmt.Println("CASæˆåŠŸ")
    } else {
        fmt.Println("CASå¤±è´¥")
    }
    
    // åŸå­åŠ è½½æ–°æ•°æ®
    currentData = (*Data)(atomic.LoadPointer(&dataPtr))
    fmt.Printf("å½“å‰æ•°æ®: %+v\n", currentData)
}
```

---

## 4. æ— é”ç¼–ç¨‹

### 4.1 æ— é”ç¼–ç¨‹çš„ä¼˜åŠ¿ä¸æŒ‘æˆ˜
æ— é”ç¼–ç¨‹çš„ä¼˜åŠ¿ï¼š
- é¿å…é”çš„å¼€é”€ï¼ˆä¸Šä¸‹æ–‡åˆ‡æ¢ã€ç³»ç»Ÿè°ƒç”¨ç­‰ï¼‰
- é™ä½æ­»é”é£é™©
- æé«˜æ€§èƒ½å’Œå¯ä¼¸ç¼©æ€§

æŒ‘æˆ˜ï¼š
- éœ€è¦æ­£ç¡®ç†è§£å†…å­˜æ¨¡å‹
- ä»£ç å¤æ‚åº¦è¾ƒé«˜
- æ˜“å‡ºç°éšè—Bug
- ABAé—®é¢˜

### 4.2 æ— é”é˜Ÿåˆ—å®ç°
```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
    "unsafe"
)

// å®šä¹‰é˜Ÿåˆ—èŠ‚ç‚¹
type Node struct {
    value interface{}
    next  unsafe.Pointer // *Node
}

// æ— é”é˜Ÿåˆ—
type LockFreeQueue struct {
    head unsafe.Pointer // *Node
    tail unsafe.Pointer // *Node
}

// åˆ›å»ºæ–°é˜Ÿåˆ—
func NewLockFreeQueue() *LockFreeQueue {
    // åˆ›å»ºå“¨å…µèŠ‚ç‚¹
    node := &Node{}
    ptr := unsafe.Pointer(node)
    
    return &LockFreeQueue{
        head: ptr,
        tail: ptr,
    }
}

// å…¥é˜Ÿ
func (q *LockFreeQueue) Enqueue(value interface{}) {
    // åˆ›å»ºæ–°èŠ‚ç‚¹
    newNode := &Node{value: value}
    newPtr := unsafe.Pointer(newNode)
    
    for {
        // è·å–å½“å‰å°¾èŠ‚ç‚¹
        tail := atomic.LoadPointer(&q.tail)
        tailNode := (*Node)(tail)
        next := atomic.LoadPointer(&tailNode.next)
        
        // æ£€æŸ¥å°¾èŠ‚ç‚¹æ˜¯å¦ä¸€è‡´
        if tail == atomic.LoadPointer(&q.tail) {
            // å¦‚æœå°¾èŠ‚ç‚¹çš„nextä¸ºnil
            if next == nil {
                // å°è¯•æ·»åŠ æ–°èŠ‚ç‚¹
                if atomic.CompareAndSwapPointer(&tailNode.next, nil, newPtr) {
                    // æˆåŠŸæ·»åŠ åï¼Œå°è¯•æ›´æ–°å°¾èŠ‚ç‚¹
                    atomic.CompareAndSwapPointer(&q.tail, tail, newPtr)
                    return
                }
            } else {
                // å°¾èŠ‚ç‚¹å·²ç»å˜åŒ–ï¼Œå°è¯•å¸®åŠ©ç§»åŠ¨å°¾èŠ‚ç‚¹
                atomic.CompareAndSwapPointer(&q.tail, tail, next)
            }
        }
    }
}

// å‡ºé˜Ÿ
func (q *LockFreeQueue) Dequeue() (interface{}, bool) {
    for {
        // è·å–å½“å‰å¤´èŠ‚ç‚¹
        head := atomic.LoadPointer(&q.head)
        tail := atomic.LoadPointer(&q.tail)
        headNode := (*Node)(head)
        next := atomic.LoadPointer(&headNode.next)
        
        // æ£€æŸ¥å¤´èŠ‚ç‚¹æ˜¯å¦ä¸€è‡´
        if head == atomic.LoadPointer(&q.head) {
            // é˜Ÿåˆ—ä¸ºç©ºçš„æƒ…å†µ
            if head == tail {
                if next == nil {
                    // é˜Ÿåˆ—ç¡®å®ä¸ºç©º
                    return nil, false
                }
                // å°¾èŠ‚ç‚¹è½åï¼Œå¸®åŠ©ç§»åŠ¨
                atomic.CompareAndSwapPointer(&q.tail, tail, next)
            } else {
                // è·å–å€¼
                nextNode := (*Node)(next)
                value := nextNode.value
                
                // å°è¯•ç§»åŠ¨å¤´èŠ‚ç‚¹
                if atomic.CompareAndSwapPointer(&q.head, head, next) {
                    return value, true
                }
            }
        }
    }
}

func main() {
    q := NewLockFreeQueue()
    
    // å…¥é˜Ÿæµ‹è¯•
    q.Enqueue(1)
    q.Enqueue(2)
    q.Enqueue(3)
    
    // å‡ºé˜Ÿæµ‹è¯•
    if v, ok := q.Dequeue(); ok {
        fmt.Println("å‡ºé˜Ÿ:", v)
    }
    if v, ok := q.Dequeue(); ok {
        fmt.Println("å‡ºé˜Ÿ:", v)
    }
    if v, ok := q.Dequeue(); ok {
        fmt.Println("å‡ºé˜Ÿ:", v)
    }
    if _, ok := q.Dequeue(); !ok {
        fmt.Println("é˜Ÿåˆ—ä¸ºç©º")
    }
    
    // å¹¶å‘æµ‹è¯•
    var wg sync.WaitGroup
    
    // ç”Ÿäº§è€…
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func(val int) {
            defer wg.Done()
            q.Enqueue(val)
        }(i)
    }
    
    // æ¶ˆè´¹è€…
    results := make(map[interface{}]bool)
    var mu sync.Mutex
    
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            if val, ok := q.Dequeue(); ok {
                mu.Lock()
                results[val] = true
                mu.Unlock()
            }
        }()
    }
    
    wg.Wait()
    
    // ç»Ÿè®¡ç»“æœ
    mu.Lock()
    fmt.Printf("æ¶ˆè´¹çš„å…ƒç´ æ•°é‡: %d\n", len(results))
    mu.Unlock()
}
```

### 4.3 ABAé—®é¢˜
ABAé—®é¢˜æ˜¯æŒ‡å¹¶å‘ç¯å¢ƒä¸­ï¼Œä¸€ä¸ªå€¼ä»Aå˜æˆBï¼Œå†å˜å›Aï¼Œä½¿å¾—é€šè¿‡CASæ“ä½œçš„çº¿ç¨‹æ— æ³•æ£€æµ‹åˆ°è¿™ç§å˜åŒ–ã€‚

```go
package main

import (
    "fmt"
    "sync/atomic"
    "time"
    "unsafe"
)

type Node struct {
    value int
    next  *Node
}

func main() {
    // åˆå§‹é“¾è¡¨: A -> B -> C
    nodeC := &Node{value: 3}
    nodeB := &Node{value: 2, next: nodeC}
    nodeA := &Node{value: 1, next: nodeB}
    
    // æŒ‡å‘é“¾è¡¨å¤´çš„åŸå­æŒ‡é’ˆ
    var head unsafe.Pointer = unsafe.Pointer(nodeA)
    
    // goroutine 1: å°è¯•åˆ é™¤èŠ‚ç‚¹A
    go func() {
        // ä¿å­˜åˆå§‹å¤´æŒ‡é’ˆå’Œä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        oldHead := (*Node)(atomic.LoadPointer(&head))
        next := oldHead.next
        
        // æ¨¡æ‹Ÿå»¶è¿Ÿï¼ŒæœŸé—´å…¶ä»–goroutineå¯èƒ½ä¿®æ”¹é“¾è¡¨
        fmt.Println("goroutine 1: å»¶è¿Ÿä¸­...")
        time.Sleep(100 * time.Millisecond)
        
        // ä½¿ç”¨CASå°è¯•æ›´æ–°å¤´æŒ‡é’ˆ
        // æ£€æŸ¥å¤´æŒ‡é’ˆæ˜¯å¦ä»ç„¶æŒ‡å‘Aï¼Œå¦‚æœæ˜¯ï¼Œåˆ™æ›¿æ¢ä¸ºB
        if atomic.CompareAndSwapPointer(&head, unsafe.Pointer(oldHead), unsafe.Pointer(next)) {
            fmt.Println("goroutine 1: CASæˆåŠŸï¼Œåˆ é™¤äº†èŠ‚ç‚¹A")
        } else {
            fmt.Println("goroutine 1: CASå¤±è´¥ï¼Œå¤´æŒ‡é’ˆå·²å˜åŒ–")
        }
    }()
    
    // goroutine 2: æ‰§è¡ŒABAé—®é¢˜çš„æ“ä½œåºåˆ—
    go func() {
        time.Sleep(10 * time.Millisecond) // ç¡®ä¿åœ¨goroutine 1ä¹‹åå¯åŠ¨
        
        // 1. åˆ é™¤èŠ‚ç‚¹A
        oldHead := (*Node)(atomic.LoadPointer(&head))
        atomic.StorePointer(&head, unsafe.Pointer(oldHead.next))
        fmt.Println("goroutine 2: åˆ é™¤äº†èŠ‚ç‚¹A")
        
        // 2. åˆ é™¤èŠ‚ç‚¹B
        oldHead = (*Node)(atomic.LoadPointer(&head))
        atomic.StorePointer(&head, unsafe.Pointer(oldHead.next))
        fmt.Println("goroutine 2: åˆ é™¤äº†èŠ‚ç‚¹B")
        
        // 3. é‡æ–°æ·»åŠ èŠ‚ç‚¹A
        nodeA.next = (*Node)(atomic.LoadPointer(&head)) // ç°åœ¨æŒ‡å‘C
        atomic.StorePointer(&head, unsafe.Pointer(nodeA))
        fmt.Println("goroutine 2: é‡æ–°æ·»åŠ äº†èŠ‚ç‚¹A")
        
        // ç°åœ¨é“¾è¡¨æ˜¯: A -> C
        // å¯¹goroutine 1æ¥è¯´ï¼Œå¤´æŒ‡é’ˆä»ç„¶æ˜¯Aï¼Œä½†é“¾è¡¨ç»“æ„å·²ç»æ”¹å˜
    }()
    
    // ç­‰å¾…goroutineå®Œæˆ
    time.Sleep(200 * time.Millisecond)
    
    // æ‰“å°æœ€ç»ˆé“¾è¡¨
    fmt.Println("\næœ€ç»ˆé“¾è¡¨:")
    current := (*Node)(atomic.LoadPointer(&head))
    for current != nil {
        fmt.Printf("%d -> ", current.value)
        current = current.next
    }
    fmt.Println("nil")
}
```

### 4.4 è§£å†³ABAé—®é¢˜ï¼šä½¿ç”¨æ ‡è®°æŒ‡é’ˆ
ä¸€ç§è§£å†³ABAé—®é¢˜çš„æ–¹æ³•æ˜¯ä½¿ç”¨æ ‡è®°æŒ‡é’ˆï¼Œä¸ºæŒ‡é’ˆæ·»åŠ ç‰ˆæœ¬å·æˆ–è®¡æ•°å™¨ï¼š

```go
package main

import (
    "fmt"
    "sync/atomic"
    "time"
    "unsafe"
)

// å¸¦ç‰ˆæœ¬å·çš„æŒ‡é’ˆ
type VersionedPointer struct {
    ptr     unsafe.Pointer
    version uint64
}

// è·å–æŒ‡é’ˆçš„åœ°å€å’Œç‰ˆæœ¬
func loadVersionedPointer(vpp *unsafe.Pointer) VersionedPointer {
    vpptr := (*VersionedPointer)(atomic.LoadPointer(vpp))
    return *vpptr
}

// åŸå­åœ°æ›´æ–°æŒ‡é’ˆå’Œç‰ˆæœ¬
func casVersionedPointer(vpp *unsafe.Pointer, old VersionedPointer, new VersionedPointer) bool {
    return atomic.CompareAndSwapPointer(
        vpp,
        unsafe.Pointer(&old),
        unsafe.Pointer(&new),
    )
}

// èŠ‚ç‚¹ç»“æ„
type Node struct {
    value int
    next  *Node
}

func main() {
    // åˆå§‹é“¾è¡¨: A -> B -> C
    nodeC := &Node{value: 3}
    nodeB := &Node{value: 2, next: nodeC}
    nodeA := &Node{value: 1, next: nodeB}
    
    // åˆå§‹ç‰ˆæœ¬åŒ–æŒ‡é’ˆ
    initialVP := VersionedPointer{
        ptr:     unsafe.Pointer(nodeA),
        version: 1,
    }
    
    // æŒ‡å‘é“¾è¡¨å¤´çš„åŸå­æŒ‡é’ˆ
    var head unsafe.Pointer = unsafe.Pointer(&initialVP)
    
    // goroutine 1: å°è¯•åˆ é™¤èŠ‚ç‚¹A
    go func() {
        // åŠ è½½åˆå§‹å¤´æŒ‡é’ˆå’Œç‰ˆæœ¬
        oldVP := loadVersionedPointer(&head)
        oldNode := (*Node)(oldVP.ptr)
        next := oldNode.next
        
        // æ¨¡æ‹Ÿå»¶è¿Ÿ
        fmt.Println("goroutine 1: å»¶è¿Ÿä¸­...")
        time.Sleep(100 * time.Millisecond)
        
        // å‡†å¤‡æ–°çš„ç‰ˆæœ¬åŒ–æŒ‡é’ˆï¼Œç‰ˆæœ¬+1
        newVP := VersionedPointer{
            ptr:     unsafe.Pointer(next),
            version: oldVP.version + 1,
        }
        
        // ä½¿ç”¨CASå°è¯•æ›´æ–°
        if casVersionedPointer(&head, oldVP, newVP) {
            fmt.Println("goroutine 1: CASæˆåŠŸï¼Œåˆ é™¤äº†èŠ‚ç‚¹A (ç‰ˆæœ¬:", newVP.version, ")")
        } else {
            currentVP := loadVersionedPointer(&head)
            fmt.Println("goroutine 1: CASå¤±è´¥ï¼Œå¤´æŒ‡é’ˆå·²å˜åŒ– (å½“å‰ç‰ˆæœ¬:", currentVP.version, ")")
        }
    }()
    
    // goroutine 2: æ‰§è¡ŒABAæ“ä½œåºåˆ—
    go func() {
        time.Sleep(10 * time.Millisecond) // ç¡®ä¿åœ¨goroutine 1ä¹‹åå¯åŠ¨
        
        // 1. åˆ é™¤èŠ‚ç‚¹A
        oldVP := loadVersionedPointer(&head)
        oldNode := (*Node)(oldVP.ptr)
        
        newVP := VersionedPointer{
            ptr:     unsafe.Pointer(oldNode.next),
            version: oldVP.version + 1,
        }
        
        if casVersionedPointer(&head, oldVP, newVP) {
            fmt.Println("goroutine 2: åˆ é™¤äº†èŠ‚ç‚¹A (ç‰ˆæœ¬:", newVP.version, ")")
            oldVP = newVP
        }
        
        // 2. åˆ é™¤èŠ‚ç‚¹B
        oldNode = (*Node)(oldVP.ptr)
        
        newVP = VersionedPointer{
            ptr:     unsafe.Pointer(oldNode.next),
            version: oldVP.version + 1,
        }
        
        if casVersionedPointer(&head, oldVP, newVP) {
            fmt.Println("goroutine 2: åˆ é™¤äº†èŠ‚ç‚¹B (ç‰ˆæœ¬:", newVP.version, ")")
            oldVP = newVP
        }
        
        // 3. é‡æ–°æ·»åŠ èŠ‚ç‚¹A
        nodeA.next = (*Node)(oldVP.ptr) // ç°åœ¨æŒ‡å‘C
        
        newVP = VersionedPointer{
            ptr:     unsafe.Pointer(nodeA),
            version: oldVP.version + 1,
        }
        
        if casVersionedPointer(&head, oldVP, newVP) {
            fmt.Println("goroutine 2: é‡æ–°æ·»åŠ äº†èŠ‚ç‚¹A (ç‰ˆæœ¬:", newVP.version, ")")
        }
    }()
    
    // ç­‰å¾…goroutineå®Œæˆ
    time.Sleep(200 * time.Millisecond)
    
    // æ‰“å°æœ€ç»ˆé“¾è¡¨å’Œç‰ˆæœ¬
    finalVP := loadVersionedPointer(&head)
    fmt.Printf("\næœ€ç»ˆé“¾è¡¨ (ç‰ˆæœ¬: %d):\n", finalVP.version)
    
    current := (*Node)(finalVP.ptr)
    for current != nil {
        fmt.Printf("%d -> ", current.value)
        current = current.next
    }
    fmt.Println("nil")
}
```

---

## 5. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 åŸå­è®¡æ•°å™¨
```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
    "time"
)

// åŸå­è®¡æ•°å™¨
type AtomicCounter struct {
    value int64
}

func (c *AtomicCounter) Increment() {
    atomic.AddInt64(&c.value, 1)
}

func (c *AtomicCounter) Decrement() {
    atomic.AddInt64(&c.value, -1)
}

func (c *AtomicCounter) Value() int64 {
    return atomic.LoadInt64(&c.value)
}

func main() {
    // åˆ›å»ºè®¡æ•°å™¨
    counter := AtomicCounter{}
    
    // å¯åŠ¨100ä¸ªgoroutineè¿›è¡Œé€’å¢
    var wg sync.WaitGroup
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            
            for j := 0; j < 1000; j++ {
                counter.Increment()
            }
        }()
    }
    
    // å¯åŠ¨100ä¸ªgoroutineè¿›è¡Œé€’å‡
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            
            for j := 0; j < 500; j++ {
                counter.Decrement()
            }
        }()
    }
    
    // æ¯100msæ‰“å°ä¸€æ¬¡è®¡æ•°å™¨å€¼
    done := make(chan struct{})
    go func() {
        for {
            select {
            case <-time.After(100 * time.Millisecond):
                fmt.Printf("å½“å‰è®¡æ•°: %d\n", counter.Value())
            case <-done:
                return
            }
        }
    }()
    
    wg.Wait()
    close(done)
    
    // æœ€ç»ˆç»“æœ
    fmt.Printf("æœ€ç»ˆè®¡æ•°: %d (é¢„æœŸ: 50000)\n", counter.Value())
}
```

### 5.2 é«˜æ€§èƒ½ç¼“å­˜
```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
    "time"
)

// ç¼“å­˜é¡¹
type CacheItem struct {
    key   string
    value interface{}
}

// åŸå­ç¼“å­˜
type AtomicCache struct {
    items   atomic.Value // å­˜å‚¨map[string]interface{}
    metrics struct {
        hits   uint64
        misses uint64
    }
}

// åˆ›å»ºæ–°ç¼“å­˜
func NewAtomicCache() *AtomicCache {
    cache := &AtomicCache{}
    cache.items.Store(make(map[string]interface{}))
    return cache
}

// è·å–ç¼“å­˜é¡¹
func (c *AtomicCache) Get(key string) (interface{}, bool) {
    items := c.items.Load().(map[string]interface{})
    value, found := items[key]
    
    if found {
        atomic.AddUint64(&c.metrics.hits, 1)
    } else {
        atomic.AddUint64(&c.metrics.misses, 1)
    }
    
    return value, found
}

// è®¾ç½®ç¼“å­˜é¡¹
func (c *AtomicCache) Set(key string, value interface{}) {
    for {
        // åŠ è½½å½“å‰æ˜ å°„
        oldItems := c.items.Load().(map[string]interface{})
        
        // åˆ›å»ºæ–°æ˜ å°„
        newItems := make(map[string]interface{}, len(oldItems)+1)
        for k, v := range oldItems {
            newItems[k] = v
        }
        
        // æ·»åŠ æˆ–æ›´æ–°é¡¹
        newItems[key] = value
        
        // å°è¯•æ›¿æ¢
        if c.items.CompareAndSwap(oldItems, newItems) {
            break
        }
    }
}

// è·å–å‘½ä¸­ç‡
func (c *AtomicCache) HitRatio() float64 {
    hits := atomic.LoadUint64(&c.metrics.hits)
    misses := atomic.LoadUint64(&c.metrics.misses)
    
    if hits+misses == 0 {
        return 0
    }
    
    return float64(hits) / float64(hits+misses)
}

func main() {
    cache := NewAtomicCache()
    
    // å¯åŠ¨10ä¸ªå†™å…¥è€…
    var wg sync.WaitGroup
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            for j := 0; j < 100; j++ {
                key := fmt.Sprintf("key-%d-%d", id, j)
                value := fmt.Sprintf("value-%d-%d", id, j)
                cache.Set(key, value)
                time.Sleep(time.Millisecond)
            }
        }(i)
    }
    
    // å¯åŠ¨20ä¸ªè¯»å–è€…
    for i := 0; i < 20; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            // å†³å®šè¯»å–çš„é”®èŒƒå›´
            startWriter := id % 10
            
            for j := 0; j < 200; j++ {
                // 80%çš„æ—¶é—´è¯»å–å·²æœ‰çš„é”®
                var key string
                if j%5 < 4 {
                    // è¯»å–å¯èƒ½å­˜åœ¨çš„é”®
                    keyID := j % 100
                    key = fmt.Sprintf("key-%d-%d", startWriter, keyID)
                } else {
                    // è¯»å–å¯èƒ½ä¸å­˜åœ¨çš„é”®
                    key = fmt.Sprintf("nonexistent-key-%d-%d", id, j)
                }
                
                if value, found := cache.Get(key); found {
                    _ = value
                    // fmt.Printf("è¯»å–è€… %d: æ‰¾åˆ° %s -> %v\n", id, key, value)
                } else {
                    // fmt.Printf("è¯»å–è€… %d: æœªæ‰¾åˆ° %s\n", id, key)
                }
                
                time.Sleep(time.Millisecond)
            }
        }(i)
    }
    
    // å®šæœŸæ‰“å°å‘½ä¸­ç‡
    done := make(chan struct{})
    go func() {
        for {
            select {
            case <-time.After(500 * time.Millisecond):
                fmt.Printf("å‘½ä¸­ç‡: %.2f%%\n", cache.HitRatio()*100)
            case <-done:
                return
            }
        }
    }()
    
    wg.Wait()
    close(done)
    
    // æœ€ç»ˆå‘½ä¸­ç‡
    fmt.Printf("æœ€ç»ˆå‘½ä¸­ç‡: %.2f%%\n", cache.HitRatio()*100)
}
```

### 5.3 æ— é”ç®—æ³•å®ç°
```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

// æ— é”æ ˆ
type LockFreeStack struct {
    top atomic.Value // *Node
}

type Node struct {
    value interface{}
    next  *Node
}

// åˆ›å»ºæ–°æ ˆ
func NewLockFreeStack() *LockFreeStack {
    stack := &LockFreeStack{}
    stack.top.Store((*Node)(nil))
    return stack
}

// å…¥æ ˆ
func (s *LockFreeStack) Push(value interface{}) {
    for {
        top := s.top.Load().(*Node)
        newNode := &Node{
            value: value,
            next:  top,
        }
        
        if s.top.CompareAndSwap(top, newNode) {
            return
        }
    }
}

// å‡ºæ ˆ
func (s *LockFreeStack) Pop() (interface{}, bool) {
    for {
        top := s.top.Load().(*Node)
        if top == nil {
            return nil, false
        }
        
        if s.top.CompareAndSwap(top, top.next) {
            return top.value, true
        }
    }
}

func main() {
    stack := NewLockFreeStack()
    
    // é¡ºåºæµ‹è¯•
    stack.Push(1)
    stack.Push(2)
    stack.Push(3)
    
    if val, ok := stack.Pop(); ok {
        fmt.Println("å‡ºæ ˆ:", val) // åº”è¯¥æ˜¯3
    }
    if val, ok := stack.Pop(); ok {
        fmt.Println("å‡ºæ ˆ:", val) // åº”è¯¥æ˜¯2
    }
    if val, ok := stack.Pop(); ok {
        fmt.Println("å‡ºæ ˆ:", val) // åº”è¯¥æ˜¯1
    }
    if _, ok := stack.Pop(); !ok {
        fmt.Println("æ ˆä¸ºç©º")
    }
    
    // å¹¶å‘æµ‹è¯•
    var wg sync.WaitGroup
    iterations := 1000
    
    // ç”Ÿäº§è€…
    for i := 0; i < iterations; i++ {
        wg.Add(1)
        go func(val int) {
            defer wg.Done()
            stack.Push(val)
        }(i)
    }
    
    // æ¶ˆè´¹è€…
    popped := int32(0)
    for i := 0; i < iterations; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            if _, ok := stack.Pop(); ok {
                atomic.AddInt32(&popped, 1)
            }
        }()
    }
    
    wg.Wait()
    fmt.Printf("å…¥æ ˆ %d é¡¹ï¼Œå‡ºæ ˆ %d é¡¹\n", iterations, popped)
    
    // æ£€æŸ¥å‰©ä½™å…ƒç´ 
    remaining := 0
    for {
        if _, ok := stack.Pop(); !ok {
            break
        }
        remaining++
    }
    fmt.Printf("æ ˆä¸­å‰©ä½™ %d é¡¹\n", remaining)
}
```

---

## 6. æœ€ä½³å®è·µ

### 6.1 ä½•æ—¶ä½¿ç”¨åŸå­æ“ä½œ
ä½¿ç”¨åŸå­æ“ä½œçš„åœºæ™¯ï¼š
- ç®€å•çš„è®¡æ•°å™¨
- æ ‡å¿—ä½è®¾ç½®å’Œæ£€æŸ¥
- å•ä¸ªå˜é‡çš„æ›´æ–°
- æ€§èƒ½å…³é”®çš„ä»£ç è·¯å¾„
- å®ç°æ— é”æ•°æ®ç»“æ„

ä½¿ç”¨äº’æ–¥é”çš„åœºæ™¯ï¼š
- å¤æ‚çš„æ•°æ®ç»“æ„
- å¤šä¸ªå˜é‡éœ€è¦åŒæ­¥
- éœ€è¦é•¿æ—¶é—´æŒæœ‰é”
- éœ€è¦å®ç°æ›´å¤æ‚çš„åŒæ­¥è¯­ä¹‰

### 6.2 æ€§èƒ½è€ƒè™‘
åŸå­æ“ä½œçš„æ€§èƒ½è€ƒè™‘ï¼š
- åŸå­æ“ä½œé€šå¸¸æ¯”äº’æ–¥é”å¿«ï¼Œä½†ä»æœ‰å¼€é”€
- è¿‡åº¦ä½¿ç”¨åŸå­æ“ä½œå¯èƒ½å¯¼è‡´ç¼“å­˜ä¸€è‡´æ€§é—®é¢˜
- åœ¨å¤šæ ¸ç³»ç»Ÿä¸Šï¼ŒåŸå­æ“ä½œå¯èƒ½å¯¼è‡´ç¼“å­˜è¡Œä¹’ä¹“ï¼ˆcache line ping-pongï¼‰
- è€ƒè™‘ä½¿ç”¨å¡«å……ï¼ˆpaddingï¼‰é¿å…ä¼ªå…±äº«

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
    "sync/atomic"
    "time"
)

// é¿å…ä¼ªå…±äº«çš„è®¡æ•°å™¨
type PaddedCounter struct {
    value int64
    _pad  [56]byte // è¡¥é½åˆ°64å­—èŠ‚ï¼ˆç¼“å­˜è¡Œå¤§å°ï¼‰
}

func main() {
    // è®¾ç½®æœ€å¤§å¯ç”¨CPU
    runtime.GOMAXPROCS(runtime.NumCPU())
    
    // åˆ›å»ºæ™®é€šè®¡æ•°å™¨å’Œå¡«å……è®¡æ•°å™¨
    var counter int64
    paddedCounters := make([]PaddedCounter, runtime.NumCPU())
    
    const iterations = 10000000
    
    // æµ‹è¯•å•ä¸ªå…±äº«è®¡æ•°å™¨
    start := time.Now()
    var wg sync.WaitGroup
    
    for i := 0; i < runtime.NumCPU(); i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            
            for j := 0; j < iterations; j++ {
                atomic.AddInt64(&counter, 1)
            }
        }()
    }
    
    wg.Wait()
    sharedTime := time.Since(start)
    
    // æµ‹è¯•å¡«å……è®¡æ•°å™¨ï¼ˆæ¯ä¸ªCPUä¸€ä¸ªï¼‰
    start = time.Now()
    
    for i := 0; i < runtime.NumCPU(); i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            for j := 0; j < iterations; j++ {
                atomic.AddInt64(&paddedCounters[id].value, 1)
            }
        }(i)
    }
    
    wg.Wait()
    paddedTime := time.Since(start)
    
    // è®¡ç®—å¡«å……è®¡æ•°å™¨æ€»å’Œ
    var paddedSum int64
    for i := 0; i < runtime.NumCPU(); i++ {
        paddedSum += atomic.LoadInt64(&paddedCounters[i].value)
    }
    
    // æ‰“å°ç»“æœ
    fmt.Printf("CPUæ ¸å¿ƒæ•°: %d\n", runtime.NumCPU())
    fmt.Printf("å…±äº«è®¡æ•°å™¨: å€¼=%d, è€—æ—¶=%v\n", atomic.LoadInt64(&counter), sharedTime)
    fmt.Printf("å¡«å……è®¡æ•°å™¨: å€¼=%d, è€—æ—¶=%v\n", paddedSum, paddedTime)
    fmt.Printf("å¡«å……è®¡æ•°å™¨æ€§èƒ½æå‡: %.2få€\n", float64(sharedTime)/float64(paddedTime))
}
```

### 6.3 é”™è¯¯æ¨¡å¼å’Œé™·é˜±
ä½¿ç”¨åŸå­æ“ä½œæ—¶çš„å¸¸è§é”™è¯¯ï¼š

1. **éƒ¨åˆ†åŸå­åŒ–**ï¼šåªå¯¹éƒ¨åˆ†æ“ä½œä½¿ç”¨åŸå­æ“ä½œï¼Œè€Œå…¶ä»–æ“ä½œä¸ä½¿ç”¨

```go
// é”™è¯¯ç¤ºä¾‹
var counter int64

// åŸå­é€’å¢
atomic.AddInt64(&counter, 1)

// éåŸå­è¯»å– - é”™è¯¯ï¼
fmt.Println(counter)

// æ­£ç¡®æ–¹å¼
fmt.Println(atomic.LoadInt64(&counter))
```

2. **å‡è®¾åŸå­æ“ä½œæä¾›å†…å­˜å±éšœ**ï¼šåœ¨æŸäº›æ¶æ„ä¸Šï¼ŒåŸå­æ“ä½œå¯èƒ½ä¸æä¾›å®Œæ•´çš„å†…å­˜å±éšœ

```go
// å¯èƒ½å­˜åœ¨é—®é¢˜çš„ä»£ç 
var ready int32
var data []int

func setup() {
    // åˆå§‹åŒ–æ•°æ®
    data = []int{1, 2, 3}
    
    // è®¾ç½®å°±ç»ªæ ‡å¿—
    atomic.StoreInt32(&ready, 1)
}

func worker() {
    // æ£€æŸ¥å°±ç»ªæ ‡å¿—
    if atomic.LoadInt32(&ready) == 1 {
        // è®¿é—®æ•°æ®
        fmt.Println(data) // å¯èƒ½çœ‹åˆ°æœªåˆå§‹åŒ–çš„æ•°æ®
    }
}
```

3. **å¿½ç•¥ABAé—®é¢˜**ï¼šåœ¨æ— é”æ•°æ®ç»“æ„ä¸­æœªå¤„ç†ABAé—®é¢˜

### 6.4 è°ƒè¯•æŠ€å·§
è°ƒè¯•åŸå­æ“ä½œç›¸å…³é—®é¢˜ï¼š

1. ä½¿ç”¨Race Detector

```bash
go test -race ./...
go run -race main.go
```

2. æ·»åŠ æ—¥å¿—å’Œæ–­è¨€

```go
// æ·»åŠ æ–­è¨€æ£€æŸ¥
func (s *LockFreeStack) Push(value interface{}) {
    for {
        top := s.top.Load().(*Node)
        newNode := &Node{
            value: value,
            next:  top,
        }
        
        if s.top.CompareAndSwap(top, newNode) {
            // æ–­è¨€æ£€æŸ¥
            current := s.top.Load().(*Node)
            if current != newNode {
                panic("Pushæ“ä½œåæ ˆé¡¶æŒ‡é’ˆä¸ç¬¦åˆé¢„æœŸ")
            }
            return
        }
    }
}
```

3. ä½¿ç”¨å¯è§†åŒ–å·¥å…·å¦‚pprofåˆ†ææ€§èƒ½ç“¶é¢ˆ

```go
import _ "net/http/pprof"

func main() {
    // å¯åŠ¨pprofæœåŠ¡å™¨
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    
    // å…¶ä»–ä»£ç ...
}
```

---

## 7. å­¦ä¹ æ£€æŸ¥ç‚¹

- [ ] ç†è§£åŸå­æ“ä½œçš„åŸºæœ¬æ¦‚å¿µ
- [ ] æŒæ¡Loadã€Storeã€Addã€Swapå’ŒCASæ“ä½œ
- [ ] èƒ½ä½¿ç”¨atomic.Valueå¤„ç†å¤æ‚æ•°æ®
- [ ] ç†è§£å¹¶å¤„ç†ABAé—®é¢˜
- [ ] èƒ½å®ç°ç®€å•çš„æ— é”æ•°æ®ç»“æ„
- [ ] äº†è§£åŸå­æ“ä½œçš„æ€§èƒ½è€ƒè™‘

---

åŸå­æ“ä½œæ˜¯Goè¯­è¨€å¹¶å‘ç¼–ç¨‹çš„å¼ºå¤§å·¥å…·ï¼Œå¯ä»¥åœ¨å¾ˆå¤šæƒ…å†µä¸‹æä¾›æ¯”äº’æ–¥é”æ›´é«˜æ•ˆçš„åŒæ­¥æœºåˆ¶ã€‚é€šè¿‡æŒæ¡`sync/atomic`åŒ…æä¾›çš„å„ç§åŸå­æ“ä½œï¼Œä½ å¯ä»¥ç¼–å†™å‡ºé«˜æ€§èƒ½ã€å¯ä¼¸ç¼©çš„å¹¶å‘ç¨‹åºï¼Œç”šè‡³å®ç°æ— é”æ•°æ®ç»“æ„ã€‚è®°ä½ï¼Œè™½ç„¶åŸå­æ“ä½œå¼ºå¤§ï¼Œä½†ä¹Ÿè¦æ…é‡ä½¿ç”¨ï¼Œç¡®ä¿æ­£ç¡®ç†è§£å†…å­˜æ¨¡å‹å’Œå¹¶å‘å®‰å…¨æ€§ã€‚
