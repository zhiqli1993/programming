# Goè¯­è¨€å¹¶å‘æ€§èƒ½è°ƒä¼˜

## ğŸ“š å­¦ä¹ ç›®æ ‡
æŒæ¡Goè¯­è¨€å¹¶å‘ç¨‹åºçš„æ€§èƒ½åˆ†æã€ç“¶é¢ˆè¯†åˆ«å’Œä¼˜åŒ–æŠ€æœ¯ï¼Œèƒ½å¤Ÿæ„å»ºé«˜æ•ˆã€å¯æ‰©å±•çš„å¹¶å‘ç³»ç»Ÿã€‚

---

## 1. æ€§èƒ½åˆ†æåŸºç¡€

### 1.1 ä½¿ç”¨pprofè¿›è¡Œæ€§èƒ½åˆ†æ
```go
package main

import (
    "fmt"
    "log"
    "net/http"
    _ "net/http/pprof" // å¼•å…¥pprof
    "runtime"
    "sync"
    "time"
)

func computeIntensive() {
    // è®¡ç®—å¯†é›†å‹ä»»åŠ¡
    for i := 0; i < 1000000; i++ {
        _ = i * i
    }
}

func memoryIntensive() {
    // å†…å­˜å¯†é›†å‹ä»»åŠ¡
    data := make([]byte, 10*1024*1024) // åˆ†é…10MBå†…å­˜
    for i := range data {
        data[i] = byte(i % 255)
    }
    _ = data
}

func simulateWorkload() {
    var wg sync.WaitGroup
    
    // å¯åŠ¨10ä¸ªgoroutineæ‰§è¡Œè®¡ç®—å¯†é›†å‹ä»»åŠ¡
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            computeIntensive()
        }()
    }
    
    // å¯åŠ¨5ä¸ªgoroutineæ‰§è¡Œå†…å­˜å¯†é›†å‹ä»»åŠ¡
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            memoryIntensive()
        }()
    }
    
    wg.Wait()
}

func main() {
    // å¯åŠ¨pprofæœåŠ¡å™¨
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    
    fmt.Println("æ€§èƒ½åˆ†ææœåŠ¡å™¨å¯åŠ¨åœ¨ http://localhost:6060/debug/pprof/")
    fmt.Println("æŒ‰Ctrl+Cé€€å‡º")
    
    // å®šæœŸæ‰§è¡Œå·¥ä½œè´Ÿè½½
    for {
        simulateWorkload()
        time.Sleep(500 * time.Millisecond)
    }
}
```

ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤æ”¶é›†å’Œåˆ†ææ€§èƒ½æ•°æ®ï¼š

```bash
# CPUåˆ†æ
go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30

# å†…å­˜åˆ†æ
go tool pprof http://localhost:6060/debug/pprof/heap

# é˜»å¡åˆ†æ
go tool pprof http://localhost:6060/debug/pprof/block

# Goroutineåˆ†æ
go tool pprof http://localhost:6060/debug/pprof/goroutine
```

### 1.2 ä½¿ç”¨traceå·¥å…·è¿›è¡Œåˆ†æ
```go
package main

import (
    "context"
    "fmt"
    "os"
    "runtime/trace"
    "sync"
)

func main() {
    // åˆ›å»ºtraceæ–‡ä»¶
    f, err := os.Create("trace.out")
    if err != nil {
        panic(err)
    }
    defer f.Close()
    
    // å¼€å§‹è®°å½•trace
    err = trace.Start(f)
    if err != nil {
        panic(err)
    }
    defer trace.Stop()
    
    // æ‰§è¡Œéœ€è¦åˆ†æçš„ä»£ç 
    var wg sync.WaitGroup
    
    // åˆ›å»ºä¸€ä¸ªä»»åŠ¡
    ctx := context.Background()
    ctx, task := trace.NewTask(ctx, "main")
    defer task.End()
    
    // å¯åŠ¨10ä¸ªgoroutine
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            // åˆ›å»ºåŒºåŸŸä»¥ä¾¿åœ¨traceä¸­è¯†åˆ«
            trace.WithRegion(ctx, fmt.Sprintf("worker-%d", id), func() {
                // æ¨¡æ‹Ÿå·¥ä½œ
                sum := 0
                for i := 0; i < 1000000; i++ {
                    sum += i
                }
            })
        }(i)
    }
    
    wg.Wait()
    
    fmt.Println("Traceå·²è®°å½•åˆ°trace.out")
    fmt.Println("ä½¿ç”¨'go tool trace trace.out'æŸ¥çœ‹")
}
```

ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤æŸ¥çœ‹traceï¼š

```bash
go tool trace trace.out
```

---

## 2. å¹¶å‘ç“¶é¢ˆè¯†åˆ«

### 2.1 è¯†åˆ«é”ç«äº‰
```go
package main

import (
    "fmt"
    "net/http"
    _ "net/http/pprof"
    "sync"
    "time"
)

var (
    counter int
    mutex   sync.Mutex
)

func highContentionIncrement() {
    for i := 0; i < 1000; i++ {
        mutex.Lock()
        counter++
        mutex.Unlock()
    }
}

func lowContentionIncrement() {
    // æ‰¹å¤„ç†å¢åŠ ï¼Œå‡å°‘é”ç«äº‰
    local := 0
    for i := 0; i < 1000; i++ {
        local++
    }
    
    // åªé”ä¸€æ¬¡
    mutex.Lock()
    counter += local
    mutex.Unlock()
}

func main() {
    // å¯åŠ¨pprof
    go func() {
        fmt.Println("pprofæœåŠ¡å¯åŠ¨åœ¨: http://localhost:6060/debug/pprof/")
        http.ListenAndServe("localhost:6060", nil)
    }()
    
    fmt.Println("å¼€å§‹é«˜ç«äº‰æµ‹è¯•...")
    
    var wg sync.WaitGroup
    start := time.Now()
    
    // é«˜ç«äº‰æƒ…å†µ
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            highContentionIncrement()
        }()
    }
    
    wg.Wait()
    highDuration := time.Since(start)
    fmt.Printf("é«˜ç«äº‰ç”¨æ—¶: %v, è®¡æ•°å™¨å€¼: %d\n", highDuration, counter)
    
    // é‡ç½®è®¡æ•°å™¨
    counter = 0
    
    fmt.Println("å¼€å§‹ä½ç«äº‰æµ‹è¯•...")
    start = time.Now()
    
    // ä½ç«äº‰æƒ…å†µ
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            lowContentionIncrement()
        }()
    }
    
    wg.Wait()
    lowDuration := time.Since(start)
    fmt.Printf("ä½ç«äº‰ç”¨æ—¶: %v, è®¡æ•°å™¨å€¼: %d\n", lowDuration, counter)
    fmt.Printf("æ€§èƒ½æå‡: %.2få€\n", float64(highDuration)/float64(lowDuration))
    
    fmt.Println("è¿è¡Œ'go tool pprof http://localhost:6060/debug/pprof/mutex'åˆ†æé”ç«äº‰")
    select {} // ä¿æŒç¨‹åºè¿è¡Œä»¥ä¾¿è¿›è¡Œpprofåˆ†æ
}
```

### 2.2 è¯†åˆ«Channelç“¶é¢ˆ
```go
package main

import (
    "fmt"
    "net/http"
    _ "net/http/pprof"
    "sync"
    "time"
)

func unbufferedChannelTest() time.Duration {
    start := time.Now()
    ch := make(chan int) // æ— ç¼“å†²é€šé“
    
    var wg sync.WaitGroup
    wg.Add(2)
    
    // å‘é€è€…
    go func() {
        defer wg.Done()
        for i := 0; i < 10000; i++ {
            ch <- i // æ¯æ¬¡å‘é€éƒ½éœ€è¦ç­‰å¾…æ¥æ”¶è€…å‡†å¤‡å¥½
        }
        close(ch)
    }()
    
    // æ¥æ”¶è€…
    go func() {
        defer wg.Done()
        for range ch {
            // æ¨¡æ‹Ÿæ¥æ”¶å¤„ç†
            time.Sleep(10 * time.Microsecond)
        }
    }()
    
    wg.Wait()
    return time.Since(start)
}

func bufferedChannelTest() time.Duration {
    start := time.Now()
    ch := make(chan int, 1000) // ç¼“å†²é€šé“
    
    var wg sync.WaitGroup
    wg.Add(2)
    
    // å‘é€è€…
    go func() {
        defer wg.Done()
        for i := 0; i < 10000; i++ {
            ch <- i // å¯ä»¥å¡«æ»¡ç¼“å†²åŒºè€Œä¸é˜»å¡
        }
        close(ch)
    }()
    
    // æ¥æ”¶è€…
    go func() {
        defer wg.Done()
        for range ch {
            // æ¨¡æ‹Ÿæ¥æ”¶å¤„ç†
            time.Sleep(10 * time.Microsecond)
        }
    }()
    
    wg.Wait()
    return time.Since(start)
}

func main() {
    // å¯åŠ¨pprof
    go func() {
        fmt.Println("pprofæœåŠ¡å¯åŠ¨åœ¨: http://localhost:6060/debug/pprof/")
        http.ListenAndServe("localhost:6060", nil)
    }()
    
    fmt.Println("å¼€å§‹æ— ç¼“å†²é€šé“æµ‹è¯•...")
    unbufferedTime := unbufferedChannelTest()
    fmt.Printf("æ— ç¼“å†²é€šé“ç”¨æ—¶: %v\n", unbufferedTime)
    
    fmt.Println("å¼€å§‹ç¼“å†²é€šé“æµ‹è¯•...")
    bufferedTime := bufferedChannelTest()
    fmt.Printf("ç¼“å†²é€šé“ç”¨æ—¶: %v\n", bufferedTime)
    
    fmt.Printf("æ€§èƒ½æå‡: %.2få€\n", float64(unbufferedTime)/float64(bufferedTime))
    
    fmt.Println("è¿è¡Œ'go tool pprof http://localhost:6060/debug/pprof/profile'åˆ†æCPUä½¿ç”¨æƒ…å†µ")
    select {} // ä¿æŒç¨‹åºè¿è¡Œä»¥ä¾¿è¿›è¡Œpprofåˆ†æ
}
```

---

## 3. å¹¶å‘æ¨¡å¼ä¼˜åŒ–

### 3.1 ä¼˜åŒ–å·¥ä½œæ± æ¨¡å¼
```go
package main

import (
    "fmt"
    "runtime"
    "sync"
    "time"
)

type Job struct {
    ID  int
    Num int
}

type Result struct {
    JobID int
    Sum   int
}

// ç®€å•å·¥ä½œæ± å®ç°
func simpleWorkerPool(numWorkers int, jobs []Job) []Result {
    results := make([]Result, 0, len(jobs))
    jobsChan := make(chan Job, len(jobs))
    resultsChan := make(chan Result, len(jobs))
    
    // å¯åŠ¨å·¥ä½œè€…
    var wg sync.WaitGroup
    for i := 0; i < numWorkers; i++ {
        wg.Add(1)
        go func(workerID int) {
            defer wg.Done()
            for job := range jobsChan {
                // æ¨¡æ‹Ÿè®¡ç®—
                sum := 0
                for i := 0; i < job.Num; i++ {
                    sum += i
                }
                resultsChan <- Result{JobID: job.ID, Sum: sum}
            }
        }(i)
    }
    
    // å‘é€ä»»åŠ¡
    for _, job := range jobs {
        jobsChan <- job
    }
    close(jobsChan)
    
    // ç­‰å¾…æ‰€æœ‰å·¥ä½œè€…å®Œæˆ
    go func() {
        wg.Wait()
        close(resultsChan)
    }()
    
    // æ”¶é›†ç»“æœ
    for result := range resultsChan {
        results = append(results, result)
    }
    
    return results
}

// ä¼˜åŒ–çš„å·¥ä½œæ± å®ç°
func optimizedWorkerPool(numWorkers int, jobs []Job) []Result {
    results := make([]Result, len(jobs)) // é¢„åˆ†é…ç»“æœç©ºé—´
    
    // å°†ä»»åŠ¡åˆ†æˆè¾ƒå¤§çš„å—ï¼Œå‡å°‘é€šé“æ“ä½œ
    batchSize := max(len(jobs)/numWorkers, 1)
    numBatches := (len(jobs) + batchSize - 1) / batchSize
    
    var wg sync.WaitGroup
    for b := 0; b < numBatches; b++ {
        wg.Add(1)
        
        // è®¡ç®—æ¯ä¸ªæ‰¹æ¬¡çš„å¼€å§‹å’Œç»“æŸç´¢å¼•
        start := b * batchSize
        end := min(start+batchSize, len(jobs))
        
        go func(startIdx, endIdx int) {
            defer wg.Done()
            
            for i := startIdx; i < endIdx; i++ {
                job := jobs[i]
                
                // æ¨¡æ‹Ÿè®¡ç®—
                sum := 0
                for j := 0; j < job.Num; j++ {
                    sum += j
                }
                
                // ç›´æ¥å†™å…¥ç»“æœ
                results[i] = Result{JobID: job.ID, Sum: sum}
            }
        }(start, end)
    }
    
    wg.Wait()
    return results
}

// Helperå‡½æ•°
func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    // å‡†å¤‡æµ‹è¯•æ•°æ®
    numJobs := 10000
    jobs := make([]Job, numJobs)
    for i := 0; i < numJobs; i++ {
        jobs[i] = Job{ID: i, Num: 1000000}
    }
    
    numWorkers := runtime.NumCPU()
    fmt.Printf("ä½¿ç”¨ %d ä¸ªå·¥ä½œè€…å¤„ç† %d ä¸ªä»»åŠ¡\n", numWorkers, numJobs)
    
    // æµ‹è¯•ç®€å•å·¥ä½œæ± 
    fmt.Println("æµ‹è¯•ç®€å•å·¥ä½œæ± ...")
    start := time.Now()
    results1 := simpleWorkerPool(numWorkers, jobs)
    simpleTime := time.Since(start)
    fmt.Printf("ç®€å•å·¥ä½œæ± å®Œæˆï¼Œå¤„ç† %d ä¸ªç»“æœï¼Œè€—æ—¶: %v\n", len(results1), simpleTime)
    
    // æµ‹è¯•ä¼˜åŒ–å·¥ä½œæ± 
    fmt.Println("æµ‹è¯•ä¼˜åŒ–å·¥ä½œæ± ...")
    start = time.Now()
    results2 := optimizedWorkerPool(numWorkers, jobs)
    optimizedTime := time.Since(start)
    fmt.Printf("ä¼˜åŒ–å·¥ä½œæ± å®Œæˆï¼Œå¤„ç† %d ä¸ªç»“æœï¼Œè€—æ—¶: %v\n", len(results2), optimizedTime)
    
    fmt.Printf("æ€§èƒ½æå‡: %.2få€\n", float64(simpleTime)/float64(optimizedTime))
}
```

### 3.2 å‡å°‘Contextåˆ‡æ¢å¼€é”€
```go
package main

import (
    "fmt"
    "runtime"
    "sync"
    "time"
)

func highSwitchingWorkload() time.Duration {
    start := time.Now()
    var wg sync.WaitGroup
    
    // åˆ›å»ºå¾ˆå¤šå°ä»»åŠ¡çš„goroutines
    for i := 0; i < 10000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            // éå¸¸å°çš„å·¥ä½œå•å…ƒ
            sum := 0
            for j := 0; j < 1000; j++ {
                sum += j
            }
        }()
    }
    
    wg.Wait()
    return time.Since(start)
}

func lowSwitchingWorkload() time.Duration {
    start := time.Now()
    var wg sync.WaitGroup
    
    // åˆ›å»ºä¸CPUæ ¸å¿ƒæ•°é‡ç›¸åŒçš„goroutines
    numWorkers := runtime.NumCPU()
    workPerWorker := 10000 / numWorkers
    
    for i := 0; i < numWorkers; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            
            // æ›´å¤§çš„å·¥ä½œå•å…ƒ
            for w := 0; w < workPerWorker; w++ {
                sum := 0
                for j := 0; j < 1000; j++ {
                    sum += j
                }
            }
        }()
    }
    
    wg.Wait()
    return time.Since(start)
}

func main() {
    fmt.Printf("CPUæ ¸å¿ƒæ•°: %d\n", runtime.NumCPU())
    runtime.GOMAXPROCS(runtime.NumCPU())
    
    fmt.Println("å¼€å§‹é«˜åˆ‡æ¢å¼€é”€æµ‹è¯•...")
    highTime := highSwitchingWorkload()
    fmt.Printf("é«˜åˆ‡æ¢å¼€é”€ç”¨æ—¶: %v\n", highTime)
    
    fmt.Println("å¼€å§‹ä½åˆ‡æ¢å¼€é”€æµ‹è¯•...")
    lowTime := lowSwitchingWorkload()
    fmt.Printf("ä½åˆ‡æ¢å¼€é”€ç”¨æ—¶: %v\n", lowTime)
    
    fmt.Printf("æ€§èƒ½æå‡: %.2få€\n", float64(highTime)/float64(lowTime))
}
```

---

## 4. å†…å­˜ä¼˜åŒ–æŠ€æœ¯

### 4.1 å‡å°‘å†…å­˜åˆ†é…
```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

func withoutPreallocation() (time.Duration, uint64) {
    start := time.Now()
    
    var m1, m2 runtime.MemStats
    runtime.ReadMemStats(&m1)
    
    // ä¸é¢„åˆ†é…å†…å­˜
    s := make([]int, 0)
    for i := 0; i < 1000000; i++ {
        s = append(s, i)
    }
    
    runtime.ReadMemStats(&m2)
    
    return time.Since(start), m2.TotalAlloc - m1.TotalAlloc
}

func withPreallocation() (time.Duration, uint64) {
    start := time.Now()
    
    var m1, m2 runtime.MemStats
    runtime.ReadMemStats(&m1)
    
    // é¢„åˆ†é…å†…å­˜
    s := make([]int, 0, 1000000)
    for i := 0; i < 1000000; i++ {
        s = append(s, i)
    }
    
    runtime.ReadMemStats(&m2)
    
    return time.Since(start), m2.TotalAlloc - m1.TotalAlloc
}

func main() {
    fmt.Println("æµ‹è¯•ä¸é¢„åˆ†é…å†…å­˜çš„æ€§èƒ½...")
    d1, m1 := withoutPreallocation()
    fmt.Printf("ä¸é¢„åˆ†é…: ç”¨æ—¶ %v, åˆ†é…å†…å­˜ %d å­—èŠ‚\n", d1, m1)
    
    fmt.Println("æµ‹è¯•é¢„åˆ†é…å†…å­˜çš„æ€§èƒ½...")
    d2, m2 := withPreallocation()
    fmt.Printf("é¢„åˆ†é…: ç”¨æ—¶ %v, åˆ†é…å†…å­˜ %d å­—èŠ‚\n", d2, m2)
    
    fmt.Printf("æ—¶é—´æ€§èƒ½æå‡: %.2få€\n", float64(d1)/float64(d2))
    fmt.Printf("å†…å­˜åˆ†é…å‡å°‘: %.2f%%\n", 100*(1-float64(m2)/float64(m1)))
}
```

### 4.2 å¯¹è±¡æ± å¤ç”¨
```go
package main

import (
    "bytes"
    "fmt"
    "sync"
    "time"
)

func withoutObjectPool() time.Duration {
    start := time.Now()
    var wg sync.WaitGroup
    
    for i := 0; i < 1000000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            
            // æ¯æ¬¡åˆ›å»ºæ–°çš„buffer
            var buf bytes.Buffer
            buf.WriteString("Hello, World!")
            _ = buf.String()
        }()
        
        // é™åˆ¶goroutineæ•°é‡
        if i%1000 == 0 {
            wg.Wait()
        }
    }
    
    wg.Wait()
    return time.Since(start)
}

func withObjectPool() time.Duration {
    start := time.Now()
    
    // åˆ›å»ºå¯¹è±¡æ± 
    pool := &sync.Pool{
        New: func() interface{} {
            return new(bytes.Buffer)
        },
    }
    
    var wg sync.WaitGroup
    
    for i := 0; i < 1000000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            
            // ä»æ± ä¸­è·å–å¯¹è±¡
            buf := pool.Get().(*bytes.Buffer)
            buf.Reset() // é‡ç½®çŠ¶æ€
            
            buf.WriteString("Hello, World!")
            _ = buf.String()
            
            // æ”¾å›æ± ä¸­
            pool.Put(buf)
        }()
        
        // é™åˆ¶goroutineæ•°é‡
        if i%1000 == 0 {
            wg.Wait()
        }
    }
    
    wg.Wait()
    return time.Since(start)
}

func main() {
    fmt.Println("æµ‹è¯•ä¸ä½¿ç”¨å¯¹è±¡æ± çš„æ€§èƒ½...")
    d1 := withoutObjectPool()
    fmt.Printf("ä¸ä½¿ç”¨å¯¹è±¡æ± : ç”¨æ—¶ %v\n", d1)
    
    fmt.Println("æµ‹è¯•ä½¿ç”¨å¯¹è±¡æ± çš„æ€§èƒ½...")
    d2 := withObjectPool()
    fmt.Printf("ä½¿ç”¨å¯¹è±¡æ± : ç”¨æ—¶ %v\n", d2)
    
    fmt.Printf("æ€§èƒ½æå‡: %.2få€\n", float64(d1)/float64(d2))
}
```

---

## 5. æé«˜å¹¶å‘ååé‡

### 5.1 æ‰¹å¤„ç†æŠ€æœ¯
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// æ¨¡æ‹Ÿæ•°æ®å¤„ç†å‡½æ•°
func processItem(item int) int {
    // æ¨¡æ‹Ÿå¤„ç†è€—æ—¶
    time.Sleep(time.Microsecond)
    return item * 2
}

// å•é¡¹å¤„ç†
func processItemsOneByOne(items []int) []int {
    results := make([]int, len(items))
    for i, item := range items {
        results[i] = processItem(item)
    }
    return results
}

// æ‰¹å¤„ç†
func processItemsInBatches(items []int, batchSize int) []int {
    results := make([]int, len(items))
    numBatches := (len(items) + batchSize - 1) / batchSize
    
    var wg sync.WaitGroup
    for b := 0; b < numBatches; b++ {
        wg.Add(1)
        
        go func(batchIndex int) {
            defer wg.Done()
            
            start := batchIndex * batchSize
            end := min(start+batchSize, len(items))
            
            for i := start; i < end; i++ {
                results[i] = processItem(items[i])
            }
        }(b)
    }
    
    wg.Wait()
    return results
}

func main() {
    // å‡†å¤‡æ•°æ®
    const numItems = 1000
    items := make([]int, numItems)
    for i := range items {
        items[i] = i + 1
    }
    
    // æµ‹è¯•å•é¡¹å¤„ç†
    fmt.Println("å¼€å§‹å•é¡¹å¤„ç†æµ‹è¯•...")
    start := time.Now()
    results1 := processItemsOneByOne(items)
    singleTime := time.Since(start)
    fmt.Printf("å•é¡¹å¤„ç†ç”¨æ—¶: %v, ç»“æœæ•°é‡: %d\n", singleTime, len(results1))
    
    // æµ‹è¯•æ‰¹å¤„ç†
    fmt.Println("å¼€å§‹æ‰¹å¤„ç†æµ‹è¯•...")
    start = time.Now()
    results2 := processItemsInBatches(items, 100)
    batchTime := time.Since(start)
    fmt.Printf("æ‰¹å¤„ç†ç”¨æ—¶: %v, ç»“æœæ•°é‡: %d\n", batchTime, len(results2))
    
    fmt.Printf("æ€§èƒ½æå‡: %.2få€\n", float64(singleTime)/float64(batchTime))
}
```

### 5.2 å¹¶è¡Œæµæ°´çº¿
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// å®šä¹‰æµæ°´çº¿é˜¶æ®µ
func stage1(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            // æ¨¡æ‹Ÿå¤„ç†
            time.Sleep(10 * time.Millisecond)
            out <- n * 2
        }
    }()
    return out
}

func stage2(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            // æ¨¡æ‹Ÿå¤„ç†
            time.Sleep(20 * time.Millisecond)
            out <- n + 10
        }
    }()
    return out
}

func stage3(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            // æ¨¡æ‹Ÿå¤„ç†
            time.Sleep(15 * time.Millisecond)
            out <- n * n
        }
    }()
    return out
}

// ç®€å•é¡ºåºå¤„ç†
func sequentialProcessing(nums []int) []int {
    results := make([]int, len(nums))
    
    for i, n := range nums {
        // é¡ºåºåº”ç”¨æ‰€æœ‰é˜¶æ®µ
        temp := n
        
        // ç¬¬ä¸€é˜¶æ®µ
        time.Sleep(10 * time.Millisecond)
        temp = temp * 2
        
        // ç¬¬äºŒé˜¶æ®µ
        time.Sleep(20 * time.Millisecond)
        temp = temp + 10
        
        // ç¬¬ä¸‰é˜¶æ®µ
        time.Sleep(15 * time.Millisecond)
        temp = temp * temp
        
        results[i] = temp
    }
    
    return results
}

// å¹¶è¡Œæµæ°´çº¿å¤„ç†
func pipelineProcessing(nums []int) []int {
    // åˆ›å»ºè¾“å…¥é€šé“
    in := make(chan int)
    
    // å¯åŠ¨goroutineå‘é€è¾“å…¥
    go func() {
        defer close(in)
        for _, n := range nums {
            in <- n
        }
    }()
    
    // æ„å»ºæµæ°´çº¿
    stage1Out := stage1(in)
    stage2Out := stage2(stage1Out)
    stage3Out := stage3(stage2Out)
    
    // æ”¶é›†ç»“æœ
    var results []int
    for n := range stage3Out {
        results = append(results, n)
    }
    
    return results
}

// æ‰©å±•çš„å¹¶è¡Œæµæ°´çº¿å¤„ç†
func parallelPipelineProcessing(nums []int, parallelism int) []int {
    // åˆ›å»ºè¾“å…¥é€šé“
    in := make(chan int)
    
    // å¯åŠ¨goroutineå‘é€è¾“å…¥
    go func() {
        defer close(in)
        for _, n := range nums {
            in <- n
        }
    }()
    
    // ç¬¬ä¸€é˜¶æ®µå¤šworker
    stage1OutChannels := make([]<-chan int, parallelism)
    for i := 0; i < parallelism; i++ {
        stage1OutChannels[i] = stage1(in)
    }
    
    // åˆå¹¶ç¬¬ä¸€é˜¶æ®µç»“æœ
    stage1Out := mergeChannels(stage1OutChannels)
    
    // ç¬¬äºŒé˜¶æ®µå¤šworker
    stage2OutChannels := make([]<-chan int, parallelism)
    for i := 0; i < parallelism; i++ {
        stage2OutChannels[i] = stage2(stage1Out)
    }
    
    // åˆå¹¶ç¬¬äºŒé˜¶æ®µç»“æœ
    stage2Out := mergeChannels(stage2OutChannels)
    
    // ç¬¬ä¸‰é˜¶æ®µå¤šworker
    stage3OutChannels := make([]<-chan int, parallelism)
    for i := 0; i < parallelism; i++ {
        stage3OutChannels[i] = stage3(stage2Out)
    }
    
    // åˆå¹¶ç¬¬ä¸‰é˜¶æ®µç»“æœ
    stage3Out := mergeChannels(stage3OutChannels)
    
    // æ”¶é›†ç»“æœ
    var results []int
    for n := range stage3Out {
        results = append(results, n)
    }
    
    return results
}

// åˆå¹¶å¤šä¸ªé€šé“çš„è¾…åŠ©å‡½æ•°
func mergeChannels(cs []<-chan int) <-chan int {
    out := make(chan int)
    var wg sync.WaitGroup
    
    // ä¸ºæ¯ä¸ªè¾“å…¥é€šé“å¯åŠ¨ä¸€ä¸ªgoroutine
    wg.Add(len(cs))
    for _, c := range cs {
        go func(ch <-chan int) {
            defer wg.Done()
            for n := range ch {
                out <- n
            }
        }(c)
    }
    
    // å½“æ‰€æœ‰è¾“å…¥é€šé“å…³é—­åï¼Œå…³é—­è¾“å‡ºé€šé“
    go func() {
        wg.Wait()
        close(out)
    }()
    
    return out
}

func main() {
    // å‡†å¤‡æ•°æ®
    nums := make([]int, 20)
    for i := range nums {
        nums[i] = i + 1
    }
    
    // æµ‹è¯•é¡ºåºå¤„ç†
    fmt.Println("å¼€å§‹é¡ºåºå¤„ç†æµ‹è¯•...")
    start := time.Now()
    results1 := sequentialProcessing(nums)
    seqTime := time.Since(start)
    fmt.Printf("é¡ºåºå¤„ç†ç”¨æ—¶: %v, ç»“æœæ•°é‡: %d\n", seqTime, len(results1))
    
    // æµ‹è¯•åŸºæœ¬æµæ°´çº¿
    fmt.Println("å¼€å§‹åŸºæœ¬æµæ°´çº¿æµ‹è¯•...")
    start = time.Now()
    results2 := pipelineProcessing(nums)
    pipeTime := time.Since(start)
    fmt.Printf("åŸºæœ¬æµæ°´çº¿ç”¨æ—¶: %v, ç»“æœæ•°é‡: %d\n", pipeTime, len(results2))
    
    // æµ‹è¯•å¹¶è¡Œæµæ°´çº¿
    fmt.Println("å¼€å§‹å¹¶è¡Œæµæ°´çº¿æµ‹è¯•...")
    start = time.Now()
    results3 := parallelPipelineProcessing(nums, 3)
    parPipeTime := time.Since(start)
    fmt.Printf("å¹¶è¡Œæµæ°´çº¿ç”¨æ—¶: %v, ç»“æœæ•°é‡: %d\n", parPipeTime, len(results3))
    
    fmt.Printf("åŸºæœ¬æµæ°´çº¿vsé¡ºåº: æå‡%.2få€\n", float64(seqTime)/float64(pipeTime))
    fmt.Printf("å¹¶è¡Œæµæ°´çº¿vsé¡ºåº: æå‡%.2få€\n", float64(seqTime)/float64(parPipeTime))
    fmt.Printf("å¹¶è¡Œæµæ°´çº¿vsåŸºæœ¬æµæ°´çº¿: æå‡%.2få€\n", float64(pipeTime)/float64(parPipeTime))
}
```

---

## 6. å®æˆ˜æ¡ˆä¾‹ï¼šé«˜æ€§èƒ½WebæœåŠ¡å™¨

### 6.1 æ„å»ºé«˜æ€§èƒ½HTTPæœåŠ¡å™¨
```go
package main

import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "runtime"
    "sync"
    "sync/atomic"
    "time"
)

// è¯·æ±‚è®¡æ•°å™¨
var (
    requestCount   int64
    successCount   int64
    errorCount     int64
    responseTimeNs int64
)

// æ¨¡æ‹Ÿæ•°æ®åº“è¿æ¥æ± 
type DBPool struct {
    conns chan struct{}
}

func NewDBPool(maxConns int) *DBPool {
    pool := &DBPool{
        conns: make(chan struct{}, maxConns),
    }
    
    // åˆå§‹åŒ–è¿æ¥æ± 
    for i := 0; i < maxConns; i++ {
        pool.conns <- struct{}{}
    }
    
    return pool
}

func (p *DBPool) Acquire() {
    <-p.conns
}

func (p *DBPool) Release() {
    p.conns <- struct{}{}
}

// æ¨¡æ‹Ÿæ•°æ®åº“æ“ä½œ
func queryDatabase() ([]map[string]interface{}, error) {
    // æ¨¡æ‹Ÿæ•°æ®åº“æ“ä½œè€—æ—¶
    time.Sleep(50 * time.Millisecond)
    
    // æ¨¡æ‹Ÿè¿”å›æ•°æ®
    results := make([]map[string]interface{}, 10)
    for i := 0; i < 10; i++ {
        results[i] = map[string]interface{}{
            "id":    i + 1,
            "name":  fmt.Sprintf("Item %d", i+1),
            "value": (i + 1) * 10,
        }
    }
    
    return results, nil
}

// å¤„ç†è¯·æ±‚
func handleRequest(w http.ResponseWriter, r *http.Request, dbPool *DBPool) {
    start := time.Now()
    
    // å¢åŠ è¯·æ±‚è®¡æ•°
    atomic.AddInt64(&requestCount, 1)
    
    // ä»è¿æ¥æ± è·å–è¿æ¥
    dbPool.Acquire()
    defer dbPool.Release()
    
    // æŸ¥è¯¢æ•°æ®
    results, err := queryDatabase()
    if err != nil {
        atomic.AddInt64(&errorCount, 1)
        http.Error(w, "Database error", http.StatusInternalServerError)
        return
    }
    
    // æ„é€ å“åº”
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]interface{}{
        "status":  "success",
        "results": results,
    })
    
    // å¢åŠ æˆåŠŸè®¡æ•°
    atomic.AddInt64(&successCount, 1)
    
    // è®°å½•å“åº”æ—¶é—´
    elapsed := time.Since(start).Nanoseconds()
    atomic.AddInt64(&responseTimeNs, elapsed)
}

// ç»Ÿè®¡æ•°æ®
func statsHandler(w http.ResponseWriter, r *http.Request) {
    rc := atomic.LoadInt64(&requestCount)
    sc := atomic.LoadInt64(&successCount)
    ec := atomic.LoadInt64(&errorCount)
    rt := atomic.LoadInt64(&responseTimeNs)
    
    var avgResponseTime float64
    if rc > 0 {
        avgResponseTime = float64(rt) / float64(rc) / 1000000 // è½¬æ¢ä¸ºæ¯«ç§’
    }
    
    stats := map[string]interface{}{
        "total_requests":      rc,
        "successful_requests": sc,
        "error_requests":      ec,
        "avg_response_time":   avgResponseTime,
        "goroutines":          runtime.NumGoroutine(),
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(stats)
}

func main() {
    // è®¾ç½®GOMAXPROCS
    numCPU := runtime.NumCPU()
    runtime.GOMAXPROCS(numCPU)
    fmt.Printf("æœåŠ¡å™¨å¯åŠ¨ï¼Œä½¿ç”¨ %d ä¸ªCPUæ ¸å¿ƒ\n", numCPU)
    
    // åˆ›å»ºæ•°æ®åº“è¿æ¥æ± 
    dbPool := NewDBPool(100)
    
    // è®¾ç½®HTTPå¤„ç†å‡½æ•°
    http.HandleFunc("/api/data", func(w http.ResponseWriter, r *http.Request) {
        handleRequest(w, r, dbPool)
    })
    
    http.HandleFunc("/stats", statsHandler)
    
    // å¯åŠ¨æœåŠ¡å™¨
    fmt.Println("æœåŠ¡å™¨ç›‘å¬åœ¨ http://localhost:8080")
    fmt.Println("è®¿é—® http://localhost:8080/api/data æµ‹è¯•API")
    fmt.Println("è®¿é—® http://localhost:8080/stats æŸ¥çœ‹ç»Ÿè®¡ä¿¡æ¯")
    
    if err := http.ListenAndServe(":8080", nil); err != nil {
        log.Fatal("Server error:", err)
    }
}
```

### 6.2 è´Ÿè½½æµ‹è¯•
ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤è¿›è¡Œè´Ÿè½½æµ‹è¯•ï¼š

```bash
# ä½¿ç”¨heyå·¥å…·è¿›è¡Œæµ‹è¯•
go install github.com/rakyll/hey@latest

# å‘é€1000ä¸ªè¯·æ±‚ï¼Œ50ä¸ªå¹¶å‘
hey -n 1000 -c 50 http://localhost:8080/api/data
```

---

## 7. å­¦ä¹ æ£€æŸ¥ç‚¹

- [ ] ç†è§£å¦‚ä½•ä½¿ç”¨pprofè¿›è¡Œæ€§èƒ½åˆ†æ
- [ ] èƒ½å¤Ÿè¯†åˆ«å¹¶å‘ç¨‹åºä¸­çš„é”ç«äº‰é—®é¢˜
- [ ] æŒæ¡å‡å°‘é€šé“æ“ä½œå¼€é”€çš„æŠ€æœ¯
- [ ] èƒ½å¤Ÿä¼˜åŒ–å·¥ä½œæ± å®ç°æé«˜æ€§èƒ½
- [ ] ç†è§£å¹¶åº”ç”¨å†…å­˜ä¼˜åŒ–æŠ€æœ¯
- [ ] æŒæ¡æ‰¹å¤„ç†å’Œæµæ°´çº¿å¹¶è¡Œçš„å®ç°æ–¹æ³•
- [ ] èƒ½å¤Ÿæ„å»ºå’Œä¼˜åŒ–é«˜æ€§èƒ½å¹¶å‘æœåŠ¡

---

å¹¶å‘æ€§èƒ½è°ƒä¼˜æ˜¯æ„å»ºé«˜æ€§èƒ½Goåº”ç”¨ç¨‹åºçš„å…³é”®ã€‚é€šè¿‡ç³»ç»Ÿåœ°åˆ†ææ€§èƒ½ç“¶é¢ˆï¼Œåº”ç”¨é€‚å½“çš„ä¼˜åŒ–æŠ€æœ¯ï¼Œå¯ä»¥æ˜¾è‘—æé«˜ç¨‹åºçš„ååé‡å’Œå“åº”é€Ÿåº¦ã€‚è®°ä½ï¼Œä¼˜åŒ–åº”è¯¥å»ºç«‹åœ¨æµ‹é‡çš„åŸºç¡€ä¸Šï¼Œè€Œä¸æ˜¯çŒœæµ‹ã€‚
