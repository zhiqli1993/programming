# Go语言关系型数据库编程

## 概述

关系型数据库是最常用的数据存储系统之一，Go语言通过`database/sql`包提供了与关系型数据库交互的标准接口。本文档将介绍在Go中连接和操作关系型数据库的基本方法，以MySQL和PostgreSQL为例，展示如何进行常见的数据库操作。

## database/sql包基础

`database/sql`是Go标准库提供的用于操作SQL数据库的包，它定义了一套与具体数据库实现无关的接口。

### 导入必要的包

```go
import (
    "database/sql"
    "fmt"
    "log"
    
    _ "github.com/go-sql-driver/mysql"     // MySQL驱动
    // 或
    // _ "github.com/lib/pq"                // PostgreSQL驱动
)
```

注意驱动包前面的下划线(`_`)，表示导入包但只执行其初始化函数，不直接使用其导出的标识符。

### 建立数据库连接

```go
// MySQL连接
func connectMySQL() (*sql.DB, error) {
    // 连接字符串格式：用户名:密码@tcp(主机:端口)/数据库名?参数=值
    dsn := "user:password@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&parseTime=True&loc=Local"
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        return nil, err
    }
    
    // 验证连接
    if err := db.Ping(); err != nil {
        return nil, err
    }
    
    return db, nil
}

// PostgreSQL连接
func connectPostgreSQL() (*sql.DB, error) {
    // 连接字符串格式
    connStr := "host=localhost port=5432 user=postgres password=password dbname=mydb sslmode=disable"
    db, err := sql.Open("postgres", connStr)
    if err != nil {
        return nil, err
    }
    
    // 验证连接
    if err := db.Ping(); err != nil {
        return nil, err
    }
    
    return db, nil
}
```

### 配置连接池

`sql.DB`对象实际上是一个数据库连接池，可以通过以下方式配置：

```go
func configureDB(db *sql.DB) {
    // 设置最大打开连接数
    db.SetMaxOpenConns(25)
    // 设置最大空闲连接数
    db.SetMaxIdleConns(5)
    // 设置连接最大生存时间
    db.SetConnMaxLifetime(5 * time.Minute)
    // Go 1.15+支持设置最大空闲时间
    // db.SetConnMaxIdleTime(1 * time.Minute)
}
```

## 基本数据库操作

### 查询单行数据

```go
func queryRow(db *sql.DB, id int) (string, error) {
    var name string
    
    // 查询单行
    row := db.QueryRow("SELECT name FROM users WHERE id = ?", id)
    
    // 将结果扫描到变量中
    err := row.Scan(&name)
    if err != nil {
        if err == sql.ErrNoRows {
            return "", fmt.Errorf("没有找到ID为%d的用户", id)
        }
        return "", err
    }
    
    return name, nil
}
```

### 查询多行数据

```go
// 用户结构体
type User struct {
    ID    int
    Name  string
    Email string
    Age   int
}

func queryUsers(db *sql.DB) ([]User, error) {
    // 执行查询
    rows, err := db.Query("SELECT id, name, email, age FROM users")
    if err != nil {
        return nil, err
    }
    defer rows.Close() // 重要：确保关闭rows
    
    var users []User
    
    // 遍历结果集
    for rows.Next() {
        var u User
        // 扫描当前行到结构体
        if err := rows.Scan(&u.ID, &u.Name, &u.Email, &u.Age); err != nil {
            return nil, err
        }
        users = append(users, u)
    }
    
    // 检查遍历过程中是否有错误
    if err := rows.Err(); err != nil {
        return nil, err
    }
    
    return users, nil
}
```

### 插入数据

```go
func insertUser(db *sql.DB, user User) (int64, error) {
    // 执行插入
    result, err := db.Exec(
        "INSERT INTO users (name, email, age) VALUES (?, ?, ?)",
        user.Name, user.Email, user.Age,
    )
    if err != nil {
        return 0, err
    }
    
    // 获取插入ID
    id, err := result.LastInsertId()
    if err != nil {
        return 0, err
    }
    
    return id, nil
}
```

### 更新数据

```go
func updateUser(db *sql.DB, user User) (int64, error) {
    // 执行更新
    result, err := db.Exec(
        "UPDATE users SET name = ?, email = ?, age = ? WHERE id = ?",
        user.Name, user.Email, user.Age, user.ID,
    )
    if err != nil {
        return 0, err
    }
    
    // 获取影响的行数
    rowsAffected, err := result.RowsAffected()
    if err != nil {
        return 0, err
    }
    
    return rowsAffected, nil
}
```

### 删除数据

```go
func deleteUser(db *sql.DB, id int) (int64, error) {
    // 执行删除
    result, err := db.Exec("DELETE FROM users WHERE id = ?", id)
    if err != nil {
        return 0, err
    }
    
    // 获取影响的行数
    rowsAffected, err := result.RowsAffected()
    if err != nil {
        return 0, err
    }
    
    return rowsAffected, nil
}
```

## 预处理语句

预处理语句可以提高性能并防止SQL注入攻击。

```go
func preparedInsert(db *sql.DB, users []User) error {
    // 准备语句
    stmt, err := db.Prepare("INSERT INTO users (name, email, age) VALUES (?, ?, ?)")
    if err != nil {
        return err
    }
    defer stmt.Close() // 重要：确保关闭语句
    
    // 多次执行语句
    for _, user := range users {
        _, err := stmt.Exec(user.Name, user.Email, user.Age)
        if err != nil {
            return err
        }
    }
    
    return nil
}
```

## 事务处理

事务确保一组操作要么全部成功，要么全部失败。

```go
func transferMoney(db *sql.DB, fromID, toID int, amount float64) error {
    // 开始事务
    tx, err := db.Begin()
    if err != nil {
        return err
    }
    
    // 使用defer和recover确保事务的一致性
    defer func() {
        if p := recover(); p != nil {
            tx.Rollback()
            panic(p) // 重新抛出panic
        }
    }()
    
    // 从账户1减款
    _, err = tx.Exec("UPDATE accounts SET balance = balance - ? WHERE id = ?", amount, fromID)
    if err != nil {
        tx.Rollback()
        return err
    }
    
    // 给账户2加款
    _, err = tx.Exec("UPDATE accounts SET balance = balance + ? WHERE id = ?", amount, toID)
    if err != nil {
        tx.Rollback()
        return err
    }
    
    // 提交事务
    return tx.Commit()
}
```

## 处理NULL值

数据库中的NULL值需要特殊处理。

```go
import "database/sql"

type User struct {
    ID        int
    Name      string
    Email     string
    Age       sql.NullInt64   // 可能为NULL的整数
    CreatedAt sql.NullTime    // 可能为NULL的时间
    Address   sql.NullString  // 可能为NULL的字符串
}

func queryUserWithNulls(db *sql.DB, id int) (*User, error) {
    user := &User{}
    
    err := db.QueryRow(
        "SELECT id, name, email, age, created_at, address FROM users WHERE id = ?", 
        id,
    ).Scan(
        &user.ID, 
        &user.Name, 
        &user.Email, 
        &user.Age, 
        &user.CreatedAt, 
        &user.Address,
    )
    
    if err != nil {
        if err == sql.ErrNoRows {
            return nil, fmt.Errorf("用户不存在")
        }
        return nil, err
    }
    
    return user, nil
}

// 使用NullString
func getAddress(user *User) string {
    if user.Address.Valid {
        return user.Address.String
    }
    return "地址未提供"
}
```

## 数据库迁移

数据库迁移工具可以帮助管理数据库结构的版本变更。Go生态系统中有多种迁移工具，例如：

1. **golang-migrate**
2. **goose**
3. **sql-migrate**

以下是使用golang-migrate的简单示例：

```go
import (
    "github.com/golang-migrate/migrate/v4"
    _ "github.com/golang-migrate/migrate/v4/database/mysql"
    _ "github.com/golang-migrate/migrate/v4/source/file"
)

func migrateDatabase(dbURL string) error {
    m, err := migrate.New(
        "file://./migrations", // 迁移文件路径
        dbURL,                 // 数据库URL
    )
    if err != nil {
        return err
    }
    
    if err := m.Up(); err != nil && err != migrate.ErrNoChange {
        return err
    }
    
    return nil
}
```

## 数据库驱动特定功能

### MySQL特定操作

```go
import (
    "database/sql"
    "github.com/go-sql-driver/mysql"
)

// 注册自定义配置
func configureMySQL() {
    mysql.SetLogger(logger) // 设置自定义日志器
    
    cfg := mysql.Config{
        User:                 "user",
        Passwd:               "password",
        Net:                  "tcp",
        Addr:                 "127.0.0.1:3306",
        DBName:               "test",
        AllowNativePasswords: true,
        ParseTime:            true,
        Loc:                  time.UTC,
    }
    
    db, err := sql.Open("mysql", cfg.FormatDSN())
    // ...
}

// 批量插入
func bulkInsertMySQL(db *sql.DB, users []User) error {
    // 构建批量插入语句
    valueStrings := make([]string, 0, len(users))
    valueArgs := make([]interface{}, 0, len(users)*3)
    
    for _, u := range users {
        valueStrings = append(valueStrings, "(?, ?, ?)")
        valueArgs = append(valueArgs, u.Name, u.Email, u.Age)
    }
    
    stmt := fmt.Sprintf("INSERT INTO users (name, email, age) VALUES %s",
        strings.Join(valueStrings, ","))
    
    // 执行批量插入
    _, err := db.Exec(stmt, valueArgs...)
    return err
}
```

### PostgreSQL特定操作

```go
import (
    "database/sql"
    "github.com/lib/pq"
)

// 处理PostgreSQL数组
func getPostgresArrays(db *sql.DB) {
    var tags []string
    
    // 查询数组类型
    err := db.QueryRow("SELECT tags FROM posts WHERE id = $1", 1).Scan(pq.Array(&tags))
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Println("Tags:", tags)
}

// 使用JSONB类型
type Post struct {
    ID      int
    Title   string
    Content string
    Meta    map[string]interface{}  // 对应JSONB列
}

func insertPostWithJSON(db *sql.DB, post Post) error {
    metaJSON, err := json.Marshal(post.Meta)
    if err != nil {
        return err
    }
    
    _, err = db.Exec(
        "INSERT INTO posts (title, content, meta) VALUES ($1, $2, $3)",
        post.Title, post.Content, metaJSON,
    )
    return err
}

// 监听通知
func listenForNotifications(db *sql.DB) {
    listener := pq.NewListener(
        "postgres://user:password@localhost/dbname?sslmode=disable",
        10*time.Second,
        time.Minute,
        func(ev pq.ListenerEventType, err error) {
            if err != nil {
                log.Println(err)
            }
        },
    )
    
    err := listener.Listen("channel_name")
    if err != nil {
        log.Fatal(err)
    }
    
    for {
        select {
        case n := <-listener.Notify:
            fmt.Println("收到通知:", n.Extra)
        case <-time.After(time.Minute):
            go func() {
                listener.Ping()
            }()
        }
    }
}
```

## 数据库性能优化

### 连接池优化

```go
func optimizeConnectionPool(db *sql.DB) {
    // 设置最大打开连接数（默认无限制）
    // 根据预期并发量和数据库性能来设置
    db.SetMaxOpenConns(100)
    
    // 设置最大空闲连接数（默认2）
    // 保持一定数量的空闲连接以避免频繁创建和销毁连接
    db.SetMaxIdleConns(20)
    
    // 设置连接最大生存时间（默认无限制）
    // 避免长时间不活跃的连接占用资源
    db.SetConnMaxLifetime(30 * time.Minute)
    
    // Go 1.15+支持设置空闲连接最大生存时间
    // 让空闲连接更快被释放
    db.SetConnMaxIdleTime(5 * time.Minute)
}
```

### 批量操作

```go
func batchQueries(db *sql.DB, ids []int) (map[int]User, error) {
    // 构建IN子句
    placeholders := make([]string, len(ids))
    args := make([]interface{}, len(ids))
    
    for i, id := range ids {
        placeholders[i] = "?"
        args[i] = id
    }
    
    query := fmt.Sprintf(
        "SELECT id, name, email, age FROM users WHERE id IN (%s)",
        strings.Join(placeholders, ","),
    )
    
    rows, err := db.Query(query, args...)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    // 将结果映射到map
    result := make(map[int]User)
    for rows.Next() {
        var u User
        if err := rows.Scan(&u.ID, &u.Name, &u.Email, &u.Age); err != nil {
            return nil, err
        }
        result[u.ID] = u
    }
    
    return result, rows.Err()
}
```

### 使用上下文控制查询超时

```go
func queryWithTimeout(db *sql.DB, id int) (*User, error) {
    // 创建带1秒超时的上下文
    ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
    defer cancel()
    
    var user User
    
    // 使用上下文执行查询
    err := db.QueryRowContext(ctx, 
        "SELECT id, name, email, age FROM users WHERE id = ?", id,
    ).Scan(&user.ID, &user.Name, &user.Email, &user.Age)
    
    if err != nil {
        return nil, err
    }
    
    return &user, nil
}
```

## 实际应用示例

### 用户管理系统

```go
// 用户模型
type User struct {
    ID        int
    Name      string
    Email     string
    Password  string
    CreatedAt time.Time
    UpdatedAt time.Time
}

// 用户存储接口
type UserRepository interface {
    Create(user *User) error
    GetByID(id int) (*User, error)
    GetByEmail(email string) (*User, error)
    Update(user *User) error
    Delete(id int) error
    List(limit, offset int) ([]User, error)
}

// 数据库实现
type SQLUserRepository struct {
    db *sql.DB
}

func NewSQLUserRepository(db *sql.DB) *SQLUserRepository {
    return &SQLUserRepository{db: db}
}

func (r *SQLUserRepository) Create(user *User) error {
    now := time.Now()
    user.CreatedAt = now
    user.UpdatedAt = now
    
    query := `
        INSERT INTO users (name, email, password, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?)
    `
    
    result, err := r.db.Exec(query,
        user.Name,
        user.Email,
        user.Password,
        user.CreatedAt,
        user.UpdatedAt,
    )
    if err != nil {
        return err
    }
    
    id, err := result.LastInsertId()
    if err != nil {
        return err
    }
    
    user.ID = int(id)
    return nil
}

func (r *SQLUserRepository) GetByID(id int) (*User, error) {
    user := &User{}
    
    query := `
        SELECT id, name, email, password, created_at, updated_at
        FROM users
        WHERE id = ?
    `
    
    err := r.db.QueryRow(query, id).Scan(
        &user.ID,
        &user.Name,
        &user.Email,
        &user.Password,
        &user.CreatedAt,
        &user.UpdatedAt,
    )
    
    if err != nil {
        if err == sql.ErrNoRows {
            return nil, fmt.Errorf("用户ID %d 不存在", id)
        }
        return nil, err
    }
    
    return user, nil
}

// 其他方法实现...
```

### 博客系统示例

```go
// 文章模型
type Article struct {
    ID        int
    Title     string
    Content   string
    AuthorID  int
    Status    string
    Tags      []string
    CreatedAt time.Time
    UpdatedAt time.Time
}

// 事务示例：发布文章并更新用户文章计数
func PublishArticle(db *sql.DB, article *Article) error {
    tx, err := db.Begin()
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    // 插入文章
    result, err := tx.Exec(`
        INSERT INTO articles (title, content, author_id, status, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?)
    `,
        article.Title,
        article.Content,
        article.AuthorID,
        "published",
        time.Now(),
        time.Now(),
    )
    if err != nil {
        return err
    }
    
    articleID, err := result.LastInsertId()
    if err != nil {
        return err
    }
    
    // 更新用户文章计数
    _, err = tx.Exec(`
        UPDATE user_stats 
        SET article_count = article_count + 1 
        WHERE user_id = ?
    `,
        article.AuthorID,
    )
    if err != nil {
        return err
    }
    
    // 插入标签
    for _, tag := range article.Tags {
        _, err = tx.Exec(`
            INSERT INTO article_tags (article_id, tag)
            VALUES (?, ?)
        `,
            articleID,
            tag,
        )
        if err != nil {
            return err
        }
    }
    
    return tx.Commit()
}
```

## 最佳实践

### 数据访问层设计

遵循关注点分离原则，将数据库操作封装在专门的数据访问层中：

1. **仓储模式(Repository Pattern)**：定义接口抽象数据访问操作
2. **DAO(Data Access Object)**：实现具体的数据库操作
3. **实体/模型**：与数据库表对应的结构体

```go
// 定义仓储接口
type Repository interface {
    Find(id int) (Entity, error)
    FindAll() ([]Entity, error)
    Create(entity Entity) error
    Update(entity Entity) error
    Delete(id int) error
}

// 实现MySQL版本
type MySQLRepository struct {
    db *sql.DB
}

func (r *MySQLRepository) Find(id int) (Entity, error) {
    // 实现...
}

// 实现PostgreSQL版本
type PostgresRepository struct {
    db *sql.DB
}

func (r *PostgresRepository) Find(id int) (Entity, error) {
    // 实现...
}
```

### 安全性最佳实践

1. **始终使用参数化查询**：防止SQL注入攻击
2. **不要拼接SQL字符串**：除非万不得已
3. **谨慎处理错误**：不要暴露敏感的数据库错误信息
4. **使用最小权限原则**：为应用程序使用的数据库账户仅分配必要的权限
5. **避免在SQL中使用用户输入**：尤其是表名、列名等结构部分

```go
// 不安全的写法 - 容易受到SQL注入攻击
func unsafeQuery(db *sql.DB, username string) {
    query := "SELECT * FROM users WHERE username = '" + username + "'"
    // 危险!
    db.Query(query)
}

// 安全的写法 - 使用参数化查询
func safeQuery(db *sql.DB, username string) {
    db.Query("SELECT * FROM users WHERE username = ?", username)
}
```

### 错误处理最佳实践

1. **区分类型错误**：尤其是`sql.ErrNoRows`表示未找到记录
2. **不吞没错误**：始终处理或传播错误
3. **使用自定义错误**：提供更有意义的错误信息
4. **在合适的级别处理错误**：数据访问层处理数据库错误，业务层处理业务逻辑错误

```go
// 自定义错误类型
type NotFoundError struct {
    Entity string
    ID     interface{}
}

func (e *NotFoundError) Error() string {
    return fmt.Sprintf("未找到%s(ID: %v)", e.Entity, e.ID)
}

// 使用自定义错误
func (r *Repository) FindUser(id int) (*User, error) {
    user := &User{}
    err := r.db.QueryRow("SELECT * FROM users WHERE id = ?", id).
        Scan(&user.ID, &user.Name, /* ... */)
    
    if err != nil {
        if err == sql.ErrNoRows {
            return nil, &NotFoundError{Entity: "用户", ID: id}
        }
        return nil, fmt.Errorf("查询用户错误: %w", err)
    }
    
    return user, nil
}
```

## 总结

本文档介绍了Go语言中关系型数据库编程的核心概念和实践，包括：

1. **database/sql包基础**：连接数据库、配置连接池
2. **基本操作**：查询、插入、更新、删除
3. **高级特性**：预处理语句、事务、NULL值处理
4. **数据库迁移**：管理数据库结构变更
5. **特定数据库操作**：MySQL和PostgreSQL的特有功能
6. **性能优化**：连接池、批量操作、超时控制
7. **实际应用示例**：用户管理系统、博客系统
8. **最佳实践**：数据访问层设计、安全性、错误处理

掌握这些知识点，可以帮助开发者使用Go语言高效、安全地与关系型数据库交互，构建稳健的数据密集型应用。

## 推荐阅读

- [Go数据库/SQL教程](http://go-database-sql.org/)
- [Go MySQL驱动文档](https://github.com/go-sql-driver/mysql)
- [Go Postgres驱动文档](https://github.com/lib/pq)
- [SQL数据库迁移工具](https://github.com/golang-migrate/migrate)
- [Effective SQL: 数据库性能优化指南](https://www.amazon.com/Effective-SQL-Specific-Software-Development/dp/0134578899)
