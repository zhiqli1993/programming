# 二叉树实现

## 概述

二叉树是一种重要的非线性数据结构，它在计算机科学中有着广泛的应用，如二叉搜索树、堆、Huffman编码树等。本文档将介绍Go语言中二叉树的常见实现方式、基本操作和应用场景。

## 基本概念

二叉树是一种树形结构，其中每个节点最多有两个子节点，通常称为"左子节点"和"右子节点"。

### 二叉树的类型

1. **完全二叉树**：除最后一层外，其他层都填满节点，且最后一层节点都靠左排列
2. **满二叉树**：除叶节点外，所有节点都有左右两个子节点
3. **平衡二叉树**：任何节点的左右子树高度差不超过1
4. **二叉搜索树**：左子树的所有节点值小于根节点，右子树的所有节点值大于根节点

## 二叉树的基本实现

### 节点定义

```go
// TreeNode 二叉树节点
type TreeNode struct {
    Val   int         // 节点值
    Left  *TreeNode   // 左子节点
    Right *TreeNode   // 右子节点
}

// NewTreeNode 创建新节点
func NewTreeNode(val int) *TreeNode {
    return &TreeNode{
        Val:   val,
        Left:  nil,
        Right: nil,
    }
}
```

### 二叉树的创建

```go
// 手动创建二叉树
func createSampleTree() *TreeNode {
    /*
          1
         / \
        2   3
       / \   \
      4   5   6
    */
    root := NewTreeNode(1)
    root.Left = NewTreeNode(2)
    root.Right = NewTreeNode(3)
    root.Left.Left = NewTreeNode(4)
    root.Left.Right = NewTreeNode(5)
    root.Right.Right = NewTreeNode(6)
    
    return root
}

// 从数组创建完全二叉树
func createFromArray(arr []int) *TreeNode {
    if len(arr) == 0 {
        return nil
    }
    
    root := NewTreeNode(arr[0])
    queue := []*TreeNode{root}
    i := 1
    
    for i < len(arr) {
        node := queue[0]
        queue = queue[1:]
        
        // 添加左子节点
        if i < len(arr) && arr[i] != -1 { // 使用-1表示null
            node.Left = NewTreeNode(arr[i])
            queue = append(queue, node.Left)
        }
        i++
        
        // 添加右子节点
        if i < len(arr) && arr[i] != -1 {
            node.Right = NewTreeNode(arr[i])
            queue = append(queue, node.Right)
        }
        i++
    }
    
    return root
}
```

## 二叉树的遍历

### 前序遍历 (根-左-右)

```go
// 递归实现
func preorderTraversal(root *TreeNode) []int {
    var result []int
    preorderHelper(root, &result)
    return result
}

func preorderHelper(node *TreeNode, result *[]int) {
    if node == nil {
        return
    }
    
    // 先访问根节点
    *result = append(*result, node.Val)
    // 然后遍历左子树
    preorderHelper(node.Left, result)
    // 最后遍历右子树
    preorderHelper(node.Right, result)
}

// 迭代实现
func preorderTraversalIterative(root *TreeNode) []int {
    if root == nil {
        return nil
    }
    
    var result []int
    stack := []*TreeNode{root}
    
    for len(stack) > 0 {
        // 弹出栈顶节点
        node := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        
        // 访问当前节点
        result = append(result, node.Val)
        
        // 先将右子节点入栈，后将左子节点入栈
        // 这样出栈时会先处理左子节点
        if node.Right != nil {
            stack = append(stack, node.Right)
        }
        if node.Left != nil {
            stack = append(stack, node.Left)
        }
    }
    
    return result
}
```

### 中序遍历 (左-根-右)

```go
// 递归实现
func inorderTraversal(root *TreeNode) []int {
    var result []int
    inorderHelper(root, &result)
    return result
}

func inorderHelper(node *TreeNode, result *[]int) {
    if node == nil {
        return
    }
    
    // 先遍历左子树
    inorderHelper(node.Left, result)
    // 然后访问根节点
    *result = append(*result, node.Val)
    // 最后遍历右子树
    inorderHelper(node.Right, result)
}

// 迭代实现
func inorderTraversalIterative(root *TreeNode) []int {
    var result []int
    var stack []*TreeNode
    curr := root
    
    for curr != nil || len(stack) > 0 {
        // 将所有左子节点入栈
        for curr != nil {
            stack = append(stack, curr)
            curr = curr.Left
        }
        
        // 弹出栈顶节点并访问
        curr = stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        result = append(result, curr.Val)
        
        // 处理右子节点
        curr = curr.Right
    }
    
    return result
}
```

### 后序遍历 (左-右-根)

```go
// 递归实现
func postorderTraversal(root *TreeNode) []int {
    var result []int
    postorderHelper(root, &result)
    return result
}

func postorderHelper(node *TreeNode, result *[]int) {
    if node == nil {
        return
    }
    
    // 先遍历左子树
    postorderHelper(node.Left, result)
    // 然后遍历右子树
    postorderHelper(node.Right, result)
    // 最后访问根节点
    *result = append(*result, node.Val)
}

// 迭代实现
func postorderTraversalIterative(root *TreeNode) []int {
    if root == nil {
        return nil
    }
    
    var result []int
    stack := []*TreeNode{root}
    
    for len(stack) > 0 {
        // 弹出栈顶节点
        node := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        
        // 将当前节点值插入结果的头部
        // 这样相当于逆序添加，最后结果就是后序遍历
        result = append([]int{node.Val}, result...)
        
        // 先将左子节点入栈，再将右子节点入栈
        if node.Left != nil {
            stack = append(stack, node.Left)
        }
        if node.Right != nil {
            stack = append(stack, node.Right)
        }
    }
    
    return result
}
```

### 层序遍历 (按层)

```go
func levelOrderTraversal(root *TreeNode) [][]int {
    if root == nil {
        return nil
    }
    
    var result [][]int
    queue := []*TreeNode{root}
    
    for len(queue) > 0 {
        levelSize := len(queue)
        var currentLevel []int
        
        // 处理当前层的所有节点
        for i := 0; i < levelSize; i++ {
            // 出队
            node := queue[0]
            queue = queue[1:]
            
            // 将节点值添加到当前层
            currentLevel = append(currentLevel, node.Val)
            
            // 将子节点入队
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
        
        // 将当前层添加到结果
        result = append(result, currentLevel)
    }
    
    return result
}
```

## 二叉搜索树

二叉搜索树(BST)是一种特殊的二叉树，其中每个节点的左子树中的所有节点值都小于该节点的值，右子树中的所有节点值都大于该节点的值。

### 二叉搜索树实现

```go
// BST 二叉搜索树
type BST struct {
    Root *TreeNode
}

// NewBST 创建新的二叉搜索树
func NewBST() *BST {
    return &BST{Root: nil}
}

// Insert 插入值
func (bst *BST) Insert(val int) {
    if bst.Root == nil {
        bst.Root = NewTreeNode(val)
        return
    }
    
    bst.insertRecursive(bst.Root, val)
}

// 递归插入
func (bst *BST) insertRecursive(node *TreeNode, val int) {
    if val < node.Val {
        if node.Left == nil {
            node.Left = NewTreeNode(val)
        } else {
            bst.insertRecursive(node.Left, val)
        }
    } else {
        if node.Right == nil {
            node.Right = NewTreeNode(val)
        } else {
            bst.insertRecursive(node.Right, val)
        }
    }
}

// Search 搜索值
func (bst *BST) Search(val int) bool {
    return bst.searchRecursive(bst.Root, val)
}

// 递归搜索
func (bst *BST) searchRecursive(node *TreeNode, val int) bool {
    if node == nil {
        return false
    }
    
    if val == node.Val {
        return true
    }
    
    if val < node.Val {
        return bst.searchRecursive(node.Left, val)
    }
    
    return bst.searchRecursive(node.Right, val)
}

// Delete 删除值
func (bst *BST) Delete(val int) {
    bst.Root = bst.deleteRecursive(bst.Root, val)
}

// 递归删除
func (bst *BST) deleteRecursive(node *TreeNode, val int) *TreeNode {
    if node == nil {
        return nil
    }
    
    // 找到要删除的节点
    if val < node.Val {
        node.Left = bst.deleteRecursive(node.Left, val)
    } else if val > node.Val {
        node.Right = bst.deleteRecursive(node.Right, val)
    } else {
        // 情况1: 叶子节点
        if node.Left == nil && node.Right == nil {
            return nil
        }
        
        // 情况2: 只有一个子节点
        if node.Left == nil {
            return node.Right
        }
        if node.Right == nil {
            return node.Left
        }
        
        // 情况3: 有两个子节点
        // 找到右子树中的最小值
        minValue := bst.findMin(node.Right)
        // 用该最小值替换当前节点
        node.Val = minValue
        // 删除右子树中的最小值节点
        node.Right = bst.deleteRecursive(node.Right, minValue)
    }
    
    return node
}

// 查找最小值
func (bst *BST) findMin(node *TreeNode) int {
    current := node
    for current.Left != nil {
        current = current.Left
    }
    return current.Val
}
```

## 平衡二叉树 (AVL树)

AVL树是一种自平衡二叉搜索树，任何节点的左右子树高度差不超过1。

### AVL树实现

```go
// AVLNode AVL树节点
type AVLNode struct {
    Val    int
    Height int
    Left   *AVLNode
    Right  *AVLNode
}

// NewAVLNode 创建新的AVL节点
func NewAVLNode(val int) *AVLNode {
    return &AVLNode{
        Val:    val,
        Height: 1,
        Left:   nil,
        Right:  nil,
    }
}

// AVLTree 平衡二叉树
type AVLTree struct {
    Root *AVLNode
}

// NewAVLTree 创建新的AVL树
func NewAVLTree() *AVLTree {
    return &AVLTree{Root: nil}
}

// 获取节点高度
func getHeight(node *AVLNode) int {
    if node == nil {
        return 0
    }
    return node.Height
}

// 获取平衡因子
func getBalanceFactor(node *AVLNode) int {
    if node == nil {
        return 0
    }
    return getHeight(node.Left) - getHeight(node.Right)
}

// 更新节点高度
func updateHeight(node *AVLNode) {
    leftHeight := getHeight(node.Left)
    rightHeight := getHeight(node.Right)
    
    if leftHeight > rightHeight {
        node.Height = leftHeight + 1
    } else {
        node.Height = rightHeight + 1
    }
}

// 右旋转
func rightRotate(y *AVLNode) *AVLNode {
    x := y.Left
    T2 := x.Right
    
    // 旋转
    x.Right = y
    y.Left = T2
    
    // 更新高度
    updateHeight(y)
    updateHeight(x)
    
    return x
}

// 左旋转
func leftRotate(x *AVLNode) *AVLNode {
    y := x.Right
    T2 := y.Left
    
    // 旋转
    y.Left = x
    x.Right = T2
    
    // 更新高度
    updateHeight(x)
    updateHeight(y)
    
    return y
}

// Insert 插入节点
func (avl *AVLTree) Insert(val int) {
    avl.Root = avl.insertRecursive(avl.Root, val)
}

// 递归插入
func (avl *AVLTree) insertRecursive(node *AVLNode, val int) *AVLNode {
    // 标准BST插入
    if node == nil {
        return NewAVLNode(val)
    }
    
    if val < node.Val {
        node.Left = avl.insertRecursive(node.Left, val)
    } else if val > node.Val {
        node.Right = avl.insertRecursive(node.Right, val)
    } else {
        // 重复值不插入
        return node
    }
    
    // 更新高度
    updateHeight(node)
    
    // 获取平衡因子
    balance := getBalanceFactor(node)
    
    // 平衡调整
    // 左左情况
    if balance > 1 && val < node.Left.Val {
        return rightRotate(node)
    }
    
    // 右右情况
    if balance < -1 && val > node.Right.Val {
        return leftRotate(node)
    }
    
    // 左右情况
    if balance > 1 && val > node.Left.Val {
        node.Left = leftRotate(node.Left)
        return rightRotate(node)
    }
    
    // 右左情况
    if balance < -1 && val < node.Right.Val {
        node.Right = rightRotate(node.Right)
        return leftRotate(node)
    }
    
    return node
}
```

## 树的常见操作与算法

### 计算树的高度

```go
func treeHeight(root *TreeNode) int {
    if root == nil {
        return 0
    }
    
    leftHeight := treeHeight(root.Left)
    rightHeight := treeHeight(root.Right)
    
    if leftHeight > rightHeight {
        return leftHeight + 1
    }
    return rightHeight + 1
}
```

### 判断是否为平衡二叉树

```go
func isBalanced(root *TreeNode) bool {
    if root == nil {
        return true
    }
    
    leftHeight := treeHeight(root.Left)
    rightHeight := treeHeight(root.Right)
    
    // 高度差不超过1，且左右子树都是平衡的
    return abs(leftHeight-rightHeight) <= 1 && isBalanced(root.Left) && isBalanced(root.Right)
}

func abs(n int) int {
    if n < 0 {
        return -n
    }
    return n
}
```

### 判断是否为二叉搜索树

```go
func isValidBST(root *TreeNode) bool {
    return isValidBSTHelper(root, nil, nil)
}

func isValidBSTHelper(node *TreeNode, min, max *int) bool {
    if node == nil {
        return true
    }
    
    // 检查节点值是否在有效范围内
    if min != nil && node.Val <= *min {
        return false
    }
    if max != nil && node.Val >= *max {
        return false
    }
    
    // 递归检查左右子树
    return isValidBSTHelper(node.Left, min, &node.Val) && isValidBSTHelper(node.Right, &node.Val, max)
}
```

### 最低公共祖先

```go
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    if root == nil || root == p || root == q {
        return root
    }
    
    left := lowestCommonAncestor(root.Left, p, q)
    right := lowestCommonAncestor(root.Right, p, q)
    
    if left != nil && right != nil {
        return root
    }
    if left != nil {
        return left
    }
    return right
}
```

### 路径总和

```go
func hasPathSum(root *TreeNode, targetSum int) bool {
    if root == nil {
        return false
    }
    
    // 减去当前节点值
    targetSum -= root.Val
    
    // 如果是叶节点，检查剩余和是否为0
    if root.Left == nil && root.Right == nil {
        return targetSum == 0
    }
    
    // 递归检查左右子树
    return hasPathSum(root.Left, targetSum) || hasPathSum(root.Right, targetSum)
}
```

## 二叉树的应用

### 表达式树

表达式树是二叉树的一种应用，用于表示算术表达式。

```go
// ExprNode 表达式节点
type ExprNode struct {
    Value    string
    Left     *ExprNode
    Right    *ExprNode
    IsOperator bool
}

// 计算表达式树
func evaluateExprTree(root *ExprNode) float64 {
    if root == nil {
        return 0
    }
    
    // 叶子节点是操作数
    if !root.IsOperator {
        val, _ := strconv.ParseFloat(root.Value, 64)
        return val
    }
    
    // 递归计算左右子树
    leftVal := evaluateExprTree(root.Left)
    rightVal := evaluateExprTree(root.Right)
    
    // 根据运算符计算结果
    switch root.Value {
    case "+":
        return leftVal + rightVal
    case "-":
        return leftVal - rightVal
    case "*":
        return leftVal * rightVal
    case "/":
        if rightVal == 0 {
            panic("除数不能为零")
        }
        return leftVal / rightVal
    }
    
    return 0
}
```

### Huffman编码树

Huffman编码是一种前缀编码算法，用于数据压缩。

```go
// HuffmanNode Huffman树节点
type HuffmanNode struct {
    Char  rune
    Freq  int
    Left  *HuffmanNode
    Right *HuffmanNode
}

// 生成Huffman树
func buildHuffmanTree(text string) *HuffmanNode {
    if text == "" {
        return nil
    }
    
    // 统计字符频率
    freqMap := make(map[rune]int)
    for _, char := range text {
        freqMap[char]++
    }
    
    // 创建优先队列
    pq := make([]*HuffmanNode, 0)
    for char, freq := range freqMap {
        pq = append(pq, &HuffmanNode{Char: char, Freq: freq})
    }
    
    // 排序优先队列
    sort.Slice(pq, func(i, j int) bool {
        return pq[i].Freq < pq[j].Freq
    })
    
    // 构建Huffman树
    for len(pq) > 1 {
        // 取出两个频率最小的节点
        left := pq[0]
        right := pq[1]
        pq = pq[2:]
        
        // 创建新节点
        newNode := &HuffmanNode{
            Freq:  left.Freq + right.Freq,
            Left:  left,
            Right: right,
        }
        
        // 插入新节点到合适位置
        inserted := false
        for i := 0; i < len(pq); i++ {
            if newNode.Freq < pq[i].Freq {
                pq = append(pq[:i], append([]*HuffmanNode{newNode}, pq[i:]...)...)
                inserted = true
                break
            }
        }
        if !inserted {
            pq = append(pq, newNode)
        }
    }
    
    // 返回树的根节点
    if len(pq) > 0 {
        return pq[0]
    }
    return nil
}

// 生成编码表
func generateHuffmanCodes(root *HuffmanNode) map[rune]string {
    codes := make(map[rune]string)
    generateCodesRecursive(root, "", codes)
    return codes
}

func generateCodesRecursive(node *HuffmanNode, code string, codes map[rune]string) {
    if node == nil {
        return
    }
    
    // 叶子节点
    if node.Left == nil && node.Right == nil {
        codes[node.Char] = code
        return
    }
    
    // 递归生成左右子树的编码
    generateCodesRecursive(node.Left, code+"0", codes)
    generateCodesRecursive(node.Right, code+"1", codes)
}
```

## 总结

二叉树是一种灵活而强大的数据结构，在Go语言中可以通过结构体和指针轻松实现。本文档介绍了二叉树的基本实现、常见操作和应用场景，包括：

1. **基本实现**：节点定义、树的创建
2. **树的遍历**：前序、中序、后序、层序遍历
3. **二叉搜索树**：BST的实现及操作
4. **平衡二叉树**：AVL树的实现
5. **常见算法**：计算高度、判断平衡性、查找公共祖先等
6. **应用实例**：表达式树、Huffman编码树

掌握二叉树的实现和操作，对于提高算法设计能力和解决复杂问题有着重要意义。在实际应用中，二叉树经常用于搜索、排序、编码、路径规划等多种场景。

## 推荐阅读

- [Introduction to Algorithms](https://mitpress.mit.edu/books/introduction-algorithms-third-edition)
- [Go数据结构与算法](https://github.com/emirpasic/gods)
- [LeetCode Tree Problems](https://leetcode.com/tag/tree/)
- [平衡树原理与实现](https://github.com/Workiva/go-datastructures)
