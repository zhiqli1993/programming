# Go语言链表实现

## 概述

链表是一种基础的线性数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的引用。本文档将介绍Go语言中链表的实现、常见操作以及使用场景。

## 单向链表

单向链表是最基本的链表类型，每个节点只有一个指向下一个节点的引用。

### 基本结构

```go
package linkedlist

// Node 表示链表中的节点
type Node struct {
    Value interface{} // 节点存储的值
    Next  *Node       // 指向下一个节点的指针
}

// LinkedList 表示单向链表
type LinkedList struct {
    Head *Node // 链表头节点
    Tail *Node // 链表尾节点
    Size int   // 链表中节点的数量
}

// New 创建并返回一个新的空链表
func New() *LinkedList {
    return &LinkedList{}
}
```

### 基本操作

#### 添加元素

```go
// Append 在链表末尾添加节点
func (l *LinkedList) Append(value interface{}) {
    newNode := &Node{Value: value}
    
    // 如果链表为空，设置头节点
    if l.Head == nil {
        l.Head = newNode
        l.Tail = newNode
    } else {
        // 将新节点添加到尾部
        l.Tail.Next = newNode
        l.Tail = newNode
    }
    
    l.Size++
}

// Prepend 在链表头部添加节点
func (l *LinkedList) Prepend(value interface{}) {
    newNode := &Node{Value: value, Next: l.Head}
    
    // 更新头节点
    l.Head = newNode
    
    // 如果这是第一个节点，同时更新尾节点
    if l.Tail == nil {
        l.Tail = newNode
    }
    
    l.Size++
}

// InsertAt 在指定位置插入节点
func (l *LinkedList) InsertAt(value interface{}, position int) error {
    // 检查位置是否有效
    if position < 0 || position > l.Size {
        return fmt.Errorf("位置超出范围: %d, 有效范围: 0-%d", position, l.Size)
    }
    
    // 在头部插入
    if position == 0 {
        l.Prepend(value)
        return nil
    }
    
    // 在尾部插入
    if position == l.Size {
        l.Append(value)
        return nil
    }
    
    // 在中间位置插入
    current := l.Head
    for i := 0; i < position-1; i++ {
        current = current.Next
    }
    
    newNode := &Node{Value: value, Next: current.Next}
    current.Next = newNode
    l.Size++
    
    return nil
}
```

#### 删除元素

```go
// RemoveAt 删除指定位置的节点
func (l *LinkedList) RemoveAt(position int) (interface{}, error) {
    // 检查链表是否为空
    if l.Size == 0 {
        return nil, fmt.Errorf("链表为空")
    }
    
    // 检查位置是否有效
    if position < 0 || position >= l.Size {
        return nil, fmt.Errorf("位置超出范围: %d, 有效范围: 0-%d", position, l.Size-1)
    }
    
    var removedNode *Node
    
    // 删除头节点
    if position == 0 {
        removedNode = l.Head
        l.Head = l.Head.Next
        
        // 如果链表变为空，更新尾节点
        if l.Head == nil {
            l.Tail = nil
        }
    } else {
        // 找到要删除节点的前一个节点
        current := l.Head
        for i := 0; i < position-1; i++ {
            current = current.Next
        }
        
        // 保存要删除的节点
        removedNode = current.Next
        
        // 更新链接
        current.Next = removedNode.Next
        
        // 如果删除的是尾节点，更新尾节点引用
        if position == l.Size-1 {
            l.Tail = current
        }
    }
    
    // 清除被删除节点的引用，帮助垃圾回收
    removedNode.Next = nil
    
    l.Size--
    return removedNode.Value, nil
}

// Remove 删除链表中第一个值等于给定值的节点
func (l *LinkedList) Remove(value interface{}) bool {
    // 检查链表是否为空
    if l.Size == 0 {
        return false
    }
    
    // 如果头节点是要删除的节点
    if reflect.DeepEqual(l.Head.Value, value) {
        l.Head = l.Head.Next
        
        // 如果链表变为空，更新尾节点
        if l.Head == nil {
            l.Tail = nil
        }
        
        l.Size--
        return true
    }
    
    // 查找要删除节点的前一个节点
    current := l.Head
    for current.Next != nil && !reflect.DeepEqual(current.Next.Value, value) {
        current = current.Next
    }
    
    // 如果找到了要删除的节点
    if current.Next != nil {
        nodeToRemove := current.Next
        current.Next = nodeToRemove.Next
        
        // 如果删除的是尾节点，更新尾节点引用
        if nodeToRemove == l.Tail {
            l.Tail = current
        }
        
        // 清除被删除节点的引用，帮助垃圾回收
        nodeToRemove.Next = nil
        
        l.Size--
        return true
    }
    
    return false
}
```

#### 查找元素

```go
// IndexOf 返回值等于给定值的第一个节点的位置，如果不存在则返回-1
func (l *LinkedList) IndexOf(value interface{}) int {
    current := l.Head
    position := 0
    
    for current != nil {
        if reflect.DeepEqual(current.Value, value) {
            return position
        }
        current = current.Next
        position++
    }
    
    return -1
}

// Contains 检查链表是否包含给定值
func (l *LinkedList) Contains(value interface{}) bool {
    return l.IndexOf(value) != -1
}

// Get 获取指定位置的节点值
func (l *LinkedList) Get(position int) (interface{}, error) {
    // 检查位置是否有效
    if position < 0 || position >= l.Size {
        return nil, fmt.Errorf("位置超出范围: %d, 有效范围: 0-%d", position, l.Size-1)
    }
    
    current := l.Head
    for i := 0; i < position; i++ {
        current = current.Next
    }
    
    return current.Value, nil
}
```

#### 工具方法

```go
// Clear 清空链表
func (l *LinkedList) Clear() {
    l.Head = nil
    l.Tail = nil
    l.Size = 0
}

// IsEmpty 检查链表是否为空
func (l *LinkedList) IsEmpty() bool {
    return l.Size == 0
}

// Length 返回链表的长度
func (l *LinkedList) Length() int {
    return l.Size
}

// String 返回链表的字符串表示
func (l *LinkedList) String() string {
    if l.IsEmpty() {
        return "[]"
    }
    
    var builder strings.Builder
    builder.WriteString("[")
    
    current := l.Head
    for current != nil {
        builder.WriteString(fmt.Sprintf("%v", current.Value))
        
        if current.Next != nil {
            builder.WriteString(" -> ")
        }
        
        current = current.Next
    }
    
    builder.WriteString("]")
    return builder.String()
}
```

#### 迭代器方法

```go
// ForEach 对链表中的每个元素执行给定函数
func (l *LinkedList) ForEach(fn func(value interface{}, index int) bool) {
    current := l.Head
    index := 0
    
    for current != nil {
        if !fn(current.Value, index) {
            break
        }
        current = current.Next
        index++
    }
}

// ToArray 将链表转换为数组
func (l *LinkedList) ToArray() []interface{} {
    array := make([]interface{}, l.Size)
    
    current := l.Head
    index := 0
    
    for current != nil {
        array[index] = current.Value
        current = current.Next
        index++
    }
    
    return array
}
```

### 使用示例

```go
package main

import (
    "fmt"
    "linkedlist"
)

func main() {
    list := linkedlist.New()
    
    // 添加元素
    list.Append(10)
    list.Append(20)
    list.Append(30)
    list.Prepend(5)
    
    fmt.Println("链表:", list) // 输出: [5 -> 10 -> 20 -> 30]
    
    // 插入元素
    list.InsertAt(15, 2)
    fmt.Println("插入后:", list) // 输出: [5 -> 10 -> 15 -> 20 -> 30]
    
    // 获取元素
    value, _ := list.Get(3)
    fmt.Println("索引3的值:", value) // 输出: 20
    
    // 删除元素
    list.Remove(15)
    fmt.Println("删除15后:", list) // 输出: [5 -> 10 -> 20 -> 30]
    
    // 迭代链表
    fmt.Println("链表元素:")
    list.ForEach(func(value interface{}, index int) bool {
        fmt.Printf("索引%d: %v\n", index, value)
        return true
    })
}
```

## 双向链表

双向链表中的每个节点有两个指针，一个指向下一个节点，一个指向前一个节点。

### 基本结构

```go
package linkedlist

// DoublyNode 表示双向链表中的节点
type DoublyNode struct {
    Value interface{}   // 节点存储的值
    Next  *DoublyNode   // 指向下一个节点的指针
    Prev  *DoublyNode   // 指向前一个节点的指针
}

// DoublyLinkedList 表示双向链表
type DoublyLinkedList struct {
    Head *DoublyNode // 链表头节点
    Tail *DoublyNode // 链表尾节点
    Size int         // 链表中节点的数量
}

// NewDoubly 创建并返回一个新的空双向链表
func NewDoubly() *DoublyLinkedList {
    return &DoublyLinkedList{}
}
```

### 基本操作

```go
// Append 在链表末尾添加节点
func (l *DoublyLinkedList) Append(value interface{}) {
    newNode := &DoublyNode{Value: value}
    
    if l.Head == nil {
        // 如果链表为空
        l.Head = newNode
        l.Tail = newNode
    } else {
        // 将新节点添加到尾部
        newNode.Prev = l.Tail
        l.Tail.Next = newNode
        l.Tail = newNode
    }
    
    l.Size++
}

// Prepend 在链表头部添加节点
func (l *DoublyLinkedList) Prepend(value interface{}) {
    newNode := &DoublyNode{Value: value}
    
    if l.Head == nil {
        // 如果链表为空
        l.Head = newNode
        l.Tail = newNode
    } else {
        // 将新节点添加到头部
        newNode.Next = l.Head
        l.Head.Prev = newNode
        l.Head = newNode
    }
    
    l.Size++
}

// RemoveAt 删除指定位置的节点
func (l *DoublyLinkedList) RemoveAt(position int) (interface{}, error) {
    // 检查链表是否为空
    if l.Size == 0 {
        return nil, fmt.Errorf("链表为空")
    }
    
    // 检查位置是否有效
    if position < 0 || position >= l.Size {
        return nil, fmt.Errorf("位置超出范围: %d, 有效范围: 0-%d", position, l.Size-1)
    }
    
    var removedNode *DoublyNode
    
    // 删除头节点
    if position == 0 {
        removedNode = l.Head
        l.Head = l.Head.Next
        
        // 如果链表变为空，更新尾节点
        if l.Head == nil {
            l.Tail = nil
        } else {
            // 断开前一个节点的引用
            l.Head.Prev = nil
        }
    } else if position == l.Size-1 {
        // 删除尾节点
        removedNode = l.Tail
        l.Tail = l.Tail.Prev
        l.Tail.Next = nil
    } else {
        // 删除中间节点
        // 从头部或尾部开始，选择更近的一端遍历
        if position < l.Size/2 {
            // 从头部开始
            removedNode = l.Head
            for i := 0; i < position; i++ {
                removedNode = removedNode.Next
            }
        } else {
            // 从尾部开始
            removedNode = l.Tail
            for i := l.Size - 1; i > position; i-- {
                removedNode = removedNode.Prev
            }
        }
        
        // 更新前后节点的引用
        removedNode.Prev.Next = removedNode.Next
        removedNode.Next.Prev = removedNode.Prev
    }
    
    // 清除被删除节点的引用，帮助垃圾回收
    value := removedNode.Value
    removedNode.Next = nil
    removedNode.Prev = nil
    
    l.Size--
    return value, nil
}
```

### 其他操作

双向链表可以实现比单向链表更高效的操作，例如反向遍历和从尾部删除元素：

```go
// Reverse 返回链表元素的反向迭代
func (l *DoublyLinkedList) Reverse() []interface{} {
    array := make([]interface{}, l.Size)
    
    current := l.Tail
    index := 0
    
    for current != nil {
        array[index] = current.Value
        current = current.Prev
        index++
    }
    
    return array
}

// ForEachReverse 从尾到头对链表中的每个元素执行给定函数
func (l *DoublyLinkedList) ForEachReverse(fn func(value interface{}, index int) bool) {
    current := l.Tail
    index := l.Size - 1
    
    for current != nil {
        if !fn(current.Value, index) {
            break
        }
        current = current.Prev
        index--
    }
}
```

## 循环链表

循环链表是一种特殊的链表，其尾节点指向头节点，形成一个环。

### 单向循环链表

```go
package linkedlist

// CircularLinkedList 表示单向循环链表
type CircularLinkedList struct {
    Head *Node // 链表头节点
    Tail *Node // 链表尾节点
    Size int   // 链表中节点的数量
}

// NewCircular 创建并返回一个新的空循环链表
func NewCircular() *CircularLinkedList {
    return &CircularLinkedList{}
}

// Append 在链表末尾添加节点
func (l *CircularLinkedList) Append(value interface{}) {
    newNode := &Node{Value: value}
    
    if l.Head == nil {
        // 如果链表为空
        l.Head = newNode
        l.Tail = newNode
        newNode.Next = newNode // 指向自身形成循环
    } else {
        // 将新节点添加到尾部
        newNode.Next = l.Head // 新节点指向头部形成循环
        l.Tail.Next = newNode // 旧尾节点指向新节点
        l.Tail = newNode      // 更新尾节点
    }
    
    l.Size++
}

// Traverse 遍历循环链表指定的圈数
func (l *CircularLinkedList) Traverse(rounds int) []interface{} {
    if l.IsEmpty() {
        return []interface{}{}
    }
    
    result := make([]interface{}, 0, l.Size*rounds)
    current := l.Head
    count := 0
    
    // 遍历指定的圈数
    for count < l.Size*rounds {
        result = append(result, current.Value)
        current = current.Next
        count++
    }
    
    return result
}
```

## 链表的应用场景

链表在以下场景中特别有用：

1. **动态数据集合** - 当数据集合大小不确定或经常变化时
2. **频繁插入和删除操作** - 特别是在列表中间位置
3. **实现其他数据结构** - 如栈、队列、散列表的冲突解决等
4. **内存利用** - 当需要有效利用分散的内存空间时
5. **LRU缓存** - 实现最近最少使用缓存
6. **多项式表示** - 表示和操作多项式
7. **编辑器缓冲区** - 存储和操作文本

## 实际应用示例：LRU缓存

