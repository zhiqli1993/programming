# 项目结构与组织

## 概述
Go项目的目录结构和代码组织对于项目的可维护性、可扩展性和协作效率有着重要影响。本文档介绍Go项目的标准目录结构、包组织原则以及大型项目的代码组织最佳实践，帮助开发者构建结构清晰、易于维护的Go应用。

## 基本原则

### 标准项目布局
```
project-root/
├── cmd/                    # 主要应用程序入口点
│   └── myapp/              # 应用程序名称
│       └── main.go         # 主函数文件
├── internal/               # 私有应用程序和库代码
│   ├── app/                # 应用程序代码
│   ├── pkg/                # 不导出的库代码
│   └── service/            # 内部服务实现
├── pkg/                    # 可被外部应用导入的库代码
├── api/                    # OpenAPI/Swagger规范、JSON模式文件等
├── web/                    # Web应用特定组件(静态资源、模板等)
├── configs/                # 配置文件模板或默认配置
├── scripts/                # 构建、安装、分析等操作的脚本
├── build/                  # 打包和持续集成
│   ├── ci/                 # CI配置和脚本
│   └── package/            # 打包配置和脚本
├── deployments/            # IaaS、PaaS、系统和容器编排部署配置
├── test/                   # 额外的外部测试应用和测试数据
├── docs/                   # 设计和用户文档
├── tools/                  # 项目的支持工具
├── examples/               # 应用程序或公共库的示例
├── third_party/            # 外部辅助工具(fork的工具等)
├── vendor/                 # 应用程序依赖项(go mod vendor)
├── LICENSE                 # 许可证文件
├── README.md               # 项目说明
├── Makefile                # 构建自动化
├── go.mod                  # Go模块定义
└── go.sum                  # Go模块依赖校验
```

## 包组织策略

### 按功能组织
将相关功能组织在同一个包中，适合中小型项目：

```go
package user    // 用户相关功能
package order   // 订单相关功能
package payment // 支付相关功能
```

### 按层组织
按照技术层次组织代码，适合复杂项目：

```
project/
├── handler/  // HTTP处理层
├── service/  // 业务逻辑层
├── repo/     // 数据访问层
└── model/    // 数据模型层
```

### 六边形架构(端口与适配器)
将业务逻辑与外部依赖隔离：

```
project/
├── core/      // 领域模型和业务逻辑
├── ports/     // 输入输出接口定义
└── adapters/  // 接口实现(数据库、HTTP等)
```

## 示例代码

### 标准项目结构示例

```go
// cmd/myapp/main.go
package main

import (
    "log"
    
    "github.com/username/project/internal/app"
    "github.com/username/project/internal/config"
)

func main() {
    cfg, err := config.Load()
    if err != nil {
        log.Fatalf("Failed to load config: %v", err)
    }
    
    app := app.New(cfg)
    if err := app.Run(); err != nil {
        log.Fatalf("Application error: %v", err)
    }
}
```

### 包导入示例

```go
// internal/app/app.go
package app

import (
    "github.com/username/project/internal/service/user"
    "github.com/username/project/internal/service/order"
    "github.com/username/project/pkg/logger"
    "github.com/username/project/internal/config"
)

type App struct {
    userSvc  *user.Service
    orderSvc *order.Service
    logger   *logger.Logger
    config   *config.Config
}

func New(cfg *config.Config) *App {
    logger := logger.New(cfg.LogLevel)
    
    return &App{
        userSvc:  user.NewService(logger),
        orderSvc: order.NewService(logger),
        logger:   logger,
        config:   cfg,
    }
}

func (a *App) Run() error {
    a.logger.Info("Application starting")
    // 启动HTTP服务器、gRPC服务器等
    return nil
}
```

## 常见问题与解决方案

1. **循环依赖问题**
   - 问题：包之间相互导入形成循环依赖
   - 解决：提取共享类型到单独的包，或重新设计接口关系

2. **包过大问题**
   - 问题：单个包含有过多文件和功能
   - 解决：按照子功能拆分为多个包，确保每个包职责单一

3. **内部包泄露问题**
   - 问题：internal包中的实现细节泄露到外部
   - 解决：严格遵循包可见性规则，使用接口隔离实现细节

## 进阶内容

### 大型单体应用组织
对于大型单体应用，可采用以下目录结构：

```
internal/
├── app/             # 应用层，协调各种服务
├── domain/          # 领域模型，核心业务逻辑
│   ├── user/        # 用户领域
│   ├── order/       # 订单领域
│   └── payment/     # 支付领域
├── service/         # 服务层，实现业务用例
├── repository/      # 数据访问层
├── transport/       # 传输层(HTTP、gRPC等)
└── config/          # 应用配置
```

### 微服务项目组织
对于微服务架构，每个服务可以是一个独立的项目，也可以在单一代码库中组织：

```
services/
├── user/            # 用户服务
│   ├── cmd/         # 入口点
│   ├── internal/    # 服务私有代码
│   └── go.mod       # 服务依赖
├── order/           # 订单服务
├── payment/         # 支付服务
└── shared/          # 共享代码库
    └── pkg/         # 公共包
```

## 相关知识点
- [包和模块](../基础知识/包和模块.md)
- [依赖管理](依赖管理.md)
- [构建与部署](构建与部署.md)
