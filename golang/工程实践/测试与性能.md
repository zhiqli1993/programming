# Goè¯­è¨€æµ‹è¯•ä¸æ€§èƒ½åˆ†æ

## ğŸ“š å­¦ä¹ ç›®æ ‡
æŒæ¡Goè¯­è¨€çš„æµ‹è¯•æ¡†æ¶ï¼Œå­¦ä¼šç¼–å†™å•å…ƒæµ‹è¯•ã€åŸºå‡†æµ‹è¯•å’Œç¤ºä¾‹æµ‹è¯•ï¼Œäº†è§£ä»£ç è¦†ç›–ç‡å’Œæ€§èƒ½åˆ†æå·¥å…·çš„ä½¿ç”¨ï¼ŒåŸ¹å…»æµ‹è¯•é©±åŠ¨å¼€å‘çš„æ€ç»´å’Œä¹ æƒ¯ã€‚

---

## 1. Goæµ‹è¯•åŸºç¡€

### 1.1 æµ‹è¯•æ–‡ä»¶å‘½åè§„èŒƒ
- æµ‹è¯•æ–‡ä»¶ä»¥`_test.go`ç»“å°¾
- æµ‹è¯•æ–‡ä»¶ä¸è¢«æµ‹æ–‡ä»¶æ”¾åœ¨åŒä¸€ä¸ªåŒ…ä¸­
- ä¸€èˆ¬æµ‹è¯•æ–‡ä»¶ä¸è¢«æµ‹æ–‡ä»¶åŒåï¼Œå¦‚`user.go`å’Œ`user_test.go`

### 1.2 æµ‹è¯•å‡½æ•°å‘½åè§„èŒƒ
- å•å…ƒæµ‹è¯•å‡½æ•°ä»¥`Test`å¼€å¤´ï¼Œå¦‚`TestAdd`
- åŸºå‡†æµ‹è¯•å‡½æ•°ä»¥`Benchmark`å¼€å¤´ï¼Œå¦‚`BenchmarkAdd`
- ç¤ºä¾‹æµ‹è¯•å‡½æ•°ä»¥`Example`å¼€å¤´ï¼Œå¦‚`ExampleAdd`
- ä¸€èˆ¬æµ‹è¯•å‡½æ•°åç§°ä¸º"Test+è¢«æµ‹å‡½æ•°å"

### 1.3 åŸºæœ¬æµ‹è¯•ç»“æ„
```go
package main

import (
    "testing"
)

// è¢«æµ‹å‡½æ•°
func Add(a, b int) int {
    return a + b
}

// æµ‹è¯•å‡½æ•°
func TestAdd(t *testing.T) {
    got := Add(2, 3)
    want := 5
    
    if got != want {
        t.Errorf("Add(2, 3) = %d; want %d", got, want)
    }
}
```

### 1.4 è¿è¡Œæµ‹è¯•
```bash
# è¿è¡Œå½“å‰åŒ…ä¸­çš„æ‰€æœ‰æµ‹è¯•
go test

# è¯¦ç»†è¾“å‡ºæ¨¡å¼
go test -v

# è¿è¡Œç‰¹å®šæµ‹è¯•å‡½æ•°
go test -run TestAdd

# è¿è¡Œç‰¹å®šåŒ…çš„æµ‹è¯•
go test github.com/yourname/yourproject/pkg/...

# è¿è¡Œå¤šä¸ªåŒ…çš„æµ‹è¯•
go test ./...
```

---

## 2. å•å…ƒæµ‹è¯•

### 2.1 è¡¨æ ¼é©±åŠ¨æµ‹è¯•
è¡¨æ ¼é©±åŠ¨æµ‹è¯•æ˜¯Goè¯­è¨€ä¸­å¸¸ç”¨çš„æµ‹è¯•æ¨¡å¼ï¼Œé€‚åˆæµ‹è¯•å¤šç§è¾“å…¥å’Œé¢„æœŸè¾“å‡ºçš„ç»„åˆï¼š

```go
package main

import (
    "testing"
)

func TestAdd(t *testing.T) {
    // æµ‹è¯•ç”¨ä¾‹è¡¨
    tests := []struct {
        name     string
        a, b     int
        expected int
    }{
        {"positive", 2, 3, 5},
        {"negative", -2, -3, -5},
        {"mixed", -2, 3, 1},
        {"zero", 0, 0, 0},
    }
    
    // è¿è¡Œæµ‹è¯•ç”¨ä¾‹
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := Add(tt.a, tt.b)
            if got != tt.expected {
                t.Errorf("Add(%d, %d) = %d; want %d", 
                         tt.a, tt.b, got, tt.expected)
            }
        })
    }
}
```

### 2.2 å­æµ‹è¯•
Go 1.7å¼•å…¥äº†å­æµ‹è¯•åŠŸèƒ½ï¼Œå¯ä»¥å°†ç›¸å…³çš„æµ‹è¯•ç»„ç»‡åœ¨ä¸€èµ·ï¼š

```go
package main

import (
    "testing"
)

func TestUserOperations(t *testing.T) {
    t.Run("Create", func(t *testing.T) {
        // æµ‹è¯•åˆ›å»ºç”¨æˆ·åŠŸèƒ½
        user := CreateUser("John", "john@example.com")
        if user.Name != "John" {
            t.Errorf("Expected name 'John', got '%s'", user.Name)
        }
    })
    
    t.Run("Update", func(t *testing.T) {
        // æµ‹è¯•æ›´æ–°ç”¨æˆ·åŠŸèƒ½
        user := CreateUser("John", "john@example.com")
        updated := UpdateUser(user, "John Doe", "john@example.com")
        if updated.Name != "John Doe" {
            t.Errorf("Expected name 'John Doe', got '%s'", updated.Name)
        }
    })
    
    t.Run("Delete", func(t *testing.T) {
        // æµ‹è¯•åˆ é™¤ç”¨æˆ·åŠŸèƒ½
        user := CreateUser("John", "john@example.com")
        success := DeleteUser(user.ID)
        if !success {
            t.Errorf("Failed to delete user")
        }
    })
}
```

### 2.3 è¾…åŠ©å‡½æ•°
ç¼–å†™è¾…åŠ©å‡½æ•°å¯ä»¥å‡å°‘æµ‹è¯•ä»£ç çš„é‡å¤ï¼š

```go
package main

import (
    "testing"
)

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥é”™è¯¯
func checkError(t *testing.T, got, want error) {
    t.Helper() // æ ‡è®°ä¸ºè¾…åŠ©å‡½æ•°ï¼Œé”™è¯¯å°†æŒ‡å‘è°ƒç”¨è€…è€Œéæœ¬å‡½æ•°
    
    if got != want {
        t.Fatalf("got error %q, want %q", got, want)
    }
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥æ•´æ•°ç»“æœ
func checkInt(t *testing.T, got, want int) {
    t.Helper()
    
    if got != want {
        t.Fatalf("got %d, want %d", got, want)
    }
}

// ä½¿ç”¨è¾…åŠ©å‡½æ•°çš„æµ‹è¯•
func TestDivide(t *testing.T) {
    result, err := Divide(10, 2)
    checkError(t, err, nil)
    checkInt(t, result, 5)
    
    _, err = Divide(10, 0)
    checkError(t, err, ErrDivideByZero)
}
```

### 2.4 æµ‹è¯•ç”¨ä¾‹è®¾ç½®å’Œæ¸…ç†
ä½¿ç”¨`t.Cleanup`å‡½æ•°å¯ä»¥åœ¨æµ‹è¯•ç»“æŸæ—¶è‡ªåŠ¨æ¸…ç†èµ„æºï¼š

```go
package main

import (
    "os"
    "testing"
)

func TestFileOperations(t *testing.T) {
    // åˆ›å»ºä¸´æ—¶æ–‡ä»¶
    tmpfile, err := os.CreateTemp("", "example")
    if err != nil {
        t.Fatalf("Failed to create temp file: %v", err)
    }
    
    // æ³¨å†Œæ¸…ç†å‡½æ•°
    t.Cleanup(func() {
        tmpfile.Close()
        os.Remove(tmpfile.Name())
        t.Log("Temporary file cleaned up")
    })
    
    // æ‰§è¡Œæµ‹è¯•
    // ...
}
```

å¯¹äºå¤šä¸ªæµ‹è¯•é€šç”¨çš„è®¾ç½®å’Œæ¸…ç†ï¼Œå¯ä»¥ä½¿ç”¨`TestMain`ï¼š

```go
package main

import (
    "database/sql"
    "log"
    "os"
    "testing"
    
    _ "github.com/go-sql-driver/mysql"
)

var db *sql.DB

// TestMain æ˜¯æµ‹è¯•å…¥å£
func TestMain(m *testing.M) {
    // è®¾ç½®
    var err error
    db, err = sql.Open("mysql", "user:password@/testdb")
    if err != nil {
        log.Fatalf("Failed to connect to test database: %v", err)
    }
    
    // æ‰§è¡Œæµ‹è¯•
    code := m.Run()
    
    // æ¸…ç†
    db.Close()
    
    // é€€å‡º
    os.Exit(code)
}

// æµ‹è¯•å‡½æ•°å¯ä»¥ä½¿ç”¨å…¨å±€dbå˜é‡
func TestUserRepository(t *testing.T) {
    // ä½¿ç”¨dbè¿›è¡Œæµ‹è¯•
    // ...
}
```

---

## 3. æµ‹è¯•è¦†ç›–ç‡

### 3.1 è¿è¡Œè¦†ç›–ç‡æµ‹è¯•
```bash
# è¿è¡Œæµ‹è¯•å¹¶æ˜¾ç¤ºè¦†ç›–ç‡
go test -cover

# ç”Ÿæˆè¦†ç›–ç‡åˆ†ææ–‡ä»¶
go test -coverprofile=coverage.out

# å°†è¦†ç›–ç‡æ•°æ®è½¬æ¢ä¸ºHTMLæŠ¥å‘Š
go tool cover -html=coverage.out -o coverage.html

# æŸ¥çœ‹è¦†ç›–ç‡è¯¦æƒ…
go tool cover -func=coverage.out
```

### 3.2 è¦†ç›–ç‡ç¤ºä¾‹
```go
package main

import (
    "testing"
)

// è¢«æµ‹å‡½æ•°
func IsEven(n int) bool {
    return n%2 == 0
}

func IsOdd(n int) bool {
    return !IsEven(n)
}

// æµ‹è¯•å‡½æ•°
func TestIsEven(t *testing.T) {
    if !IsEven(2) {
        t.Error("IsEven(2) should be true")
    }
    
    if IsEven(3) {
        t.Error("IsEven(3) should be false")
    }
}

// æ³¨æ„ï¼šè¿™é‡Œæ²¡æœ‰æµ‹è¯•IsOddå‡½æ•°ï¼Œå°†å¯¼è‡´è¦†ç›–ç‡ä¸è¶³100%
```

### 3.3 è®¾ç½®è¦†ç›–ç‡ç›®æ ‡
åœ¨CI/CDç³»ç»Ÿä¸­ï¼Œå¯ä»¥è®¾ç½®æœ€ä½è¦†ç›–ç‡è¦æ±‚ï¼š

```bash
# å¦‚æœè¦†ç›–ç‡ä½äº80%ï¼Œæµ‹è¯•å¤±è´¥
go test -cover -covermode=atomic -coverprofile=coverage.out && \
    go tool cover -func=coverage.out | \
    awk 'END{if($3+0<80.0){print "Coverage below 80%";exit 1}}'
```

---

## 4. åŸºå‡†æµ‹è¯•

### 4.1 åŸºå‡†æµ‹è¯•åŸºç¡€
åŸºå‡†æµ‹è¯•ç”¨äºæµ‹é‡å‡½æ•°çš„æ€§èƒ½ï¼š

```go
package main

import (
    "testing"
)

// è¢«æµ‹å‡½æ•°
func Fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    return Fibonacci(n-1) + Fibonacci(n-2)
}

// åŸºå‡†æµ‹è¯•
func BenchmarkFibonacci(b *testing.B) {
    // é‡ç½®è®¡æ—¶å™¨
    b.ResetTimer()
    
    // å¾ªç¯b.Næ¬¡ï¼Œb.Nç”±testingåŒ…è‡ªåŠ¨è®¾ç½®
    for i := 0; i < b.N; i++ {
        Fibonacci(10)
    }
}
```

### 4.2 è¿è¡ŒåŸºå‡†æµ‹è¯•
```bash
# è¿è¡Œå½“å‰åŒ…ä¸­çš„æ‰€æœ‰åŸºå‡†æµ‹è¯•
go test -bench=.

# è¿è¡Œç‰¹å®šåŸºå‡†æµ‹è¯•
go test -bench=BenchmarkFibonacci

# æŒ‡å®šè¿è¡Œæ—¶é—´ï¼ˆé»˜è®¤ä¸º1ç§’ï¼‰
go test -bench=. -benchtime=5s

# æ˜¾ç¤ºå†…å­˜åˆ†é…ç»Ÿè®¡
go test -bench=. -benchmem
```

### 4.3 æ¯”è¾ƒåŸºå‡†æµ‹è¯•
å¯ä»¥ç¼–å†™å¤šä¸ªåŸºå‡†æµ‹è¯•æ¥æ¯”è¾ƒä¸åŒå®ç°çš„æ€§èƒ½ï¼š

```go
package main

import (
    "testing"
)

// é€’å½’å®ç°
func FibonacciRecursive(n int) int {
    if n <= 1 {
        return n
    }
    return FibonacciRecursive(n-1) + FibonacciRecursive(n-2)
}

// è¿­ä»£å®ç°
func FibonacciIterative(n int) int {
    if n <= 1 {
        return n
    }
    
    a, b := 0, 1
    for i := 2; i <= n; i++ {
        a, b = b, a+b
    }
    
    return b
}

// å¸¦ç¼“å­˜çš„å®ç°
func FibonacciMemoized(n int) int {
    cache := make(map[int]int)
    
    var fib func(int) int
    fib = func(x int) int {
        if x <= 1 {
            return x
        }
        
        if val, found := cache[x]; found {
            return val
        }
        
        cache[x] = fib(x-1) + fib(x-2)
        return cache[x]
    }
    
    return fib(n)
}

// åŸºå‡†æµ‹è¯•
func BenchmarkFibonacciRecursive(b *testing.B) {
    for i := 0; i < b.N; i++ {
        FibonacciRecursive(10)
    }
}

func BenchmarkFibonacciIterative(b *testing.B) {
    for i := 0; i < b.N; i++ {
        FibonacciIterative(10)
    }
}

func BenchmarkFibonacciMemoized(b *testing.B) {
    for i := 0; i < b.N; i++ {
        FibonacciMemoized(10)
    }
}
```

### 4.4 åŸºå‡†æµ‹è¯•å‚æ•°
ä½¿ç”¨å‚æ•°åŒ–çš„åŸºå‡†æµ‹è¯•å¯ä»¥æµ‹è¯•ä¸åŒè¾“å…¥è§„æ¨¡ä¸‹çš„æ€§èƒ½ï¼š

```go
package main

import (
    "testing"
)

func BenchmarkFibonacciParameterized(b *testing.B) {
    // æµ‹è¯•ä¸åŒè¾“å…¥è§„æ¨¡
    for _, size := range []int{5, 10, 15, 20} {
        b.Run(fmt.Sprintf("input_size_%d", size), func(b *testing.B) {
            for i := 0; i < b.N; i++ {
                FibonacciMemoized(size)
            }
        })
    }
}
```

---

## 5. ç¤ºä¾‹æµ‹è¯•

### 5.1 ç¤ºä¾‹æµ‹è¯•åŸºç¡€
ç¤ºä¾‹æµ‹è¯•æ—¢æ˜¯æ–‡æ¡£ï¼Œä¹Ÿæ˜¯å¯æ‰§è¡Œçš„æµ‹è¯•ï¼š

```go
package main

import (
    "fmt"
)

// è¢«æµ‹å‡½æ•°
func Greet(name string) string {
    return "Hello, " + name + "!"
}

// ç¤ºä¾‹æµ‹è¯•
func ExampleGreet() {
    message := Greet("World")
    fmt.Println(message)
    // Output: Hello, World!
}
```

ç¤ºä¾‹è¾“å‡ºé€šè¿‡`// Output:`æ³¨é‡ŠæŒ‡å®šï¼Œæµ‹è¯•æ—¶ä¼šæ¯”è¾ƒå‡½æ•°è¾“å‡ºå’Œæ³¨é‡ŠæŒ‡å®šçš„æœŸæœ›è¾“å‡ºã€‚

### 5.2 å¤šä¸ªç¤ºä¾‹
å¯ä»¥ä¸ºä¸€ä¸ªå‡½æ•°æä¾›å¤šä¸ªç¤ºä¾‹ï¼š

```go
package main

import (
    "fmt"
    "sort"
)

// ç¤ºä¾‹ï¼šåŸºæœ¬æ’åº
func ExampleSort() {
    fruits := []string{"banana", "apple", "pear"}
    sort.Strings(fruits)
    fmt.Println(fruits)
    // Output: [apple banana pear]
}

// ç¤ºä¾‹ï¼šè‡ªå®šä¹‰æ’åº
func ExampleSort_custom() {
    people := []struct {
        Name string
        Age  int
    }{
        {"Alice", 25},
        {"Bob", 30},
        {"Charlie", 20},
    }
    
    // æŒ‰å¹´é¾„æ’åº
    sort.Slice(people, func(i, j int) bool {
        return people[i].Age < people[j].Age
    })
    
    for _, person := range people {
        fmt.Printf("%s: %d\n", person.Name, person.Age)
    }
    // Output:
    // Charlie: 20
    // Alice: 25
    // Bob: 30
}
```

### 5.3 æ— åºè¾“å‡ºç¤ºä¾‹
å¯¹äºè¾“å‡ºé¡ºåºä¸ç¡®å®šçš„ç¤ºä¾‹ï¼Œå¯ä»¥ä½¿ç”¨`// Unordered output:`ï¼š

```go
package main

import (
    "fmt"
    "math/rand"
)

func ExampleUnorderedOutput() {
    // æ¨¡æ‹Ÿè¾“å‡ºé¡ºåºä¸ç¡®å®šçš„æƒ…å†µ
    for _, n := range []int{rand.Intn(3), rand.Intn(3), rand.Intn(3)} {
        fmt.Println(n)
    }
    // Unordered output:
    // 0
    // 1
    // 2
}
```

---

## 6. æ¨¡æ‹Ÿä¸ä¾èµ–æ³¨å…¥

### 6.1 åŸºäºæ¥å£çš„æ¨¡æ‹Ÿ
Goè¯­è¨€æ¨èä½¿ç”¨æ¥å£å’Œä¾èµ–æ³¨å…¥æ¥å®ç°æµ‹è¯•éš”ç¦»ï¼š

```go
package main

import (
    "testing"
)

// æ•°æ®å­˜å‚¨æ¥å£
type UserStore interface {
    Save(user User) error
    FindByID(id string) (User, error)
}

// ç”¨æˆ·æœåŠ¡
type UserService struct {
    store UserStore
}

// åˆ›å»ºæ–°çš„ç”¨æˆ·æœåŠ¡
func NewUserService(store UserStore) *UserService {
    return &UserService{store: store}
}

// åˆ›å»ºç”¨æˆ·
func (s *UserService) CreateUser(name, email string) (User, error) {
    user := User{
        ID:    generateID(),
        Name:  name,
        Email: email,
    }
    
    err := s.store.Save(user)
    return user, err
}

// æ¨¡æ‹Ÿå­˜å‚¨å®ç°
type MockUserStore struct {
    users map[string]User
}

func NewMockUserStore() *MockUserStore {
    return &MockUserStore{
        users: make(map[string]User),
    }
}

func (m *MockUserStore) Save(user User) error {
    m.users[user.ID] = user
    return nil
}

func (m *MockUserStore) FindByID(id string) (User, error) {
    user, found := m.users[id]
    if !found {
        return User{}, ErrUserNotFound
    }
    return user, nil
}

// æµ‹è¯•ç”¨æˆ·æœåŠ¡
func TestUserService_CreateUser(t *testing.T) {
    // åˆ›å»ºæ¨¡æ‹Ÿå­˜å‚¨
    mockStore := NewMockUserStore()
    
    // åˆ›å»ºç”¨æˆ·æœåŠ¡ï¼Œæ³¨å…¥æ¨¡æ‹Ÿå­˜å‚¨
    service := NewUserService(mockStore)
    
    // æµ‹è¯•åˆ›å»ºç”¨æˆ·
    user, err := service.CreateUser("John", "john@example.com")
    if err != nil {
        t.Fatalf("Expected no error, got %v", err)
    }
    
    // éªŒè¯ç”¨æˆ·å·²ä¿å­˜åˆ°å­˜å‚¨ä¸­
    savedUser, err := mockStore.FindByID(user.ID)
    if err != nil {
        t.Fatalf("Failed to find user: %v", err)
    }
    
    if savedUser.Name != "John" || savedUser.Email != "john@example.com" {
        t.Errorf("User data doesn't match. Got %+v", savedUser)
    }
}
```

### 6.2 è¡¨é©±åŠ¨çš„æ¨¡æ‹Ÿæµ‹è¯•
å°†æ¨¡æ‹Ÿä¸è¡¨é©±åŠ¨æµ‹è¯•ç»“åˆï¼š

```go
package main

import (
    "errors"
    "testing"
)

// æµ‹è¯•ç”¨ä¾‹
func TestUserService_CreateUser_Multiple(t *testing.T) {
    tests := []struct {
        name      string
        storeBehavior func(*MockUserStore)
        userName  string
        userEmail string
        wantErr   bool
        errMsg    string
    }{
        {
            name:      "success",
            storeBehavior: func(m *MockUserStore) {
                // é»˜è®¤è¡Œä¸ºï¼Œæ­£å¸¸ä¿å­˜
            },
            userName:  "John",
            userEmail: "john@example.com",
            wantErr:   false,
        },
        {
            name:      "store error",
            storeBehavior: func(m *MockUserStore) {
                // ä¿®æ”¹Saveæ–¹æ³•è¿”å›é”™è¯¯
                m.SaveFunc = func(user User) error {
                    return errors.New("database error")
                }
            },
            userName:  "John",
            userEmail: "john@example.com",
            wantErr:   true,
            errMsg:    "database error",
        },
        {
            name:      "validation error",
            storeBehavior: func(m *MockUserStore) {
                // ä¿æŒé»˜è®¤è¡Œä¸º
            },
            userName:  "", // ç©ºåç§°å°†å¯¼è‡´éªŒè¯é”™è¯¯
            userEmail: "john@example.com",
            wantErr:   true,
            errMsg:    "name cannot be empty",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // åˆ›å»ºå¯é…ç½®çš„æ¨¡æ‹Ÿå­˜å‚¨
            mockStore := NewConfigurableMockUserStore()
            
            // åº”ç”¨æµ‹è¯•ç‰¹å®šçš„è¡Œä¸º
            tt.storeBehavior(mockStore)
            
            // åˆ›å»ºæœåŠ¡å¹¶è¿è¡Œæµ‹è¯•
            service := NewUserService(mockStore)
            _, err := service.CreateUser(tt.userName, tt.userEmail)
            
            // éªŒè¯ç»“æœ
            if tt.wantErr {
                if err == nil {
                    t.Fatal("Expected error but got none")
                }
                if err.Error() != tt.errMsg {
                    t.Errorf("Expected error message %q, got %q", tt.errMsg, err.Error())
                }
            } else {
                if err != nil {
                    t.Fatalf("Expected no error, got %v", err)
                }
            }
        })
    }
}

// å¯é…ç½®çš„æ¨¡æ‹Ÿå­˜å‚¨
type ConfigurableMockUserStore struct {
    users    map[string]User
    SaveFunc func(User) error
    FindFunc func(string) (User, error)
}

func NewConfigurableMockUserStore() *ConfigurableMockUserStore {
    m := &ConfigurableMockUserStore{
        users: make(map[string]User),
    }
    
    // è®¾ç½®é»˜è®¤è¡Œä¸º
    m.SaveFunc = func(user User) error {
        m.users[user.ID] = user
        return nil
    }
    
    m.FindFunc = func(id string) (User, error) {
        user, found := m.users[id]
        if !found {
            return User{}, ErrUserNotFound
        }
        return user, nil
    }
    
    return m
}

func (m *ConfigurableMockUserStore) Save(user User) error {
    return m.SaveFunc(user)
}

func (m *ConfigurableMockUserStore) FindByID(id string) (User, error) {
    return m.FindFunc(id)
}
```

### 6.3 ä½¿ç”¨ç¬¬ä¸‰æ–¹æ¨¡æ‹Ÿå·¥å…·
å¯¹äºå¤æ‚çš„æ¨¡æ‹Ÿåœºæ™¯ï¼Œå¯ä»¥ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“ï¼š

```go
package main

import (
    "testing"
    
    "github.com/golang/mock/gomock"
)

// ä½¿ç”¨mockgenç”Ÿæˆçš„æ¨¡æ‹Ÿ
//go:generate mockgen -destination=mocks/mock_store.go -package=mocks github.com/yourorg/yourproject UserStore

func TestUserServiceWithMockGen(t *testing.T) {
    // åˆ›å»ºæ§åˆ¶å™¨
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    
    // åˆ›å»ºæ¨¡æ‹Ÿå­˜å‚¨
    mockStore := mocks.NewMockUserStore(ctrl)
    
    // è®¾ç½®æœŸæœ›
    user := User{ID: "123", Name: "John", Email: "john@example.com"}
    mockStore.EXPECT().
        Save(gomock.Any()).
        DoAndReturn(func(u User) error {
            // éªŒè¯ç”¨æˆ·æ•°æ®ä½†å¿½ç•¥ID
            if u.Name != "John" || u.Email != "john@example.com" {
                t.Errorf("Unexpected user: %+v", u)
            }
            return nil
        })
    
    // åˆ›å»ºæœåŠ¡å¹¶æµ‹è¯•
    service := NewUserService(mockStore)
    createdUser, err := service.CreateUser("John", "john@example.com")
    
    if err != nil {
        t.Fatalf("Expected no error, got %v", err)
    }
    
    if createdUser.Name != "John" || createdUser.Email != "john@example.com" {
        t.Errorf("User data doesn't match. Got %+v", createdUser)
    }
}
```

---

## 7. HTTPæµ‹è¯•

### 7.1 æµ‹è¯•HTTPå¤„ç†å™¨
ä½¿ç”¨`httptest`åŒ…æµ‹è¯•HTTPå¤„ç†å™¨ï¼š

```go
package main

import (
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "strings"
    "testing"
)

// HTTPå¤„ç†å™¨
func UserHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method == http.MethodPost {
        var user User
        decoder := json.NewDecoder(r.Body)
        if err := decoder.Decode(&user); err != nil {
            http.Error(w, "Invalid request body", http.StatusBadRequest)
            return
        }
        
        // æ·»åŠ ç”¨æˆ·...
        
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(user)
        return
    }
    
    // ä¸æ”¯æŒçš„æ–¹æ³•
    w.WriteHeader(http.StatusMethodNotAllowed)
}

// æµ‹è¯•HTTPå¤„ç†å™¨
func TestUserHandler(t *testing.T) {
    // åˆ›å»ºè¯·æ±‚
    reqBody := `{"name":"John","email":"john@example.com"}`
    req, err := http.NewRequest(http.MethodPost, "/users", strings.NewReader(reqBody))
    if err != nil {
        t.Fatalf("Failed to create request: %v", err)
    }
    
    // è®¾ç½®è¯·æ±‚å¤´
    req.Header.Set("Content-Type", "application/json")
    
    // åˆ›å»ºå“åº”è®°å½•å™¨
    rr := httptest.NewRecorder()
    
    // è°ƒç”¨å¤„ç†å™¨
    handler := http.HandlerFunc(UserHandler)
    handler.ServeHTTP(rr, req)
    
    // æ£€æŸ¥çŠ¶æ€ç 
    if status := rr.Code; status != http.StatusCreated {
        t.Errorf("Handler returned wrong status code: got %v want %v",
            status, http.StatusCreated)
    }
    
    // æ£€æŸ¥å“åº”ä½“
    var user User
    if err := json.NewDecoder(rr.Body).Decode(&user); err != nil {
        t.Fatalf("Failed to decode response body: %v", err)
    }
    
    if user.Name != "John" || user.Email != "john@example.com" {
        t.Errorf("Handler returned unexpected body: got %+v", user)
    }
}
```

### 7.2 æµ‹è¯•HTTPå®¢æˆ·ç«¯
æµ‹è¯•ä½¿ç”¨HTTPå®¢æˆ·ç«¯çš„ä»£ç ï¼š

```go
package main

import (
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"
)

// APIå®¢æˆ·ç«¯
type APIClient struct {
    baseURL    string
    httpClient *http.Client
}

func NewAPIClient(baseURL string) *APIClient {
    return &APIClient{
        baseURL:    baseURL,
        httpClient: http.DefaultClient,
    }
}

func (c *APIClient) GetUser(id string) (User, error) {
    resp, err := c.httpClient.Get(c.baseURL + "/users/" + id)
    if err != nil {
        return User{}, err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return User{}, fmt.Errorf("API returned status %d", resp.StatusCode)
    }
    
    var user User
    if err := json.NewDecoder(resp.Body).Decode(&user); err != nil {
        return User{}, err
    }
    
    return user, nil
}

// æµ‹è¯•APIå®¢æˆ·ç«¯
func TestAPIClient_GetUser(t *testing.T) {
    // åˆ›å»ºæµ‹è¯•æœåŠ¡å™¨
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // æ£€æŸ¥è¯·æ±‚è·¯å¾„
        if r.URL.Path != "/users/123" {
            t.Errorf("Expected request to '/users/123', got %s", r.URL.Path)
            http.NotFound(w, r)
            return
        }
        
        // è®¾ç½®å“åº”
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(User{
            ID:    "123",
            Name:  "John",
            Email: "john@example.com",
        })
    }))
    defer server.Close()
    
    // åˆ›å»ºå®¢æˆ·ç«¯ï¼Œä½¿ç”¨æµ‹è¯•æœåŠ¡å™¨URL
    client := NewAPIClient(server.URL)
    
    // æµ‹è¯•è·å–ç”¨æˆ·
    user, err := client.GetUser("123")
    if err != nil {
        t.Fatalf("Expected no error, got %v", err)
    }
    
    // éªŒè¯å“åº”
    if user.ID != "123" || user.Name != "John" || user.Email != "john@example.com" {
        t.Errorf("Unexpected user: %+v", user)
    }
}
```

### 7.3 æµ‹è¯•HTTPä¸­é—´ä»¶
æµ‹è¯•HTTPä¸­é—´ä»¶ï¼š

```go
package main

import (
    "net/http"
    "net/http/httptest"
    "testing"
)

// è®¤è¯ä¸­é—´ä»¶
func AuthMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        token := r.Header.Get("Authorization")
        if token != "valid-token" {
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return
        }
        
        // è®¤è¯é€šè¿‡ï¼Œç»§ç»­å¤„ç†è¯·æ±‚
        next.ServeHTTP(w, r)
    })
}

// æµ‹è¯•è®¤è¯ä¸­é—´ä»¶
func TestAuthMiddleware(t *testing.T) {
    // åˆ›å»ºä¸€ä¸ªç®€å•çš„å¤„ç†å™¨
    handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("OK"))
    })
    
    // åº”ç”¨ä¸­é—´ä»¶
    middleware := AuthMiddleware(handler)
    
    tests := []struct {
        name       string
        token      string
        wantStatus int
    }{
        {
            name:       "valid token",
            token:      "valid-token",
            wantStatus: http.StatusOK,
        },
        {
            name:       "invalid token",
            token:      "invalid-token",
            wantStatus: http.StatusUnauthorized,
        },
        {
            name:       "missing token",
            token:      "",
            wantStatus: http.StatusUnauthorized,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // åˆ›å»ºè¯·æ±‚
            req, err := http.NewRequest(http.MethodGet, "/", nil)
            if err != nil {
                t.Fatalf("Failed to create request: %v", err)
            }
            
            // è®¾ç½®è®¤è¯å¤´
            if tt.token != "" {
                req.Header.Set("Authorization", tt.token)
            }
            
            // åˆ›å»ºå“åº”è®°å½•å™¨
            rr := httptest.NewRecorder()
            
            // è°ƒç”¨ä¸­é—´ä»¶
            middleware.ServeHTTP(rr, req)
            
            // æ£€æŸ¥çŠ¶æ€ç 
            if status := rr.Code; status != tt.wantStatus {
                t.Errorf("Handler returned wrong status code: got %v want %v",
                    status, tt.wantStatus)
            }
        })
    }
}
```

---

## 8. æ•°æ®åº“æµ‹è¯•

### 8.1 ä½¿ç”¨æµ‹è¯•æ•°æ®åº“
åœ¨æµ‹è¯•ä¸­ä½¿ç”¨çœŸå®æ•°æ®åº“ï¼š

```go
package main

import (
    "database/sql"
    "testing"
    
    _ "github.com/go-sql-driver/mysql"
)

func setupTestDB(t *testing.T) (*sql.DB, func()) {
    // è¿æ¥åˆ°æµ‹è¯•æ•°æ®åº“
    db, err := sql.Open("mysql", "user:password@/testdb")
    if err != nil {
        t.Fatalf("Failed to connect to test database: %v", err)
    }
    
    // å‡†å¤‡æµ‹è¯•è¡¨
    _, err = db.Exec(`
        CREATE TEMPORARY TABLE users (
            id VARCHAR(36) PRIMARY KEY,
            name VARCHAR(100) NOT NULL,
            email VARCHAR(100) NOT NULL UNIQUE
        )
    `)
    if err != nil {
        t.Fatalf("Failed to create test table: %v", err)
    }
    
    // è¿”å›æ•°æ®åº“è¿æ¥å’Œæ¸…ç†å‡½æ•°
    return db, func() {
        db.Close()
    }
}

// æµ‹è¯•ç”¨æˆ·ä»“åº“
func TestUserRepository(t *testing.T) {
    // è®¾ç½®æµ‹è¯•æ•°æ®åº“
    db, cleanup := setupTestDB(t)
    defer cleanup()
    
    // åˆ›å»ºä»“åº“
    repo := NewUserRepository(db)
    
    // æµ‹è¯•ä¿å­˜ç”¨æˆ·
    user := User{
        ID:    "123",
        Name:  "John",
        Email: "john@example.com",
    }
    
    err := repo.Save(user)
    if err != nil {
        t.Fatalf("Failed to save user: %v", err)
    }
    
    // æµ‹è¯•æŸ¥è¯¢ç”¨æˆ·
    found, err := repo.FindByID("123")
    if err != nil {
        t.Fatalf("Failed to find user: %v", err)
    }
    
    if found.ID != user.ID || found.Name != user.Name || found.Email != user.Email {
        t.Errorf("Found user doesn't match saved user. Got %+v, want %+v", found, user)
    }
}
```

### 8.2 ä½¿ç”¨å†…å­˜æ•°æ®åº“
å¯¹äºè½»é‡çº§æµ‹è¯•ï¼Œå¯ä»¥ä½¿ç”¨å†…å­˜æ•°æ®åº“ï¼š

```go
package main

import (
    "database/sql"
    "testing"
    
    _ "github.com/mattn/go-sqlite3"
)

func setupInMemoryDB(t *testing.T) *sql.DB {
    // åˆ›å»ºå†…å­˜æ•°æ®åº“
    db, err := sql.Open("sqlite3", ":memory:")
    if err != nil {
        t.Fatalf("Failed to open in-memory database: %v", err)
    }
    
    // åˆ›å»ºè¡¨
    _, err = db.Exec(`
        CREATE TABLE users (
            id TEXT PRIMARY KEY,
            name TEXT NOT NULL,
            email TEXT NOT NULL UNIQUE
        )
    `)
    if err != nil {
        t.Fatalf("Failed to create users table: %v", err)
    }
    
    return db
}

// æµ‹è¯•ç”¨æˆ·ä»“åº“ï¼ˆä½¿ç”¨SQLiteå†…å­˜æ•°æ®åº“ï¼‰
func TestUserRepositorySQLite(t *testing.T) {
    // è®¾ç½®å†…å­˜æ•°æ®åº“
    db := setupInMemoryDB(t)
    defer db.Close()
    
    // åˆ›å»ºä»“åº“
    repo := NewUserRepository(db)
    
    // æµ‹è¯•ä¿å­˜å’ŒæŸ¥è¯¢ç”¨æˆ·
    // ...ç±»ä¼¼å‰é¢çš„ä¾‹å­
}
```

### 8.3 ä½¿ç”¨SQLæ¨¡æ‹Ÿ
ä½¿ç”¨SQLé©±åŠ¨æ¨¡æ‹Ÿå™¨è¿›è¡Œæ›´è½»é‡çš„æµ‹è¯•ï¼š

```go
package main

import (
    "testing"
    
    "github.com/DATA-DOG/go-sqlmock"
)

func TestUserRepositoryWithMock(t *testing.T) {
    // åˆ›å»ºæ•°æ®åº“æ¨¡æ‹Ÿ
    db, mock, err := sqlmock.New()
    if err != nil {
        t.Fatalf("Failed to create mock: %v", err)
    }
    defer db.Close()
    
    // åˆ›å»ºä»“åº“
    repo := NewUserRepository(db)
    
    // è®¾ç½®é¢„æœŸ
    user := User{
        ID:    "123",
        Name:  "John",
        Email: "john@example.com",
    }
    
    // æ¨¡æ‹Ÿä¿å­˜æ“ä½œ
    mock.ExpectExec("INSERT INTO users").
        WithArgs(user.ID, user.Name, user.Email).
        WillReturnResult(sqlmock.NewResult(1, 1))
    
    // æ‰§è¡Œä¿å­˜
    err = repo.Save(user)
    if err != nil {
        t.Fatalf("Failed to save user: %v", err)
    }
    
    // æ¨¡æ‹ŸæŸ¥è¯¢æ“ä½œ
    rows := sqlmock.NewRows([]string{"id", "name", "email"}).
        AddRow(user.ID, user.Name, user.Email)
    
    mock.ExpectQuery("SELECT (.+) FROM users WHERE id = ?").
        WithArgs(user.ID).
        WillReturnRows(rows)
    
    // æ‰§è¡ŒæŸ¥è¯¢
    found, err := repo.FindByID(user.ID)
    if err != nil {
        t.Fatalf("Failed to find user: %v", err)
    }
    
    if found.ID != user.ID || found.Name != user.Name || found.Email != user.Email {
        t.Errorf("Found user doesn't match. Got %+v, want %+v", found, user)
    }
    
    // ç¡®ä¿æ‰€æœ‰æœŸæœ›éƒ½è¢«æ»¡è¶³
    if err := mock.ExpectationsWereMet(); err != nil {
        t.Errorf("Unfulfilled expectations: %v", err)
    }
}
```

---

## 9. é›†æˆæµ‹è¯•

### 9.1 è®¾ç½®é›†æˆæµ‹è¯•ç¯å¢ƒ
ä½¿ç”¨Dockerå’Œdocker-composeè¿›è¡Œé›†æˆæµ‹è¯•ï¼š

```go
package main

import (
    "database/sql"
    "fmt"
    "os"
    "testing"
    
    _ "github.com/go-sql-driver/mysql"
)

// åªåœ¨é›†æˆæµ‹è¯•ç¯å¢ƒè¿è¡Œ
func TestIntegration(t *testing.T) {
    // æ£€æŸ¥æ˜¯å¦åœ¨é›†æˆæµ‹è¯•ç¯å¢ƒ
    if os.Getenv("INTEGRATION_TEST") != "true" {
        t.Skip("Skipping integration test. Set INTEGRATION_TEST=true to run.")
    }
    
    // è¿æ¥åˆ°é›†æˆæµ‹è¯•æ•°æ®åº“
    // æ³¨æ„ï¼šè¿™é‡Œå‡è®¾docker-composeå·²ç»å¯åŠ¨äº†æ•°æ®åº“
    db, err := sql.Open("mysql", "root:rootpassword@tcp(localhost:3306)/testdb")
    if err != nil {
        t.Fatalf("Failed to connect to integration test database: %v", err)
    }
    defer db.Close()
    
    // æµ‹è¯•çœŸå®çš„æ•°æ®åº“äº¤äº’
    // ...
}
```

åœ¨`docker-compose.yml`ä¸­è®¾ç½®æµ‹è¯•ç¯å¢ƒï¼š

```yaml
version: '3'

services:
  db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: testdb
    ports:
      - "3306:3306"
    
  redis:
    image: redis:6.0
    ports:
      - "6379:6379"
      
  app_tests:
    build:
      context: .
      dockerfile: Dockerfile.test
    environment:
      INTEGRATION_TEST: "true"
      DB_HOST: db
      DB_PORT: 3306
      DB_USER: root
      DB_PASSWORD: rootpassword
      DB_NAME: testdb
      REDIS_HOST: redis
      REDIS_PORT: 6379
    depends_on:
      - db
      - redis
    command: go test -v ./...
```

### 9.2 ç«¯åˆ°ç«¯æµ‹è¯•
ä½¿ç”¨æµ‹è¯•æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯è¿›è¡Œç«¯åˆ°ç«¯æµ‹è¯•ï¼š

```go
package main

import (
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "strings"
    "testing"
)

// ç«¯åˆ°ç«¯æµ‹è¯•
func TestEndToEnd(t *testing.T) {
    // è·³è¿‡ä¸æ˜¯é›†æˆæµ‹è¯•ç¯å¢ƒçš„æƒ…å†µ
    if os.Getenv("INTEGRATION_TEST") != "true" {
        t.Skip("Skipping E2E test. Set INTEGRATION_TEST=true to run.")
    }
    
    // è®¾ç½®æœåŠ¡å™¨
    server := setupTestServer()
    defer server.Close()
    
    // åˆ›å»ºå®¢æˆ·ç«¯
    client := &http.Client{}
    
    // æµ‹è¯•åˆ›å»ºç”¨æˆ·
    userJSON := `{"name":"John","email":"john@example.com"}`
    req, _ := http.NewRequest(http.MethodPost, server.URL+"/users", strings.NewReader(userJSON))
    req.Header.Set("Content-Type", "application/json")
    
    resp, err := client.Do(req)
    if err != nil {
        t.Fatalf("Failed to send request: %v", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusCreated {
        t.Errorf("Expected status %d, got %d", http.StatusCreated, resp.StatusCode)
    }
    
    // è§£æå“åº”
    var createdUser User
    if err := json.NewDecoder(resp.Body).Decode(&createdUser); err != nil {
        t.Fatalf("Failed to decode response: %v", err)
    }
    
    // è·å–ç”¨æˆ·
    req, _ = http.NewRequest(http.MethodGet, server.URL+"/users/"+createdUser.ID, nil)
    resp, err = client.Do(req)
    if err != nil {
        t.Fatalf("Failed to send request: %v", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        t.Errorf("Expected status %d, got %d", http.StatusOK, resp.StatusCode)
    }
    
    // è§£æå“åº”
    var fetchedUser User
    if err := json.NewDecoder(resp.Body).Decode(&fetchedUser); err != nil {
        t.Fatalf("Failed to decode response: %v", err)
    }
    
    if fetchedUser.ID != createdUser.ID || 
       fetchedUser.Name != createdUser.Name || 
       fetchedUser.Email != createdUser.Email {
        t.Errorf("Fetched user doesn't match created user. Got %+v, want %+v", 
                 fetchedUser, createdUser)
    }
}

// è®¾ç½®æµ‹è¯•æœåŠ¡å™¨
func setupTestServer() *httptest.Server {
    // åˆ›å»ºè·¯ç”±
    mux := http.NewServeMux()
    
    // æ³¨å†Œå¤„ç†å™¨
    mux.HandleFunc("/users", handleUsers)
    mux.HandleFunc("/users/", handleUserByID)
    
    // åˆ›å»ºæµ‹è¯•æœåŠ¡å™¨
    return httptest.NewServer(mux)
}
```

---

## 10. æµ‹è¯•å·¥å…·å’Œæ¡†æ¶

### 10.1 æ€§èƒ½åˆ†æå·¥å…·
Goå†…ç½®äº†å¼ºå¤§çš„æ€§èƒ½åˆ†æå·¥å…·ï¼š

```bash
# CPUæ€§èƒ½åˆ†æ
go test -cpuprofile=cpu.prof

# å†…å­˜åˆ†æ
go test -memprofile=mem.prof

# é˜»å¡åˆ†æ
go test -blockprofile=block.prof

# ä½¿ç”¨pprofå·¥å…·åˆ†æ
go tool pprof cpu.prof
go tool pprof -http=:8080 cpu.prof  # åœ¨æµè§ˆå™¨ä¸­æŸ¥çœ‹
```

### 10.2 æµ‹è¯•æ¡†æ¶ä¸è¾…åŠ©åº“
ä¸€äº›æœ‰ç”¨çš„æµ‹è¯•åº“ï¼š

1. **Testify**: æä¾›æ–­è¨€å’Œæ¨¡æ‹ŸåŠŸèƒ½
```go
package main

import (
    "testing"
    
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestWithTestify(t *testing.T) {
    // æ–­è¨€ï¼Œå¤±è´¥ç»§ç»­æµ‹è¯•
    assert.Equal(t, 123, Add(100, 23), "Add function result incorrect")
    assert.NotNil(t, GetUser(1), "GetUser should not return nil")
    
    // è¦æ±‚ï¼Œå¤±è´¥ç«‹å³ç»ˆæ­¢æµ‹è¯•
    user := GetUser(1)
    require.NotNil(t, user, "User must not be nil to continue")
    
    // ç»§ç»­æµ‹è¯•
    assert.Equal(t, "John", user.Name, "User name mismatch")
}
```

2. **Gomock**: ç”Ÿæˆæ¨¡æ‹Ÿ
```bash
# å®‰è£…gomock
go install github.com/golang/mock/mockgen@latest

# ç”Ÿæˆæ¨¡æ‹Ÿ
mockgen -destination=mocks/mock_service.go -package=mocks your/package Service
```

3. **GoConvey**: BDDé£æ ¼æµ‹è¯•
```go
package main

import (
    "testing"
    
    . "github.com/smartystreets/goconvey/convey"
)

func TestWithGoConvey(t *testing.T) {
    Convey("Given a user service", t, func() {
        service := NewUserService()
        
        Convey("When creating a user", func() {
            user, err := service.CreateUser("John", "john@example.com")
            
            Convey("Then the user should be created successfully", func() {
                So(err, ShouldBeNil)
                So(user, ShouldNotBeNil)
                So(user.Name, ShouldEqual, "John")
                So(user.Email, ShouldEqual, "john@example.com")
            })
        })
        
        Convey("When retrieving a user that exists", func() {
            user, err := service.GetUserByID("123")
            
            Convey("Then the user should be returned", func() {
                So(err, ShouldBeNil)
                So(user, ShouldNotBeNil)
            })
        })
    })
}
```

### 10.3 æµ‹è¯•è¦†ç›–ç‡æœåŠ¡
é›†æˆæµ‹è¯•è¦†ç›–ç‡åˆ°CI/CDæµç¨‹ï¼š

```yaml
# GitHub Actions ç¤ºä¾‹
name: Go Tests with Coverage

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Go
      uses: actions/setup-go@v2
      with:
        go-version: 1.16
    
    - name: Test with coverage
      run: go test -race -coverprofile=coverage.txt -covermode=atomic ./...
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v1
      with:
        file: ./coverage.txt
        fail_ci_if_error: true
```

---

## 11. æµ‹è¯•é©±åŠ¨å¼€å‘ (TDD)

### 11.1 TDDæµç¨‹
æµ‹è¯•é©±åŠ¨å¼€å‘çš„åŸºæœ¬æµç¨‹ï¼š

1. **çº¢**ï¼šç¼–å†™ä¸€ä¸ªå¤±è´¥çš„æµ‹è¯•
2. **ç»¿**ï¼šç¼–å†™æœ€å°å®ç°ä½¿æµ‹è¯•é€šè¿‡
3. **é‡æ„**ï¼šæ”¹è¿›ä»£ç ä½†ä¿æŒæµ‹è¯•é€šè¿‡

### 11.2 TDDç¤ºä¾‹
ä½¿ç”¨TDDå¼€å‘ä¸€ä¸ªç®€å•çš„è®¡ç®—å™¨ï¼š

**ç¬¬ä¸€æ­¥ï¼šç¼–å†™æµ‹è¯•ï¼ˆçº¢ï¼‰**
```go
package calculator

import "testing"

func TestAdd(t *testing.T) {
    got := Add(2, 3)
    want := 5
    
    if got != want {
        t.Errorf("Add(2, 3) = %d; want %d", got, want)
    }
}
```

**ç¬¬äºŒæ­¥ï¼šæœ€å°å®ç°ï¼ˆç»¿ï¼‰**
```go
package calculator

func Add(a, b int) int {
    return 5 // æœ€ç®€å•çš„å®ç°ï¼Œä½¿æµ‹è¯•é€šè¿‡
}
```

**ç¬¬ä¸‰æ­¥ï¼šé‡æ„**
```go
package calculator

func Add(a, b int) int {
    return a + b // å®é™…çš„å®ç°
}
```

**ç¬¬å››æ­¥ï¼šæ·»åŠ æ›´å¤šæµ‹è¯•ï¼ˆçº¢ï¼‰**
```go
func TestSubtract(t *testing.T) {
    got := Subtract(5, 3)
    want := 2
    
    if got != want {
        t.Errorf("Subtract(5, 3) = %d; want %d", got, want)
    }
}
```

**ç¬¬äº”æ­¥ï¼šå®ç°æ–°åŠŸèƒ½ï¼ˆç»¿ï¼‰**
```go
func Subtract(a, b int) int {
    return a - b
}
```

**ç¬¬å…­æ­¥ï¼šç»§ç»­æ‰©å±•æµ‹è¯•å’Œå®ç°**
```go
func TestMultiply(t *testing.T) {
    got := Multiply(2, 3)
    want := 6
    
    if got != want {
        t.Errorf("Multiply(2, 3) = %d; want %d", got, want)
    }
}

func Multiply(a, b int) int {
    return a * b
}

func TestDivide(t *testing.T) {
    // æ­£å¸¸é™¤æ³•
    t.Run("normal division", func(t *testing.T) {
        got, err := Divide(6, 3)
        want := 2
        
        if err != nil {
            t.Fatalf("Divide(6, 3) returned error: %v", err)
        }
        
        if got != want {
            t.Errorf("Divide(6, 3) = %d; want %d", got, want)
        }
    })
    
    // é™¤é›¶é”™è¯¯
    t.Run("division by zero", func(t *testing.T) {
        _, err := Divide(6, 0)
        
        if err == nil {
            t.Error("Divide(6, 0) should return error")
        }
    })
}

func Divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}
```

---

## 12. å­¦ä¹ æ£€æŸ¥ç‚¹

- [ ] ç†è§£Goæµ‹è¯•çš„åŸºæœ¬æ¦‚å¿µå’Œå‘½åè§„èŒƒ
- [ ] èƒ½å¤Ÿç¼–å†™è¡¨æ ¼é©±åŠ¨æµ‹è¯•å’Œå­æµ‹è¯•
- [ ] æŒæ¡æµ‹è¯•è¦†ç›–ç‡çš„æµ‹é‡å’Œåˆ†æ
- [ ] èƒ½å¤Ÿç¼–å†™å’Œè¿è¡ŒåŸºå‡†æµ‹è¯•
- [ ] èƒ½å¤Ÿç¼–å†™ç¤ºä¾‹æµ‹è¯•
- [ ] æŒæ¡æ¨¡æ‹Ÿå’Œä¾èµ–æ³¨å…¥æŠ€æœ¯
- [ ] èƒ½å¤Ÿæµ‹è¯•HTTPå¤„ç†å™¨å’Œå®¢æˆ·ç«¯
- [ ] èƒ½å¤Ÿè¿›è¡Œæ•°æ®åº“æµ‹è¯•
- [ ] äº†è§£é›†æˆæµ‹è¯•å’Œç«¯åˆ°ç«¯æµ‹è¯•
- [ ] ç†Ÿæ‚‰å¸¸ç”¨çš„æµ‹è¯•å·¥å…·å’Œæ¡†æ¶
- [ ] ç†è§£å¹¶èƒ½åº”ç”¨æµ‹è¯•é©±åŠ¨å¼€å‘æ–¹æ³•

---

Goè¯­è¨€æä¾›äº†å¼ºå¤§çš„å†…ç½®æµ‹è¯•æ¡†æ¶ï¼Œæ”¯æŒå•å…ƒæµ‹è¯•ã€åŸºå‡†æµ‹è¯•å’Œç¤ºä¾‹æµ‹è¯•ã€‚é€šè¿‡ç¼–å†™å…¨é¢çš„æµ‹è¯•ï¼Œå¯ä»¥æé«˜ä»£ç è´¨é‡ï¼Œå‡å°‘bugï¼Œå¹¶ä½¿ä»£ç æ›´æ˜“äºç»´æŠ¤ã€‚æµ‹è¯•é©±åŠ¨å¼€å‘ä½œä¸ºä¸€ç§å®è·µæ–¹æ³•ï¼Œå¯ä»¥å¸®åŠ©å¼€å‘è€…ç¼–å†™æ›´åŠ æ¸…æ™°ã€ç®€æ´å’Œå¯é çš„ä»£ç ã€‚
