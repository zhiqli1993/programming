# 依赖注入

## 概述
依赖注入是一种设计模式，通过将依赖关系从代码中解耦，提高了程序的可测试性、可维护性和灵活性。在Go语言中，依赖注入通常通过接口实现，使代码更容易测试和扩展。本文将深入探讨依赖注入的原理、实现方法和在Go项目中的最佳实践。

## 依赖注入基础

### 1. 什么是依赖注入

依赖注入是控制反转(IoC)的一种形式，它将创建依赖对象的责任从使用对象转移到外部。在Go中，这通常通过以下方式实现：

1. **构造函数注入**：通过构造函数参数提供依赖
2. **属性注入**：设置结构体字段值
3. **接口注入**：通过接口类型接收依赖

### 2. 依赖注入的优势

1. **解耦**：减少组件之间的紧密耦合
2. **可测试性**：可以轻松模拟依赖，进行单元测试
3. **可维护性**：代码更清晰，职责分明
4. **灵活性**：运行时替换依赖实现，不需要修改代码

### 3. 不使用依赖注入的问题

```go
// 不好的实践：直接创建依赖
type UserService struct{}

func (s *UserService) GetUser(id string) (*User, error) {
    // 直接创建数据库连接
    db, err := sql.Open("postgres", "connection-string")
    if err != nil {
        return nil, err
    }
    defer db.Close()
    
    // 使用db执行查询
    // ...
    
    return &User{ID: id, Name: "John"}, nil
}
```

这种实现存在以下问题：
- 无法单元测试，因为直接依赖数据库
- 无法在不同环境使用不同配置
- 每次调用都创建新连接，性能低下
- 代码重复，违反DRY原则

## Go中的依赖注入实现

### 1. 构造函数注入

最常见的方法是通过构造函数参数提供依赖：

```go
// 定义数据库接口
type Database interface {
    Query(query string, args ...interface{}) ([]map[string]interface{}, error)
    Close() error
}

// UserService依赖Database接口
type UserService struct {
    db Database
}

// 通过构造函数注入依赖
func NewUserService(db Database) *UserService {
    return &UserService{db: db}
}

// 使用注入的依赖
func (s *UserService) GetUser(id string) (*User, error) {
    results, err := s.db.Query("SELECT * FROM users WHERE id = ?", id)
    if err != nil {
        return nil, err
    }
    
    if len(results) == 0 {
        return nil, fmt.Errorf("user not found: %s", id)
    }
    
    user := &User{
        ID:   results[0]["id"].(string),
        Name: results[0]["name"].(string),
    }
    
    return user, nil
}
```

### 2. 属性注入

通过设置结构体字段注入依赖：

```go
type UserService struct {
    DB Database // 公开字段，允许外部设置
}

// 使用
func main() {
    db := NewPostgresDatabase("connection-string")
    userService := &UserService{}
    userService.DB = db // 设置依赖
    
    user, err := userService.GetUser("123")
    // ...
}
```

属性注入在Go中不常用，因为它不能保证依赖被正确设置。

### 3. 函数选项模式注入

使用函数选项模式进行更灵活的依赖注入：

```go
type UserServiceOption func(*UserService)

func WithDatabase(db Database) UserServiceOption {
    return func(s *UserService) {
        s.db = db
    }
}

func WithLogger(logger Logger) UserServiceOption {
    return func(s *UserService) {
        s.logger = logger
    }
}

func NewUserService(options ...UserServiceOption) *UserService {
    // 创建服务并设置默认值
    service := &UserService{
        db:     NewInMemoryDatabase(), // 默认使用内存数据库
        logger: NewNoOpLogger(),       // 默认使用空日志记录器
    }
    
    // 应用选项
    for _, option := range options {
        option(service)
    }
    
    return service
}

// 使用
func main() {
    db := NewPostgresDatabase("connection-string")
    logger := NewConsoleLogger()
    
    // 创建带有指定依赖的服务
    userService := NewUserService(
        WithDatabase(db),
        WithLogger(logger),
    )
    
    // ...
}
```

## 依赖注入框架

### 1. wire

[Wire](https://github.com/google/wire) 是Google开发的编译时依赖注入工具，它通过代码生成消除了运行时反射的需要。

定义wire.go文件：

```go
//+build wireinject

package main

import (
    "github.com/google/wire"
)

// 定义provider
func provideDatabase() Database {
    return NewPostgresDatabase("connection-string")
}

func provideLogger() Logger {
    return NewConsoleLogger()
}

func provideUserService(db Database, logger Logger) *UserService {
    return NewUserService(db, logger)
}

// 定义注入器
func InitializeUserService() *UserService {
    wire.Build(
        provideDatabase,
        provideLogger,
        provideUserService,
    )
    return nil // 将被wire替换
}
```

运行 `wire` 命令生成代码：

```go
// wire_gen.go - 自动生成的代码
func InitializeUserService() *UserService {
    database := provideDatabase()
    logger := provideLogger()
    userService := provideUserService(database, logger)
    return userService
}
```

### 2. dig

[dig](https://pkg.go.dev/go.uber.org/dig) 是Uber开发的运行时依赖注入容器，使用反射在运行时解析依赖关系。

```go
package main

import (
    "go.uber.org/dig"
)

func main() {
    container := dig.New()
    
    // 注册providers
    container.Provide(NewPostgresDatabase)
    container.Provide(NewConsoleLogger)
    container.Provide(NewUserService)
    
    // 解析和执行
    err := container.Invoke(func(service *UserService) {
        user, err := service.GetUser("123")
        // ...
    })
    
    if err != nil {
        panic(err)
    }
}
```

### 3. fx

[fx](https://pkg.go.dev/go.uber.org/fx) 是Uber基于dig构建的依赖注入框架，提供了生命周期管理和更多功能。

```go
package main

import (
    "context"
    "go.uber.org/fx"
    "net/http"
)

func main() {
    app := fx.New(
        // 提供依赖
        fx.Provide(
            NewPostgresDatabase,
            NewConsoleLogger,
            NewUserService,
            NewHTTPServer,
        ),
        // 注册钩子
        fx.Invoke(func(server *http.Server) {
            // 启动HTTP服务器
            go server.ListenAndServe()
        }),
    )
    
    // 启动应用
    app.Start(context.Background())
    defer app.Stop(context.Background())
    
    // 等待应用终止
    select {}
}
```

## 测试中的依赖注入

依赖注入使测试更简单，可以轻松模拟依赖：

```go
// 模拟数据库实现
type MockDatabase struct {
    QueryFunc func(query string, args ...interface{}) ([]map[string]interface{}, error)
}

func (m *MockDatabase) Query(query string, args ...interface{}) ([]map[string]interface{}, error) {
    return m.QueryFunc(query, args...)
}

func (m *MockDatabase) Close() error {
    return nil
}

// 测试用例
func TestUserService_GetUser(t *testing.T) {
    // 创建模拟数据库
    mockDB := &MockDatabase{
        QueryFunc: func(query string, args ...interface{}) ([]map[string]interface{}, error) {
            // 验证查询
            if query != "SELECT * FROM users WHERE id = ?" {
                t.Errorf("Unexpected query: %s", query)
            }
            
            if args[0] != "123" {
                t.Errorf("Unexpected arg: %v", args[0])
            }
            
            // 返回模拟数据
            return []map[string]interface{}{
                {
                    "id":   "123",
                    "name": "Test User",
                },
            }, nil
        },
    }
    
    // 创建测试对象
    userService := NewUserService(mockDB)
    
    // 执行测试
    user, err := userService.GetUser("123")
    
    // 验证结果
    if err != nil {
        t.Errorf("Unexpected error: %v", err)
    }
    
    if user.ID != "123" || user.Name != "Test User" {
        t.Errorf("Unexpected user: %+v", user)
    }
}
```

## 依赖注入的实际案例

### 1. Web应用程序中的依赖注入

下面是一个完整的Web应用程序示例，使用依赖注入组织代码：

```go
package main

import (
    "database/sql"
    "encoding/json"
    "log"
    "net/http"
    
    _ "github.com/lib/pq"
)

// 定义接口
type UserRepository interface {
    GetByID(id string) (*User, error)
    Create(user *User) error
}

type Logger interface {
    Info(format string, args ...interface{})
    Error(format string, args ...interface{})
}

// 数据模型
type User struct {
    ID   string `json:"id"`
    Name string `json:"name"`
}

// 实现PostgreSQL仓库
type PostgresUserRepository struct {
    db *sql.DB
}

func NewPostgresUserRepository(connString string) (*PostgresUserRepository, error) {
    db, err := sql.Open("postgres", connString)
    if err != nil {
        return nil, err
    }
    
    if err := db.Ping(); err != nil {
        return nil, err
    }
    
    return &PostgresUserRepository{db: db}, nil
}

func (r *PostgresUserRepository) GetByID(id string) (*User, error) {
    row := r.db.QueryRow("SELECT id, name FROM users WHERE id = $1", id)
    
    var user User
    if err := row.Scan(&user.ID, &user.Name); err != nil {
        if err == sql.ErrNoRows {
            return nil, nil // 用户不存在
        }
        return nil, err
    }
    
    return &user, nil
}

func (r *PostgresUserRepository) Create(user *User) error {
    _, err := r.db.Exec("INSERT INTO users (id, name) VALUES ($1, $2)", user.ID, user.Name)
    return err
}

// 实现日志记录器
type ConsoleLogger struct{}

func NewConsoleLogger() *ConsoleLogger {
    return &ConsoleLogger{}
}

func (l *ConsoleLogger) Info(format string, args ...interface{}) {
    log.Printf("[INFO] "+format, args...)
}

func (l *ConsoleLogger) Error(format string, args ...interface{}) {
    log.Printf("[ERROR] "+format, args...)
}

// 用户服务
type UserService struct {
    repo   UserRepository
    logger Logger
}

func NewUserService(repo UserRepository, logger Logger) *UserService {
    return &UserService{
        repo:   repo,
        logger: logger,
    }
}

func (s *UserService) GetUser(id string) (*User, error) {
    s.logger.Info("Getting user: %s", id)
    
    user, err := s.repo.GetByID(id)
    if err != nil {
        s.logger.Error("Failed to get user: %v", err)
        return nil, err
    }
    
    if user == nil {
        return nil, nil // 用户不存在
    }
    
    return user, nil
}

func (s *UserService) CreateUser(user *User) error {
    s.logger.Info("Creating user: %+v", user)
    
    if err := s.repo.Create(user); err != nil {
        s.logger.Error("Failed to create user: %v", err)
        return err
    }
    
    return nil
}

// HTTP处理器
type UserHandler struct {
    service *UserService
}

func NewUserHandler(service *UserService) *UserHandler {
    return &UserHandler{service: service}
}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
    id := r.URL.Query().Get("id")
    if id == "" {
        http.Error(w, "Missing user ID", http.StatusBadRequest)
        return
    }
    
    user, err := h.service.GetUser(id)
    if err != nil {
        http.Error(w, "Internal server error", http.StatusInternalServerError)
        return
    }
    
    if user == nil {
        http.Error(w, "User not found", http.StatusNotFound)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}

func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) {
    var user User
    if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
        http.Error(w, "Invalid request body", http.StatusBadRequest)
        return
    }
    
    if user.ID == "" || user.Name == "" {
        http.Error(w, "Missing required fields", http.StatusBadRequest)
        return
    }
    
    if err := h.service.CreateUser(&user); err != nil {
        http.Error(w, "Internal server error", http.StatusInternalServerError)
        return
    }
    
    w.WriteHeader(http.StatusCreated)
}

// 主函数
func main() {
    // 创建依赖
    repo, err := NewPostgresUserRepository("postgres://user:password@localhost/mydb?sslmode=disable")
    if err != nil {
        log.Fatalf("Failed to create repository: %v", err)
    }
    
    logger := NewConsoleLogger()
    
    // 注入依赖
    userService := NewUserService(repo, logger)
    userHandler := NewUserHandler(userService)
    
    // 注册路由
    http.HandleFunc("/users", func(w http.ResponseWriter, r *http.Request) {
        switch r.Method {
        case http.MethodGet:
            userHandler.GetUser(w, r)
        case http.MethodPost:
            userHandler.CreateUser(w, r)
        default:
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        }
    })
    
    // 启动服务器
    log.Println("Starting server on :8080")
    if err := http.ListenAndServe(":8080", nil); err != nil {
        log.Fatalf("Server error: %v", err)
    }
}
```

### 2. 使用Wire的完整示例

项目结构：
```
myapp/
├── cmd/
│   └── server/
│       └── main.go
├── internal/
│   ├── config/
│   │   └── config.go
│   ├── handler/
│   │   └── user.go
│   ├── repository/
│   │   └── user.go
│   └── service/
│       └── user.go
├── wire.go
└── wire_gen.go
```

配置（config/config.go）：
```go
package config

type Config struct {
    DatabaseURL string
    ServerPort  string
}

func NewConfig() *Config {
    return &Config{
        DatabaseURL: "postgres://user:password@localhost/mydb?sslmode=disable",
        ServerPort:  ":8080",
    }
}
```

仓库（repository/user.go）：
```go
package repository

import (
    "database/sql"
    
    _ "github.com/lib/pq"
)

type User struct {
    ID   string
    Name string
}

type UserRepository interface {
    GetByID(id string) (*User, error)
    Create(user *User) error
}

type PostgresUserRepository struct {
    db *sql.DB
}

func NewUserRepository(db *sql.DB) UserRepository {
    return &PostgresUserRepository{db: db}
}

func (r *PostgresUserRepository) GetByID(id string) (*User, error) {
    // 实现...
    return &User{ID: id, Name: "Test User"}, nil
}

func (r *PostgresUserRepository) Create(user *User) error {
    // 实现...
    return nil
}
```

服务（service/user.go）：
```go
package service

import (
    "myapp/internal/repository"
)

type UserService struct {
    repo repository.UserRepository
}

func NewUserService(repo repository.UserRepository) *UserService {
    return &UserService{repo: repo}
}

func (s *UserService) GetUser(id string) (*repository.User, error) {
    return s.repo.GetByID(id)
}

func (s *UserService) CreateUser(user *repository.User) error {
    return s.repo.Create(user)
}
```

处理器（handler/user.go）：
```go
package handler

import (
    "encoding/json"
    "myapp/internal/repository"
    "myapp/internal/service"
    "net/http"
)

type UserHandler struct {
    service *service.UserService
}

func NewUserHandler(service *service.UserService) *UserHandler {
    return &UserHandler{service: service}
}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
    // 实现...
}

func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) {
    // 实现...
}
```

Wire定义（wire.go）：
```go
//+build wireinject

package main

import (
    "database/sql"
    "myapp/internal/config"
    "myapp/internal/handler"
    "myapp/internal/repository"
    "myapp/internal/service"
    "net/http"
    
    "github.com/google/wire"
)

func initDB(cfg *config.Config) (*sql.DB, error) {
    return sql.Open("postgres", cfg.DatabaseURL)
}

func initServer(handler *handler.UserHandler, cfg *config.Config) *http.Server {
    mux := http.NewServeMux()
    mux.HandleFunc("/users", handler.GetUser)
    
    return &http.Server{
        Addr:    cfg.ServerPort,
        Handler: mux,
    }
}

func InitializeServer() (*http.Server, error) {
    wire.Build(
        config.NewConfig,
        initDB,
        repository.NewUserRepository,
        service.NewUserService,
        handler.NewUserHandler,
        initServer,
    )
    return nil, nil
}
```

生成的Wire代码（wire_gen.go）：
```go
// Code generated by Wire. DO NOT EDIT.

package main

import (
    "database/sql"
    "myapp/internal/config"
    "myapp/internal/handler"
    "myapp/internal/repository"
    "myapp/internal/service"
    "net/http"
)

func InitializeServer() (*http.Server, error) {
    configConfig := config.NewConfig()
    db, err := initDB(configConfig)
    if err != nil {
        return nil, err
    }
    userRepository := repository.NewUserRepository(db)
    userService := service.NewUserService(userRepository)
    userHandler := handler.NewUserHandler(userService)
    server := initServer(userHandler, configConfig)
    return server, nil
}
```

主函数（cmd/server/main.go）：
```go
package main

import (
    "log"
    "myapp"
)

func main() {
    server, err := myapp.InitializeServer()
    if err != nil {
        log.Fatalf("Failed to initialize server: %v", err)
    }
    
    log.Printf("Starting server on %s", server.Addr)
    if err := server.ListenAndServe(); err != nil {
        log.Fatalf("Server error: %v", err)
    }
}
```

## 依赖注入最佳实践

### 1. 接口设计原则

1. **接口隔离原则**：接口应该小而专注
   ```go
   // 好的设计：小而专注的接口
   type Reader interface {
       Read(p []byte) (n int, err error)
   }
   
   type Writer interface {
       Write(p []byte) (n int, err error)
   }
   
   // 组合接口
   type ReadWriter interface {
       Reader
       Writer
   }
   ```

2. **依赖倒置原则**：依赖于抽象，不依赖于具体实现
   ```go
   // 高层模块依赖于抽象接口
   type UserService struct {
       repo UserRepository // 接口
   }
   ```

3. **构造函数返回接口**：而不是具体类型
   ```go
   // 返回接口类型
   func NewUserRepository() UserRepository {
       return &PostgresUserRepository{...}
   }
   ```

### 2. 组织依赖

1. **依赖容器**：在应用的入口点组织依赖，避免全局状态
   ```go
   type Application struct {
       UserService  *UserService
       OrderService *OrderService
       // 其他服务...
   }
   
   func NewApplication() *Application {
       db := initDatabase()
       userRepo := NewUserRepository(db)
       orderRepo := NewOrderRepository(db)
       
       return &Application{
           UserService:  NewUserService(userRepo),
           OrderService: NewOrderService(orderRepo, userRepo),
       }
   }
   ```

2. **功能分组**：相关组件组织在一起
   ```go
   // 用户模块
   type UserModule struct {
       Repository UserRepository
       Service    *UserService
       Handler    *UserHandler
   }
   
   func NewUserModule(db *sql.DB) *UserModule {
       repo := NewUserRepository(db)
       service := NewUserService(repo)
       handler := NewUserHandler(service)
       
       return &UserModule{
           Repository: repo,
           Service:    service,
           Handler:    handler,
       }
   }
   ```

### 3. 避免循环依赖

如果A依赖B，B依赖C，C又依赖A，就会出现循环依赖。解决方法：

1. **重新设计**：重新思考组件职责和边界
2. **引入中间层**：创建新的抽象来打破循环
3. **使用事件**：通过事件机制代替直接依赖

```go
// 循环依赖问题
// A -> B -> C -> A

// 解决方案：引入事件系统
type EventBus interface {
    Publish(event string, data interface{})
    Subscribe(event string, handler func(data interface{}))
}

// A依赖EventBus而不是直接依赖C
type ComponentA struct {
    b        *ComponentB
    eventBus EventBus
}

// C通过EventBus间接与A通信
type ComponentC struct {
    eventBus EventBus
}

func (c *ComponentC) DoSomething() {
    // 不直接调用A，而是发布事件
    c.eventBus.Publish("c.event", data)
}
```

### 4. 测试策略

1. **接口模拟**：为依赖创建模拟实现
   ```go
   type MockUserRepository struct {
       GetByIDFunc func(id string) (*User, error)
   }
   
   func (m *MockUserRepository) GetByID(id string) (*User, error) {
       return m.GetByIDFunc(id)
   }
   ```

2. **表格驱动测试**：覆盖多种场景
   ```go
   func TestUserService_GetUser(t *testing.T) {
       tests := []struct {
           name    string
           id      string
           mockFn  func(id string) (*User, error)
           want    *User
           wantErr bool
       }{
           {
               name: "user exists",
               id:   "123",
               mockFn: func(id string) (*User, error) {
                   return &User{ID: "123", Name: "Test"}, nil
               },
               want:    &User{ID: "123", Name: "Test"},
               wantErr: false,
           },
           {
               name: "user not found",
               id:   "456",
               mockFn: func(id string) (*User, error) {
                   return nil, nil
               },
               want:    nil,
               wantErr: false,
           },
           // 更多测试场景...
       }
       
       for _, tt := range tests {
           t.Run(tt.name, func(t *testing.T) {
               // 创建模拟仓库
               mockRepo := &MockUserRepository{
                   GetByIDFunc: tt.mockFn,
               }
               
               // 创建服务
               service := NewUserService(mockRepo)
               
               // 执行测试
               got, err := service.GetUser(tt.id)
               
               // 检查错误
               if (err != nil) != tt.wantErr {
                   t.Errorf("GetUser() error = %v, wantErr %v", err, tt.wantErr)
                   return
               }
               
               // 检查结果
               if !reflect.DeepEqual(got, tt.want) {
                   t.Errorf("GetUser() got = %v, want %v", got, tt.want)
               }
           })
       }
   }
   ```

## 总结

依赖注入是Go语言中实现松耦合、可测试和可维护代码的强大工具。通过接口和构造函数注入，我们可以：

1. **解耦组件**：减少直接依赖，提高代码灵活性
2. **简化测试**：轻松模拟依赖，实现单元测试
3. **提高可维护性**：清晰的依赖关系，容易理解和修改
4. **支持扩展**：运行时替换实现，而不修改代码

在实际项目中，根据复杂度选择手动依赖注入或使用框架如Wire、dig或fx。对于大多数中小型项目，手动依赖注入已经足够，而不需要引入额外的框架复杂性。

## 相关知识点
- [接口和多态](../基础知识/接口和多态.md)
- [设计模式](../设计模式/README.md)
- [代码质量保障](./代码质量保障.md)
- [测试与性能](./测试与性能.md)
- [项目结构与组织](./项目结构与组织.md)
