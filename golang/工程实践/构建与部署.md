# 构建与部署

## 概述
Go语言以其简单高效的构建系统而著称，同时也提供了丰富的部署选项，从传统的二进制部署到现代的容器化和云原生部署。本文档介绍Go项目的构建过程、优化技巧、交叉编译能力以及各种部署策略，帮助开发者选择最适合其项目需求的部署方案。

## 基本构建命令

### 基本构建
```bash
# 构建当前目录下的Go程序
go build

# 构建指定包
go build github.com/username/project/cmd/server

# 构建并指定输出文件名
go build -o myapp main.go

# 构建项目中的所有命令
go build ./...
```

### 编译选项
```bash
# 启用编译优化
go build -ldflags="-s -w" main.go

# 注入版本信息
go build -ldflags="-X main.Version=v1.0.0 -X main.BuildTime=$(date +%Y-%m-%d)" main.go

# 启用内联和优化
go build -gcflags="-N -l" main.go
```

### 交叉编译
```bash
# 编译Linux 64位可执行文件
GOOS=linux GOARCH=amd64 go build -o myapp-linux-amd64 main.go

# 编译Windows 64位可执行文件
GOOS=windows GOARCH=amd64 go build -o myapp-windows-amd64.exe main.go

# 编译macOS ARM可执行文件(M1芯片)
GOOS=darwin GOARCH=arm64 go build -o myapp-darwin-arm64 main.go
```

## 构建自动化

### Makefile示例
```makefile
.PHONY: build clean test

VERSION := $(shell git describe --tags --always --dirty)
BUILD_TIME := $(shell date +%Y-%m-%dT%H:%M:%S)
LDFLAGS := -ldflags "-X main.Version=$(VERSION) -X main.BuildTime=$(BUILD_TIME) -s -w"

build:
	go build $(LDFLAGS) -o bin/myapp cmd/myapp/main.go

build-all: build-linux build-windows build-macos

build-linux:
	GOOS=linux GOARCH=amd64 go build $(LDFLAGS) -o bin/myapp-linux-amd64 cmd/myapp/main.go

build-windows:
	GOOS=windows GOARCH=amd64 go build $(LDFLAGS) -o bin/myapp-windows-amd64.exe cmd/myapp/main.go

build-macos:
	GOOS=darwin GOARCH=amd64 go build $(LDFLAGS) -o bin/myapp-darwin-amd64 cmd/myapp/main.go

test:
	go test -v ./...

clean:
	rm -rf bin/
```

### GoReleaser配置示例
```yaml
# .goreleaser.yml
builds:
  - main: ./cmd/myapp/main.go
    binary: myapp
    ldflags:
      - -s -w
      - -X main.Version={{.Version}}
      - -X main.BuildTime={{.Date}}
    goos:
      - linux
      - windows
      - darwin
    goarch:
      - amd64
      - arm64

archives:
  - format: tar.gz
    name_template: "{{ .ProjectName }}_{{ .Version }}_{{ .Os }}_{{ .Arch }}"
    replacements:
      darwin: macOS
    format_overrides:
      - goos: windows
        format: zip

checksum:
  name_template: "checksums.txt"

changelog:
  sort: asc
  filters:
    exclude:
      - '^docs:'
      - '^test:'
```

## 容器化部署

### 多阶段构建Dockerfile
```dockerfile
# 构建阶段
FROM golang:1.19-alpine AS builder

WORKDIR /app

# 复制go mod文件
COPY go.mod go.sum ./
RUN go mod download

# 复制源代码
COPY . .

# 构建应用
RUN CGO_ENABLED=0 GOOS=linux go build -ldflags="-s -w" -o /app/myapp cmd/myapp/main.go

# 运行阶段
FROM alpine:3.16

# 安装CA证书和时区数据
RUN apk --no-cache add ca-certificates tzdata

# 创建非root用户
RUN adduser -D -g '' appuser

WORKDIR /app

# 从构建阶段复制二进制文件
COPY --from=builder /app/myapp /app/
COPY --from=builder /app/configs /app/configs

# 使用非root用户运行
USER appuser

# 暴露应用端口
EXPOSE 8080

# 启动应用
CMD ["/app/myapp"]
```

### 优化Docker镜像大小
1. 使用多阶段构建
2. 基于alpine或distroless基础镜像
3. 禁用CGO以避免链接动态库
4. 使用ldflags减小二进制体积
5. 只复制必要的配置文件

## 云原生部署

### Kubernetes部署清单
```yaml
# kubernetes/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
  labels:
    app: myapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: registry.example.com/myapp:v1.0.0
        ports:
        - containerPort: 8080
        resources:
          limits:
            cpu: "500m"
            memory: "512Mi"
          requests:
            cpu: "100m"
            memory: "128Mi"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
        env:
        - name: LOG_LEVEL
          value: "info"
        - name: DB_HOST
          valueFrom:
            configMapKeyRef:
              name: myapp-config
              key: db_host
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: myapp-secrets
              key: db_password
```

### Helm Chart目录结构
```
myapp-chart/
├── Chart.yaml              # Chart元数据
├── values.yaml             # 默认配置值
├── templates/              # Kubernetes资源模板
│   ├── deployment.yaml     # 部署定义
│   ├── service.yaml        # 服务定义
│   ├── ingress.yaml        # 入口定义
│   ├── configmap.yaml      # 配置映射
│   ├── secret.yaml         # 密钥
│   └── _helpers.tpl        # 模板辅助函数
└── charts/                 # 依赖Chart
```

## 持续集成/持续部署

### GitHub Actions工作流示例
```yaml
# .github/workflows/build.yml
name: Build and Deploy

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Set up Go
      uses: actions/setup-go@v3
      with:
        go-version: 1.19

    - name: Build
      run: make build

    - name: Test
      run: make test

    - name: Build Docker image
      uses: docker/build-push-action@v3
      with:
        context: .
        push: false
        tags: myapp:latest

    - name: Login to Registry
      if: startsWith(github.ref, 'refs/tags/v')
      uses: docker/login-action@v2
      with:
        registry: ghcr.io
        username: ${{ github.repository_owner }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Push Docker image
      if: startsWith(github.ref, 'refs/tags/v')
      uses: docker/build-push-action@v3
      with:
        context: .
        push: true
        tags: ghcr.io/${{ github.repository_owner }}/myapp:${{ github.ref_name }}
```

## 常见问题与解决方案

1. **二进制过大问题**
   - 问题：Go二进制文件体积较大
   - 解决：使用`-ldflags="-s -w"`移除调试信息，使用`upx`压缩可执行文件

2. **配置管理问题**
   - 问题：不同环境需要不同配置
   - 解决：使用环境变量、配置文件和命令行参数的组合策略

3. **动态库依赖问题**
   - 问题：使用CGO导致动态库依赖
   - 解决：设置`CGO_ENABLED=0`构建静态链接的二进制文件

4. **自动化部署失败**
   - 问题：CI/CD流程中的部署失败
   - 解决：实现金丝雀部署或蓝绿部署策略，增加自动回滚机制

## 进阶内容

### 优化二进制体积
```bash
# 使用upx压缩二进制文件
go build -ldflags="-s -w" -o myapp main.go
upx --best myapp
```

### 应用配置管理
```go
package main

import (
    "flag"
    "os"
    
    "github.com/spf13/viper"
)

func loadConfig() (*Config, error) {
    // 1. 默认配置
    viper.SetDefault("server.port", 8080)
    viper.SetDefault("log.level", "info")
    
    // 2. 配置文件
    viper.SetConfigName("config")
    viper.SetConfigType("yaml")
    viper.AddConfigPath("./configs")
    viper.AddConfigPath(".")
    
    if err := viper.ReadInConfig(); err != nil {
        if _, ok := err.(viper.ConfigFileNotFoundError); !ok {
            return nil, err
        }
    }
    
    // 3. 环境变量
    viper.AutomaticEnv()
    viper.SetEnvPrefix("APP")
    
    // 4. 命令行参数
    port := flag.Int("port", 0, "server port")
    flag.Parse()
    
    if *port != 0 {
        viper.Set("server.port", *port)
    }
    
    var config Config
    if err := viper.Unmarshal(&config); err != nil {
        return nil, err
    }
    
    return &config, nil
}
```

### 蓝绿部署示例
```yaml
# 蓝环境部署
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-blue
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
      version: blue
  template:
    metadata:
      labels:
        app: myapp
        version: blue
    spec:
      containers:
      - name: myapp
        image: registry.example.com/myapp:v1.0.0
---
# 绿环境部署
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-green
spec:
  replicas: 0
  selector:
    matchLabels:
      app: myapp
      version: green
  template:
    metadata:
      labels:
        app: myapp
        version: green
    spec:
      containers:
      - name: myapp
        image: registry.example.com/myapp:v1.1.0
---
# 服务(可以通过更新selector在蓝绿环境间切换)
apiVersion: v1
kind: Service
metadata:
  name: myapp
spec:
  selector:
    app: myapp
    version: blue
  ports:
  - port: 80
    targetPort: 8080
```

## 相关知识点
- [依赖管理](依赖管理.md)
- [项目结构与组织](项目结构与组织.md)
- [日志与监控](日志与监控.md)
