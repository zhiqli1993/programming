# 上下文控制 (Context)

## 概述
`context`包是Go语言中用于跨API边界和进程间传递请求范围值、取消信号和截止时间的标准库。它是Go语言并发控制的核心工具，特别适用于服务器应用程序，可以优雅地处理超时、取消和请求范围的值传递。本文深入探讨`context`包的使用方法、最佳实践和常见模式。

## Context基础

### 1. Context接口

`context.Context`是一个接口，定义如下：

```go
type Context interface {
    // Deadline返回完成工作的截止时间，如果没有设置截止时间，则ok返回false
    Deadline() (deadline time.Time, ok bool)
    
    // Done返回一个通道，当Context被取消或超时时关闭
    Done() <-chan struct{}
    
    // Err返回Context被取消的原因，如果Context尚未被取消，返回nil
    Err() error
    
    // Value返回与key关联的值，如果没有则返回nil
    Value(key interface{}) interface{}
}
```

### 2. 创建Context

`context`包提供了几种创建Context的方法：

```go
// 创建一个空的Context，通常作为所有Context树的根
func Background() Context

// 类似Background()，但用于测试
func TODO() Context

// 创建一个带有取消功能的Context
func WithCancel(parent Context) (ctx Context, cancel CancelFunc)

// 创建一个带有截止时间的Context
func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)

// 创建一个带有超时时间的Context
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)

// 创建一个带有键值对的Context
func WithValue(parent Context, key, val interface{}) Context
```

示例：

```go
// 创建基本Context
ctx := context.Background()

// 创建可取消的Context
ctx, cancel := context.WithCancel(ctx)
defer cancel() // 确保函数退出时取消Context

// 创建有超时的Context
ctx, cancel = context.WithTimeout(ctx, 5*time.Second)
defer cancel()

// 创建有截止时间的Context
deadline := time.Now().Add(10 * time.Second)
ctx, cancel = context.WithDeadline(ctx, deadline)
defer cancel()

// 创建带有值的Context
ctx = context.WithValue(ctx, "user_id", "123")
```

## Context的核心用法

### 1. 取消传播

Context最重要的功能之一是取消传播，使得可以取消整个调用链上的操作：

```go
func main() {
    // 创建可取消的Context
    ctx, cancel := context.WithCancel(context.Background())
    
    // 启动工作goroutine
    go worker(ctx)
    
    // 等待用户输入
    fmt.Println("按任意键停止工作")
    fmt.Scanln()
    
    // 取消Context
    cancel()
    
    // 给工作goroutine一些时间来清理
    time.Sleep(time.Second)
    fmt.Println("主函数退出")
}

func worker(ctx context.Context) {
    // 在后台工作，直到Context被取消
    for {
        select {
        case <-ctx.Done():
            fmt.Println("工作停止：", ctx.Err())
            return
        default:
            fmt.Println("工作中...")
            time.Sleep(500 * time.Millisecond)
        }
    }
}
```

### 2. 超时控制

Context可以用来设置操作超时：

```go
func slowOperation(ctx context.Context) (Result, error) {
    // 创建一个带有超时的Context
    ctx, cancel := context.WithTimeout(ctx, 2*time.Second)
    defer cancel()
    
    // 创建结果通道
    resultCh := make(chan Result, 1)
    errCh := make(chan error, 1)
    
    // 启动工作goroutine
    go func() {
        // 模拟耗时操作
        time.Sleep(3 * time.Second) // 这里故意让它超时
        
        // 发送结果
        resultCh <- Result{Data: "操作完成"}
    }()
    
    // 等待结果或Context取消
    select {
    case result := <-resultCh:
        return result, nil
    case <-ctx.Done():
        return Result{}, ctx.Err() // 返回超时或取消错误
    }
}

func main() {
    ctx := context.Background()
    result, err := slowOperation(ctx)
    if err != nil {
        fmt.Println("操作失败:", err) // 会输出 "操作失败: context deadline exceeded"
        return
    }
    fmt.Println("操作成功:", result)
}
```

### 3. 值传递

Context可以用来传递请求范围的值：

```go
// 定义类型安全的键
type contextKey string

const (
    userIDKey contextKey = "user_id"
    authTokenKey contextKey = "auth_token"
)

func ProcessRequest(ctx context.Context) {
    // 添加值到Context
    ctx = context.WithValue(ctx, userIDKey, "user-123")
    ctx = context.WithValue(ctx, authTokenKey, "token-456")
    
    // 调用需要这些值的函数
    DoSomething(ctx)
}

func DoSomething(ctx context.Context) {
    // 从Context获取值
    userID, ok := ctx.Value(userIDKey).(string)
    if !ok {
        fmt.Println("用户ID不存在或类型不正确")
        return
    }
    
    authToken, ok := ctx.Value(authTokenKey).(string)
    if !ok {
        fmt.Println("认证令牌不存在或类型不正确")
        return
    }
    
    fmt.Printf("处理用户 %s 的请求，令牌: %s\n", userID, authToken)
}
```

## Context的常见模式

### 1. HTTP服务器中使用Context

在HTTP服务器中，每个请求都应该有自己的Context：

```go
func HttpHandler(w http.ResponseWriter, r *http.Request) {
    // 获取请求的Context
    ctx := r.Context()
    
    // 创建带有超时的Context
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()
    
    // 调用可能会花费一些时间的操作
    result, err := doSomeWork(ctx)
    if err != nil {
        if errors.Is(err, context.DeadlineExceeded) {
            http.Error(w, "处理请求超时", http.StatusGatewayTimeout)
        } else if errors.Is(err, context.Canceled) {
            // 客户端可能关闭了连接
            log.Println("客户端取消了请求")
            return
        } else {
            http.Error(w, "内部服务器错误", http.StatusInternalServerError)
        }
        return
    }
    
    // 正常返回结果
    fmt.Fprintf(w, "结果: %v", result)
}

func doSomeWork(ctx context.Context) (string, error) {
    // 创建一个通道来接收结果
    resultCh := make(chan string, 1)
    
    // 在后台执行工作
    go func() {
        // 模拟耗时操作
        time.Sleep(3 * time.Second)
        resultCh <- "工作完成"
    }()
    
    // 等待工作完成或Context取消
    select {
    case result := <-resultCh:
        return result, nil
    case <-ctx.Done():
        return "", ctx.Err()
    }
}
```

### 2. 数据库操作中使用Context

数据库操作应该使用Context进行超时控制：

```go
func GetUserFromDB(ctx context.Context, userID string) (*User, error) {
    // 检查Context是否已经被取消
    if ctx.Err() != nil {
        return nil, ctx.Err()
    }
    
    // 创建查询
    query := "SELECT id, name, email FROM users WHERE id = ?"
    
    // 执行带有Context的查询
    row := db.QueryRowContext(ctx, query, userID)
    
    // 扫描结果
    var user User
    err := row.Scan(&user.ID, &user.Name, &user.Email)
    if err != nil {
        if err == sql.ErrNoRows {
            return nil, fmt.Errorf("user not found: %s", userID)
        }
        return nil, fmt.Errorf("database error: %w", err)
    }
    
    return &user, nil
}
```

### 3. 调用外部API时使用Context

当调用外部API时，应该传递Context以支持取消和超时：

```go
func CallExternalAPI(ctx context.Context, url string) ([]byte, error) {
    // 创建HTTP请求
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return nil, fmt.Errorf("creating request: %w", err)
    }
    
    // 发送请求
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        return nil, fmt.Errorf("sending request: %w", err)
    }
    defer resp.Body.Close()
    
    // 检查状态码
    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
    }
    
    // 读取响应体
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf("reading response: %w", err)
    }
    
    return body, nil
}
```

## Context最佳实践

### 1. 始终将Context作为第一个参数

按照Go的惯例，Context应该作为函数的第一个参数传递：

```go
// 好的方式
func DoSomething(ctx context.Context, arg Arg) error {
    // ...
}

// 不好的方式
func DoSomething(arg Arg, ctx context.Context) error {
    // ...
}
```

### 2. 不要存储Context在结构体中

Context应该作为参数传递，而不是存储在结构体中：

```go
// 好的方式
type Worker struct {
    // ...
}

func (w *Worker) DoWork(ctx context.Context) {
    // ...
}

// 不好的方式
type Worker struct {
    ctx context.Context
    // ...
}
```

### 3. 通过派生传递Context，不要直接传递nil

始终基于现有的Context创建新的Context，不要传递nil：

```go
// 好的方式
func ProcessRequest(ctx context.Context) {
    // 创建派生的Context
    newCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()
    
    DoSomething(newCtx)
}

// 不好的方式
func ProcessRequest(ctx context.Context) {
    DoSomething(nil) // 不要这样做
}
```

### 4. Context应该沿调用链传递

Context应该沿着API调用链传递，确保所有操作都可以被取消：

```go
func HandleRequest(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    
    user, err := GetUser(ctx, userID)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    posts, err := GetUserPosts(ctx, user.ID)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    // ...继续处理
}

func GetUser(ctx context.Context, userID string) (*User, error) {
    // 使用ctx进行数据库查询
    // ...
}

func GetUserPosts(ctx context.Context, userID string) ([]Post, error) {
    // 使用ctx进行数据库查询
    // ...
}
```

### 5. 使用类型安全的键值

当使用`context.WithValue`时，应该使用自定义类型作为键，而不是字符串或内置类型：

```go
// 好的方式
type contextKey int

const (
    userIDKey contextKey = iota
    authTokenKey
)

// 使用
ctx = context.WithValue(ctx, userIDKey, "123")
userID := ctx.Value(userIDKey).(string)

// 不好的方式
ctx = context.WithValue(ctx, "user_id", "123") // 字符串键可能冲突
```

### 6. 总是调用CancelFunc

当使用`WithCancel`、`WithTimeout`或`WithDeadline`时，总是调用返回的cancel函数，通常使用defer：

```go
func ProcessRequest(ctx context.Context) error {
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel() // 即使函数提前返回，也会调用cancel
    
    // ...处理请求
    return nil
}
```

## 实际案例分析

### 1. HTTP服务器完整示例

```go
package main

import (
    "context"
    "encoding/json"
    "log"
    "net/http"
    "time"
)

// User表示用户数据
type User struct {
    ID    string `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

// UserService提供用户相关操作
type UserService struct {
    // 在实际应用中，这里可能有数据库连接等
}

// GetUser获取用户信息
func (s *UserService) GetUser(ctx context.Context, userID string) (*User, error) {
    // 模拟数据库查询延迟
    select {
    case <-time.After(2 * time.Second):
        // 模拟查询结果
        return &User{
            ID:    userID,
            Name:  "John Doe",
            Email: "john@example.com",
        }, nil
    case <-ctx.Done():
        return nil, ctx.Err()
    }
}

// UserHandler处理用户相关HTTP请求
type UserHandler struct {
    userService *UserService
}

// GetUserHandler处理获取用户请求
func (h *UserHandler) GetUserHandler(w http.ResponseWriter, r *http.Request) {
    // 从URL获取用户ID
    userID := r.URL.Query().Get("id")
    if userID == "" {
        http.Error(w, "Missing user ID", http.StatusBadRequest)
        return
    }
    
    // 从请求获取Context，并添加超时
    ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
    defer cancel()
    
    // 获取用户信息
    user, err := h.userService.GetUser(ctx, userID)
    if err != nil {
        if err == context.DeadlineExceeded {
            http.Error(w, "Request timed out", http.StatusGatewayTimeout)
        } else if err == context.Canceled {
            log.Println("Request was canceled by client")
            return // 客户端已断开连接，无需响应
        } else {
            http.Error(w, "Internal server error", http.StatusInternalServerError)
        }
        return
    }
    
    // 返回用户信息
    w.Header().Set("Content-Type", "application/json")
    if err := json.NewEncoder(w).Encode(user); err != nil {
        log.Printf("Error encoding response: %v", err)
    }
}

func main() {
    // 创建用户服务
    userService := &UserService{}
    
    // 创建HTTP处理器
    userHandler := &UserHandler{userService: userService}
    
    // 注册路由
    http.HandleFunc("/users", userHandler.GetUserHandler)
    
    // 创建HTTP服务器
    server := &http.Server{
        Addr:    ":8080",
        Handler: nil, // 使用DefaultServeMux
    }
    
    // 启动服务器
    log.Println("Starting server on :8080")
    if err := server.ListenAndServe(); err != nil {
        log.Fatalf("Server error: %v", err)
    }
}
```

### 2. 多服务调用链示例

```go
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "time"
)

// 用户服务
type UserService struct{}

func (s *UserService) GetUser(ctx context.Context, userID string) (*User, error) {
    // 检查Context是否已经取消
    if ctx.Err() != nil {
        return nil, ctx.Err()
    }
    
    // 模拟数据库查询
    time.Sleep(100 * time.Millisecond)
    
    return &User{ID: userID, Name: "John Doe"}, nil
}

// 订单服务
type OrderService struct{}

func (s *OrderService) GetOrders(ctx context.Context, userID string) ([]Order, error) {
    // 检查Context是否已经取消
    if ctx.Err() != nil {
        return nil, ctx.Err()
    }
    
    // 模拟数据库查询
    time.Sleep(200 * time.Millisecond)
    
    return []Order{
        {ID: "order1", UserID: userID, Amount: 99.99},
        {ID: "order2", UserID: userID, Amount: 49.99},
    }, nil
}

// 支付服务
type PaymentService struct{}

func (s *PaymentService) GetPayments(ctx context.Context, orderIDs []string) ([]Payment, error) {
    // 检查Context是否已经取消
    if ctx.Err() != nil {
        return nil, ctx.Err()
    }
    
    // 模拟外部API调用
    time.Sleep(300 * time.Millisecond)
    
    payments := make([]Payment, 0, len(orderIDs))
    for _, orderID := range orderIDs {
        payments = append(payments, Payment{
            ID:      fmt.Sprintf("payment-%s", orderID),
            OrderID: orderID,
            Status:  "completed",
        })
    }
    
    return payments, nil
}

// 数据模型
type User struct {
    ID   string `json:"id"`
    Name string `json:"name"`
}

type Order struct {
    ID     string  `json:"id"`
    UserID string  `json:"user_id"`
    Amount float64 `json:"amount"`
}

type Payment struct {
    ID      string `json:"id"`
    OrderID string `json:"order_id"`
    Status  string `json:"status"`
}

// 聚合服务
type AggregateService struct {
    userService    *UserService
    orderService   *OrderService
    paymentService *PaymentService
}

// 聚合响应
type AggregateResponse struct {
    User     *User     `json:"user"`
    Orders   []Order   `json:"orders"`
    Payments []Payment `json:"payments"`
}

func (s *AggregateService) GetUserData(ctx context.Context, userID string) (*AggregateResponse, error) {
    // 创建有超时的Context
    ctx, cancel := context.WithTimeout(ctx, 1*time.Second)
    defer cancel()
    
    // 创建响应
    response := &AggregateResponse{}
    
    // 获取用户信息
    user, err := s.userService.GetUser(ctx, userID)
    if err != nil {
        return nil, fmt.Errorf("failed to get user: %w", err)
    }
    response.User = user
    
    // 获取订单信息
    orders, err := s.orderService.GetOrders(ctx, userID)
    if err != nil {
        return nil, fmt.Errorf("failed to get orders: %w", err)
    }
    response.Orders = orders
    
    // 提取订单ID
    orderIDs := make([]string, len(orders))
    for i, order := range orders {
        orderIDs[i] = order.ID
    }
    
    // 获取支付信息
    payments, err := s.paymentService.GetPayments(ctx, orderIDs)
    if err != nil {
        return nil, fmt.Errorf("failed to get payments: %w", err)
    }
    response.Payments = payments
    
    return response, nil
}

// HTTP处理器
func handleUserData(w http.ResponseWriter, r *http.Request) {
    // 获取用户ID
    userID := r.URL.Query().Get("id")
    if userID == "" {
        http.Error(w, "Missing user ID", http.StatusBadRequest)
        return
    }
    
    // 创建服务
    aggregateService := &AggregateService{
        userService:    &UserService{},
        orderService:   &OrderService{},
        paymentService: &PaymentService{},
    }
    
    // 获取聚合数据
    data, err := aggregateService.GetUserData(r.Context(), userID)
    if err != nil {
        if err == context.DeadlineExceeded {
            http.Error(w, "Request timed out", http.StatusGatewayTimeout)
        } else if err == context.Canceled {
            log.Println("Request was canceled by client")
            return
        } else {
            log.Printf("Error: %v", err)
            http.Error(w, "Internal server error", http.StatusInternalServerError)
        }
        return
    }
    
    // 返回数据
    w.Header().Set("Content-Type", "application/json")
    if err := json.NewEncoder(w).Encode(data); err != nil {
        log.Printf("Error encoding response: %v", err)
    }
}

func main() {
    http.HandleFunc("/user-data", handleUserData)
    
    log.Println("Starting server on :8080")
    if err := http.ListenAndServe(":8080", nil); err != nil {
        log.Fatalf("Server error: %v", err)
    }
}
```

### 3. 优雅关闭HTTP服务器

```go
package main

import (
    "context"
    "log"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
)

func main() {
    // 创建路由
    mux := http.NewServeMux()
    mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        time.Sleep(2 * time.Second) // 模拟长时间处理
        w.Write([]byte("Hello, World!"))
    })
    
    // 创建服务器
    server := &http.Server{
        Addr:    ":8080",
        Handler: mux,
    }
    
    // 创建通道接收信号
    done := make(chan os.Signal, 1)
    signal.Notify(done, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)
    
    // 启动服务器
    go func() {
        log.Println("Starting server on :8080")
        if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatalf("Server error: %v", err)
        }
    }()
    
    // 等待中断信号
    <-done
    log.Println("Server is shutting down...")
    
    // 创建带有超时的Context
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    // 优雅关闭服务器
    if err := server.Shutdown(ctx); err != nil {
        log.Fatalf("Server forced to shutdown: %v", err)
    }
    
    log.Println("Server gracefully stopped")
}
```

## 深入理解Context

### 1. Context的内部实现

Go的`context`包提供了几种Context的实现：

1. **emptyCtx**: `Background()`和`TODO()`返回的基础Context
2. **cancelCtx**: 通过`WithCancel()`创建，支持取消
3. **timerCtx**: 通过`WithDeadline()`和`WithTimeout()`创建，支持定时取消
4. **valueCtx**: 通过`WithValue()`创建，存储键值对

这些实现形成了一个树状结构，其中子Context继承父Context的属性，如取消信号和值。

### 2. Context取消的传播机制

Context的取消是通过关闭`Done()`返回的通道来实现的。当一个Context被取消时，它会：

1. 关闭自己的Done通道
2. 对所有子Context递归调用取消函数

这确保了取消信号能够沿着整个Context树传播。

### 3. Context的性能考虑

Context的设计考虑了性能因素：

- 取消操作是非阻塞的
- 值查找的时间复杂度是O(n)，其中n是Context链的长度
- Context是并发安全的，可以被多个goroutine同时使用

然而，过度使用`WithValue()`可能会导致性能问题，因为值查找需要遍历整个Context链。

## 总结

Context是Go语言中处理请求范围控制的强大工具，它提供了：

1. **取消控制**：可以取消整个调用链中的操作
2. **超时控制**：可以设置操作的截止时间或超时时间
3. **值传递**：可以在调用链中传递请求范围的值

使用Context的最佳实践包括：

1. 始终将Context作为第一个参数传递
2. 不要将Context存储在结构体中
3. 通过派生传递Context，不要传递nil
4. Context应该沿调用链传递
5. 使用类型安全的键值
6. 总是调用CancelFunc

遵循这些最佳实践，可以编写出更健壮、更可维护的Go程序，特别是在处理并发、超时和取消等场景时。

## 相关知识点
- [错误处理](../基础知识/错误处理.md)
- [并发编程](../并发编程/README.md)
- [Goroutine基础](../并发编程/Goroutine基础.md)
- [Channel通信](../并发编程/Channel通信.md)
- [标准库/http网络编程](./http网络编程.md)
