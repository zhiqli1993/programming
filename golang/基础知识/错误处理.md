# 错误处理

## 概述
Go语言采用显式的错误处理机制，不同于许多其他语言使用的异常处理模式。在Go中，错误被视为值而非异常，函数通常返回一个错误值，调用者必须显式检查并处理这些错误。这种设计哲学鼓励开发者思考可能的错误情况并明确处理它们，使代码更加健壮和可维护。本文深入探讨Go语言的错误处理机制、最佳实践以及高级模式。

## 基础错误处理

### 1. 错误类型

Go语言中的错误是实现了`error`接口的值。`error`接口只定义了一个方法：

```go
type error interface {
    Error() string
}
```

最简单的错误创建方式是使用`errors`包的`New`函数：

```go
import "errors"

func doSomething() error {
    return errors.New("something went wrong")
}
```

也可以使用`fmt.Errorf`创建格式化的错误消息：

```go
import "fmt"

func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, fmt.Errorf("cannot divide %d by zero", a)
    }
    return a / b, nil
}
```

### 2. 错误检查模式

Go语言的标准错误检查模式是通过比较返回的错误值与`nil`：

```go
result, err := someFunction()
if err != nil {
    // 处理错误
    return err // 或其他错误处理逻辑
}
// 继续处理 result
```

这种模式在Go代码中非常普遍，也被称为"快乐路径"在左，错误处理在右的模式。

### 3. 自定义错误类型

当需要更丰富的错误信息时，可以创建自定义错误类型：

```go
type QueryError struct {
    Query string
    Err   error
}

func (e *QueryError) Error() string {
    return fmt.Sprintf("query error: %q: %v", e.Query, e.Err)
}

// 使用自定义错误
func executeQuery(query string) error {
    if query == "" {
        return &QueryError{Query: query, Err: errors.New("empty query")}
    }
    // ...
    return nil
}
```

## 高级错误处理技巧

### 1. 错误包装与解包

从Go 1.13开始，标准库提供了错误包装和解包的功能：

```go
import (
    "errors"
    "fmt"
)

// 包装错误
func processFile(filename string) error {
    content, err := readFile(filename)
    if err != nil {
        return fmt.Errorf("processing %s: %w", filename, err)
    }
    // 处理文件内容
    return nil
}

// 解包错误
func main() {
    err := processFile("config.json")
    if err != nil {
        // 检查是否是特定类型的错误
        var pathErr *os.PathError
        if errors.As(err, &pathErr) {
            fmt.Printf("Path error: %v\n", pathErr.Path)
        }
        
        // 检查是否包含特定错误
        if errors.Is(err, os.ErrNotExist) {
            fmt.Println("File does not exist")
        }
        
        fmt.Println(err)
    }
}
```

`errors.Is`和`errors.As`函数允许检查错误链中的错误，类似于其他语言的异常类型检查。

### 2. Sentinel错误

Go标准库中定义了一些特定的错误值，称为"sentinel错误"，用于表示特定的错误情况：

```go
// 标准库中的sentinel错误示例
var (
    ErrNotExist = errors.New("file does not exist")
    ErrPermission = errors.New("permission denied")
    ErrInvalid = errors.New("invalid argument")
)

// 使用sentinel错误
func openFile(name string) (*File, error) {
    if name == "" {
        return nil, ErrInvalid
    }
    // ...
}

// 检查sentinel错误
file, err := openFile("")
if err == ErrInvalid {
    // 处理无效参数错误
}
```

### 3. 行为错误

有时我们关心的不是具体的错误类型，而是错误的行为。可以通过接口定义错误的行为：

```go
// 定义一个表示临时错误的接口
type temporary interface {
    Temporary() bool
}

// 使用行为错误
func handleConnection(conn net.Conn) {
    for {
        err := process(conn)
        if err != nil {
            if t, ok := err.(temporary); ok && t.Temporary() {
                // 临时错误，可以重试
                time.Sleep(time.Second)
                continue
            }
            // 永久错误，中断处理
            log.Printf("permanent error: %v", err)
            break
        }
    }
}
```

## 错误处理最佳实践

### 1. 仅处理一次错误

一个常见的错误是多次处理同一个错误，例如记录日志后又返回它：

```go
// 不推荐
func doSomething() error {
    result, err := someFunc()
    if err != nil {
        log.Printf("someFunc error: %v", err) // 记录日志
        return err // 又返回了同一个错误
    }
    // ...
}

// 推荐
func doSomething() error {
    result, err := someFunc()
    if err != nil {
        // 只处理一次：添加上下文并返回
        return fmt.Errorf("someFunc error: %w", err)
    }
    // ...
}
```

### 2. 添加足够的上下文

错误消息应该提供足够的上下文，使调用者能够理解发生了什么：

```go
// 不推荐
func readConfig() error {
    data, err := ioutil.ReadFile("config.json")
    if err != nil {
        return err // 没有提供额外上下文
    }
    // ...
}

// 推荐
func readConfig() error {
    data, err := ioutil.ReadFile("config.json")
    if err != nil {
        return fmt.Errorf("reading config file: %w", err)
    }
    // ...
}
```

### 3. 使用结构化的错误处理

对于大型项目，使用更结构化的错误处理方法可能更有优势：

```go
// 定义错误类型和代码
type ErrorCode int

const (
    ErrUnknown ErrorCode = iota
    ErrNotFound
    ErrPermissionDenied
    ErrInvalidInput
)

// 定义应用错误结构
type AppError struct {
    Code    ErrorCode
    Message string
    Err     error
}

func (e *AppError) Error() string {
    if e.Err != nil {
        return fmt.Sprintf("%s: %v", e.Message, e.Err)
    }
    return e.Message
}

func (e *AppError) Unwrap() error {
    return e.Err
}

// 创建错误辅助函数
func NewNotFoundError(message string, err error) *AppError {
    return &AppError{
        Code:    ErrNotFound,
        Message: message,
        Err:     err,
    }
}

// 使用结构化错误
func getUser(id string) (*User, error) {
    user, err := db.FindUser(id)
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, NewNotFoundError(fmt.Sprintf("user %s not found", id), err)
        }
        return nil, &AppError{Code: ErrUnknown, Message: "database error", Err: err}
    }
    return user, nil
}

// 处理结构化错误
func handleGetUser(w http.ResponseWriter, r *http.Request) {
    id := r.URL.Query().Get("id")
    user, err := getUser(id)
    if err != nil {
        var appErr *AppError
        if errors.As(err, &appErr) {
            switch appErr.Code {
            case ErrNotFound:
                http.Error(w, appErr.Message, http.StatusNotFound)
            case ErrPermissionDenied:
                http.Error(w, appErr.Message, http.StatusForbidden)
            default:
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
            }
            log.Printf("Error getting user: %v", err)
            return
        }
        // 处理非应用错误
        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
        log.Printf("Unexpected error: %v", err)
        return
    }
    // 返回用户信息
    json.NewEncoder(w).Encode(user)
}
```

## panic与recover

Go语言提供了`panic`和`recover`机制，但不同于其他语言的异常处理，它们主要用于处理不可恢复的错误。

### 1. panic

`panic`会导致程序终止正常的控制流，开始执行已注册的`defer`函数，然后退出当前函数，并继续向上传播直到程序崩溃：

```go
func divideByZero() {
    a, b := 10, 0
    fmt.Println(a / b) // 会导致panic
}
```

### 2. recover

`recover`可以捕获`panic`并恢复正常的执行流程，但只能在`defer`函数中调用：

```go
func safeDivide(a, b int) (result int, err error) {
    // 设置recover
    defer func() {
        if r := recover(); r != nil {
            err = fmt.Errorf("division error: %v", r)
        }
    }()
    
    if b == 0 {
        panic("division by zero")
    }
    
    result = a / b
    return result, nil
}

func main() {
    result, err := safeDivide(10, 0)
    if err != nil {
        fmt.Println("Error:", err) // 输出: Error: division error: division by zero
    } else {
        fmt.Println("Result:", result)
    }
}
```

### 3. 何时使用panic/recover

在Go中，应该谨慎使用`panic`和`recover`。以下是一些适当的用例：

- 程序启动时的初始化错误
- 真正的意外情况，如索引越界、nil指针引用等
- 在测试中触发预期的失败

```go
// 初始化错误示例
func initApp() {
    config, err := loadConfig()
    if err != nil {
        panic(fmt.Sprintf("failed to load configuration: %v", err))
    }
    // ...继续初始化
}

// 测试中使用panic
func TestDivide(t *testing.T) {
    defer func() {
        if r := recover(); r == nil {
            t.Error("Expected panic but got none")
        }
    }()
    
    divideByZero() // 预期会panic
}
```

## 错误处理与并发

在并发环境中处理错误需要特别注意，尤其是在使用goroutine时：

```go
func processItems(items []string) error {
    errCh := make(chan error, len(items))
    
    for _, item := range items {
        go func(item string) {
            err := processItem(item)
            errCh <- err
        }(item)
    }
    
    var errs []string
    for i := 0; i < len(items); i++ {
        if err := <-errCh; err != nil {
            errs = append(errs, err.Error())
        }
    }
    
    if len(errs) > 0 {
        return fmt.Errorf("processing errors: %s", strings.Join(errs, "; "))
    }
    
    return nil
}
```

对于更复杂的并发错误处理，可以使用`errgroup`包：

```go
import (
    "context"
    "golang.org/x/sync/errgroup"
)

func processItemsConcurrently(ctx context.Context, items []string) error {
    g, ctx := errgroup.WithContext(ctx)
    
    for _, item := range items {
        item := item // 创建副本，避免闭包问题
        g.Go(func() error {
            select {
            case <-ctx.Done():
                return ctx.Err()
            default:
                return processItem(item)
            }
        })
    }
    
    // 等待所有goroutine完成，并返回第一个非nil错误
    return g.Wait()
}
```

## 实际案例分析

让我们通过一个完整的示例来展示Go错误处理的最佳实践：

```go
package main

import (
    "context"
    "database/sql"
    "encoding/json"
    "errors"
    "fmt"
    "log"
    "net/http"
    "time"
    
    _ "github.com/lib/pq"
)

// 定义错误类型
type ErrorCode int

const (
    ErrUnknown ErrorCode = iota
    ErrNotFound
    ErrDatabase
    ErrInvalidInput
    ErrTimeout
)

// 应用错误结构
type AppError struct {
    Code    ErrorCode
    Message string
    Err     error
}

func (e *AppError) Error() string {
    if e.Err != nil {
        return fmt.Sprintf("%s: %v", e.Message, e.Err)
    }
    return e.Message
}

func (e *AppError) Unwrap() error {
    return e.Err
}

// 用户模型
type User struct {
    ID       string `json:"id"`
    Username string `json:"username"`
    Email    string `json:"email"`
}

// 数据库接口
type UserRepository interface {
    FindByID(ctx context.Context, id string) (*User, error)
    Create(ctx context.Context, user *User) error
}

// PostgreSQL实现
type PostgresUserRepository struct {
    db *sql.DB
}

func NewPostgresUserRepository(connStr string) (*PostgresUserRepository, error) {
    db, err := sql.Open("postgres", connStr)
    if err != nil {
        return nil, fmt.Errorf("connecting to database: %w", err)
    }
    
    // 测试连接
    if err := db.Ping(); err != nil {
        return nil, fmt.Errorf("pinging database: %w", err)
    }
    
    return &PostgresUserRepository{db: db}, nil
}

func (r *PostgresUserRepository) FindByID(ctx context.Context, id string) (*User, error) {
    query := "SELECT id, username, email FROM users WHERE id = $1"
    
    var user User
    err := r.db.QueryRowContext(ctx, query, id).Scan(&user.ID, &user.Username, &user.Email)
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, &AppError{
                Code:    ErrNotFound,
                Message: fmt.Sprintf("user %s not found", id),
                Err:     err,
            }
        }
        return nil, &AppError{
            Code:    ErrDatabase,
            Message: "database error",
            Err:     err,
        }
    }
    
    return &user, nil
}

func (r *PostgresUserRepository) Create(ctx context.Context, user *User) error {
    query := "INSERT INTO users (id, username, email) VALUES ($1, $2, $3)"
    
    _, err := r.db.ExecContext(ctx, query, user.ID, user.Username, user.Email)
    if err != nil {
        return &AppError{
            Code:    ErrDatabase,
            Message: "failed to create user",
            Err:     err,
        }
    }
    
    return nil
}

// 用户服务
type UserService struct {
    repo UserRepository
}

func NewUserService(repo UserRepository) *UserService {
    return &UserService{repo: repo}
}

func (s *UserService) GetUser(ctx context.Context, id string) (*User, error) {
    if id == "" {
        return nil, &AppError{
            Code:    ErrInvalidInput,
            Message: "user ID cannot be empty",
        }
    }
    
    ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
    defer cancel()
    
    user, err := s.repo.FindByID(ctx, id)
    if err != nil {
        // 不需要包装错误，因为repo已经返回了结构化错误
        return nil, err
    }
    
    return user, nil
}

// HTTP处理器
type UserHandler struct {
    service *UserService
}

func NewUserHandler(service *UserService) *UserHandler {
    return &UserHandler{service: service}
}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
    id := r.URL.Query().Get("id")
    
    user, err := h.service.GetUser(r.Context(), id)
    if err != nil {
        handleError(w, err)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    if err := json.NewEncoder(w).Encode(user); err != nil {
        log.Printf("Error encoding response: %v", err)
        http.Error(w, "Error encoding response", http.StatusInternalServerError)
    }
}

// 错误处理辅助函数
func handleError(w http.ResponseWriter, err error) {
    // 记录错误
    log.Printf("Error: %v", err)
    
    var appErr *AppError
    if errors.As(err, &appErr) {
        switch appErr.Code {
        case ErrNotFound:
            http.Error(w, appErr.Message, http.StatusNotFound)
        case ErrInvalidInput:
            http.Error(w, appErr.Message, http.StatusBadRequest)
        case ErrTimeout:
            http.Error(w, "Request timed out", http.StatusGatewayTimeout)
        default:
            http.Error(w, "Internal Server Error", http.StatusInternalServerError)
        }
        return
    }
    
    // 处理上下文取消
    if errors.Is(err, context.Canceled) {
        http.Error(w, "Request canceled", http.StatusBadRequest)
        return
    }
    
    // 处理上下文超时
    if errors.Is(err, context.DeadlineExceeded) {
        http.Error(w, "Request timed out", http.StatusGatewayTimeout)
        return
    }
    
    // 默认情况
    http.Error(w, "Internal Server Error", http.StatusInternalServerError)
}

func main() {
    // 初始化数据库连接
    repo, err := NewPostgresUserRepository("postgres://user:password@localhost/mydb?sslmode=disable")
    if err != nil {
        log.Fatalf("Failed to initialize repository: %v", err)
    }
    
    // 创建服务和处理器
    service := NewUserService(repo)
    handler := NewUserHandler(service)
    
    // 设置路由
    http.HandleFunc("/users", handler.GetUser)
    
    // 启动服务器
    log.Println("Starting server on :8080")
    if err := http.ListenAndServe(":8080", nil); err != nil {
        log.Fatalf("Server error: %v", err)
    }
}
```

## 总结

Go语言的错误处理机制有以下特点：

1. **错误是值**：错误是实现了`error`接口的普通值，而不是特殊的控制流结构。
2. **显式处理**：开发者必须显式检查和处理错误，使代码的错误处理路径清晰。
3. **链式错误**：通过错误包装，可以创建错误链，保留原始错误的同时添加上下文。
4. **结构化错误**：可以创建自定义错误类型，提供更丰富的错误信息。
5. **限制性使用panic**：`panic`和`recover`仅适用于不可恢复的异常情况。

遵循这些最佳实践可以使Go代码更加健壮、可维护和可理解。

## 相关知识点
- [控制结构](./控制结构.md)
- [函数基础](./函数基础.md)
- [接口和多态](./接口和多态.md)
- [并发编程](../并发编程/README.md)
- [测试与调试](../测试与调试/README.md)
