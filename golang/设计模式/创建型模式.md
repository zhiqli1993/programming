# Go语言创建型设计模式

## 概述

创建型设计模式关注对象的创建机制，试图以合适的方式创建对象，以适应不同场景的需求。这些模式在Go语言中因其独特的特性（如组合优于继承、接口隐式实现）而有特殊的实现方式。本文档介绍Go语言中常用的创建型设计模式及其实现方式。

## 单例模式（Singleton Pattern）

单例模式确保一个类只有一个实例，并提供全局访问点。在Go中，可以使用包级变量和`sync.Once`来实现线程安全的单例。

### 实现方式

```go
package singleton

import (
    "sync"
)

// Singleton 是单例对象的接口
type Singleton interface {
    DoSomething()
}

// 具体单例实现
type singleton struct {
    // 单例的字段
    data string
}

func (s *singleton) DoSomething() {
    // 实现单例的方法
}

var (
    instance *singleton
    once     sync.Once
)

// GetInstance 返回单例实例
func GetInstance() Singleton {
    // 确保只初始化一次
    once.Do(func() {
        instance = &singleton{
            data: "单例数据",
        }
    })
    return instance
}
```

### 使用示例

```go
package main

import (
    "fmt"
    "singleton"
)

func main() {
    // 获取单例实例
    instance1 := singleton.GetInstance()
    instance2 := singleton.GetInstance()

    // 验证是否为同一实例
    fmt.Printf("实例相同: %v\n", instance1 == instance2) // 输出: 实例相同: true
}
```

### 何时使用

- 需要严格控制全局资源访问时（如配置管理器、连接池）
- 只需要一个对象实例时（如日志记录器）
- 需要协调对共享资源的操作时

### Go语言特有实现：初始化时创建单例

Go语言的包初始化特性允许我们在`init`函数中创建单例：

```go
package singleton

// Singleton 单例对象
type Singleton struct {
    // 单例的字段
}

// 包级别的单例实例
var instance *Singleton

func init() {
    // 在包初始化时创建单例
    instance = &Singleton{}
}

// GetInstance 返回单例实例
func GetInstance() *Singleton {
    return instance
}
```

## 工厂模式（Factory Pattern）

工厂模式将对象的创建逻辑封装在工厂函数中，而不是直接使用`new`关键字或构造函数。

### 简单工厂

```go
package factory

// Product 是产品接口
type Product interface {
    Use() string
}

// ConcreteProductA 是具体产品A
type ConcreteProductA struct{}

func (p *ConcreteProductA) Use() string {
    return "使用产品A"
}

// ConcreteProductB 是具体产品B
type ConcreteProductB struct{}

func (p *ConcreteProductB) Use() string {
    return "使用产品B"
}

// 简单工厂函数
func CreateProduct(productType string) Product {
    switch productType {
    case "A":
        return &ConcreteProductA{}
    case "B":
        return &ConcreteProductB{}
    default:
        return nil
    }
}
```

### 使用示例

```go
package main

import (
    "fmt"
    "factory"
)

func main() {
    productA := factory.CreateProduct("A")
    fmt.Println(productA.Use()) // 输出: 使用产品A

    productB := factory.CreateProduct("B")
    fmt.Println(productB.Use()) // 输出: 使用产品B
}
```

### 工厂方法模式

工厂方法定义了一个用于创建对象的接口，但让子类决定实例化哪个类。

```go
package factory

// Product 是产品接口
type Product interface {
    GetName() string
}

// Factory 是工厂接口
type Factory interface {
    CreateProduct() Product
}

// ConcreteProductA 是具体产品A
type ConcreteProductA struct{}

func (p *ConcreteProductA) GetName() string {
    return "产品A"
}

// ConcreteProductB 是具体产品B
type ConcreteProductB struct{}

func (p *ConcreteProductB) GetName() string {
    return "产品B"
}

// ConcreteFactoryA 是具体工厂A
type ConcreteFactoryA struct{}

func (f *ConcreteFactoryA) CreateProduct() Product {
    return &ConcreteProductA{}
}

// ConcreteFactoryB 是具体工厂B
type ConcreteFactoryB struct{}

func (f *ConcreteFactoryB) CreateProduct() Product {
    return &ConcreteProductB{}
}
```

### 抽象工厂模式

抽象工厂提供一个接口来创建相关对象的家族，而不指定具体类。

```go
package factory

// Button 接口
type Button interface {
    Paint() string
}

// Checkbox 接口
type Checkbox interface {
    Paint() string
}

// GUIFactory 是GUI工厂接口
type GUIFactory interface {
    CreateButton() Button
    CreateCheckbox() Checkbox
}

// WinButton 是Windows按钮
type WinButton struct{}

func (b *WinButton) Paint() string {
    return "Windows按钮"
}

// WinCheckbox 是Windows复选框
type WinCheckbox struct{}

func (c *WinCheckbox) Paint() string {
    return "Windows复选框"
}

// MacButton 是Mac按钮
type MacButton struct{}

func (b *MacButton) Paint() string {
    return "Mac按钮"
}

// MacCheckbox 是Mac复选框
type MacCheckbox struct{}

func (c *MacCheckbox) Paint() string {
    return "Mac复选框"
}

// WinFactory 是Windows GUI工厂
type WinFactory struct{}

func (f *WinFactory) CreateButton() Button {
    return &WinButton{}
}

func (f *WinFactory) CreateCheckbox() Checkbox {
    return &WinCheckbox{}
}

// MacFactory 是Mac GUI工厂
type MacFactory struct{}

func (f *MacFactory) CreateButton() Button {
    return &MacButton{}
}

func (f *MacFactory) CreateCheckbox() Checkbox {
    return &MacCheckbox{}
}

// CreateFactory 根据操作系统类型创建对应的工厂
func CreateFactory(osType string) GUIFactory {
    switch osType {
    case "Windows":
        return &WinFactory{}
    case "Mac":
        return &MacFactory{}
    default:
        return nil
    }
}
```

### 何时使用工厂模式

- 当对象的创建逻辑复杂，需要集中管理时
- 当客户端代码需要与具体类解耦时
- 当需要根据条件创建不同的对象时
- 当你想为库提供扩展点时

### Go语言特有实现：函数作为工厂

Go语言中，函数是一等公民，可以直接使用函数作为工厂：

```go
package factory

// Product 接口
type Product interface {
    Operation() string
}

// 具体产品类型
type ConcreteProduct struct {
    name string
}

func (p *ConcreteProduct) Operation() string {
    return "操作 " + p.name
}

// 工厂函数类型
type ProductFactory func(name string) Product

// 具体工厂函数
func CreateProduct(name string) Product {
    return &ConcreteProduct{name: name}
}
```

## 建造者模式（Builder Pattern）

建造者模式将复杂对象的构建与其表示分离，使同样的构建过程可以创建不同的表示。

### 传统实现

```go
package builder

// Product 是被构建的产品
type Product struct {
    PartA string
    PartB string
    PartC string
}

// Builder 是构建器接口
type Builder interface {
    BuildPartA()
    BuildPartB()
    BuildPartC()
    GetResult() *Product
}

// ConcreteBuilder 是具体构建器
type ConcreteBuilder struct {
    product *Product
}

func NewConcreteBuilder() *ConcreteBuilder {
    return &ConcreteBuilder{
        product: &Product{},
    }
}

func (b *ConcreteBuilder) BuildPartA() {
    b.product.PartA = "Part A"
}

func (b *ConcreteBuilder) BuildPartB() {
    b.product.PartB = "Part B"
}

func (b *ConcreteBuilder) BuildPartC() {
    b.product.PartC = "Part C"
}

func (b *ConcreteBuilder) GetResult() *Product {
    return b.product
}

// Director 指导构建过程
type Director struct {
    builder Builder
}

func NewDirector(builder Builder) *Director {
    return &Director{
        builder: builder,
    }
}

func (d *Director) Construct() *Product {
    d.builder.BuildPartA()
    d.builder.BuildPartB()
    d.builder.BuildPartC()
    return d.builder.GetResult()
}
```

### Go语言特有实现：方法链式构建器

在Go中，更常见的是使用方法链式API实现建造者模式：

```go
package builder

// ServerConfig 是服务器配置
type ServerConfig struct {
    Host           string
    Port           int
    Timeout        int
    MaxConnections int
    TLS            bool
    Certificate    string
}

// ServerConfigBuilder 是配置构建器
type ServerConfigBuilder struct {
    config *ServerConfig
}

// NewServerConfigBuilder 创建新的构建器
func NewServerConfigBuilder() *ServerConfigBuilder {
    return &ServerConfigBuilder{
        config: &ServerConfig{
            Host:           "localhost", // 默认值
            Port:           8080,        // 默认值
            Timeout:        30,          // 默认值
            MaxConnections: 100,         // 默认值
        },
    }
}

// WithHost 设置主机
func (b *ServerConfigBuilder) WithHost(host string) *ServerConfigBuilder {
    b.config.Host = host
    return b
}

// WithPort 设置端口
func (b *ServerConfigBuilder) WithPort(port int) *ServerConfigBuilder {
    b.config.Port = port
    return b
}

// WithTimeout 设置超时
func (b *ServerConfigBuilder) WithTimeout(timeout int) *ServerConfigBuilder {
    b.config.Timeout = timeout
    return b
}

// WithMaxConnections 设置最大连接数
func (b *ServerConfigBuilder) WithMaxConnections(maxConn int) *ServerConfigBuilder {
    b.config.MaxConnections = maxConn
    return b
}

// WithTLS 启用TLS
func (b *ServerConfigBuilder) WithTLS(cert string) *ServerConfigBuilder {
    b.config.TLS = true
    b.config.Certificate = cert
    return b
}

// Build 构建最终配置
func (b *ServerConfigBuilder) Build() *ServerConfig {
    return b.config
}
```

### 使用示例

```go
package main

import (
    "fmt"
    "builder"
)

func main() {
    // 使用构建器创建配置
    config := builder.NewServerConfigBuilder().
        WithHost("example.com").
        WithPort(443).
        WithTimeout(60).
        WithMaxConnections(1000).
        WithTLS("/path/to/cert.pem").
        Build()
        
    fmt.Printf("服务器配置: %+v\n", config)
}
```

### 函数选项模式（Functional Options Pattern）

函数选项模式是Go中的一种常见构建器模式变体，使用闭包和可变参数来配置对象：

```go
package options

// Server 是服务器配置
type Server struct {
    host           string
    port           int
    timeout        int
    maxConnections int
    tls            bool
    certificate    string
}

// Option 是配置选项函数类型
type Option func(*Server)

// WithHost 设置主机选项
func WithHost(host string) Option {
    return func(s *Server) {
        s.host = host
    }
}

// WithPort 设置端口选项
func WithPort(port int) Option {
    return func(s *Server) {
        s.port = port
    }
}

// WithTimeout 设置超时选项
func WithTimeout(timeout int) Option {
    return func(s *Server) {
        s.timeout = timeout
    }
}

// WithMaxConnections 设置最大连接数选项
func WithMaxConnections(maxConn int) Option {
    return func(s *Server) {
        s.maxConnections = maxConn
    }
}

// WithTLS 设置TLS选项
func WithTLS(cert string) Option {
    return func(s *Server) {
        s.tls = true
        s.certificate = cert
    }
}

// NewServer 创建新服务器，应用所有选项
func NewServer(options ...Option) *Server {
    // 默认配置
    server := &Server{
        host:           "localhost",
        port:           8080,
        timeout:        30,
        maxConnections: 100,
    }
    
    // 应用所有选项
    for _, option := range options {
        option(server)
    }
    
    return server
}
```

### 使用示例

```go
package main

import (
    "fmt"
    "options"
)

func main() {
    // 使用默认配置
    server1 := options.NewServer()
    
    // 使用自定义配置
    server2 := options.NewServer(
        options.WithHost("example.com"),
        options.WithPort(443),
        options.WithTimeout(60),
        options.WithTLS("/path/to/cert.pem"),
    )
    
    fmt.Printf("服务器1: %+v\n", server1)
    fmt.Printf("服务器2: %+v\n", server2)
}
```

### 何时使用建造者模式

- 当需要构建复杂对象，包含多个可选组件时
- 当对象的构建过程需要不同的表示时
- 当需要提供清晰的API来构建对象时
- 当对象有许多配置选项，但大部分是可选的时

## 原型模式（Prototype Pattern）

原型模式通过复制现有对象来创建新对象，而不是通过实例化类。

### 基本实现

```go
package prototype

// Prototype 定义了克隆方法的接口
type Prototype interface {
    Clone() Prototype
}

// ConcretePrototype 是具体原型
type ConcretePrototype struct {
    Name  string
    Value int
    Data  []string
}

// Clone 实现Prototype接口
func (p *ConcretePrototype) Clone() Prototype {
    // 创建深拷贝
    newSlice := make([]string, len(p.Data))
    copy(newSlice, p.Data)
    
    return &ConcretePrototype{
        Name:  p.Name,
        Value: p.Value,
        Data:  newSlice,
    }
}
```

### 使用示例

```go
package main

import (
    "fmt"
    "prototype"
)

func main() {
    original := &prototype.ConcretePrototype{
        Name:  "原型实例",
        Value: 42,
        Data:  []string{"a", "b", "c"},
    }
    
    // 克隆原型
    clone := original.Clone().(*prototype.ConcretePrototype)
    
    // 修改克隆的内容
    clone.Name = "克隆实例"
    clone.Data[0] = "x"
    
    fmt.Printf("原型: %+v\n", original)
    fmt.Printf("克隆: %+v\n", clone)
}
```

### 原型注册表

原型注册表允许客户端根据名称查找和克隆原型：

```go
package prototype

// PrototypeRegistry 是原型注册表
type PrototypeRegistry struct {
    prototypes map[string]Prototype
}

// NewPrototypeRegistry 创建新的注册表
func NewPrototypeRegistry() *PrototypeRegistry {
    return &PrototypeRegistry{
        prototypes: make(map[string]Prototype),
    }
}

// Register 注册原型
func (r *PrototypeRegistry) Register(name string, prototype Prototype) {
    r.prototypes[name] = prototype
}

// Create 根据名称创建原型的克隆
func (r *PrototypeRegistry) Create(name string) Prototype {
    if prototype, ok := r.prototypes[name]; ok {
        return prototype.Clone()
    }
    return nil
}
```

### 使用JSON序列化实现克隆

在Go中，使用JSON或其他序列化方式也可以实现原型模式：

```go
package prototype

import (
    "encoding/json"
)

type Item struct {
    ID    int
    Name  string
    Parts []string
}

// Clone 通过JSON序列化和反序列化实现克隆
func (i *Item) Clone() (*Item, error) {
    // 将对象序列化为JSON
    data, err := json.Marshal(i)
    if err != nil {
        return nil, err
    }
    
    // 创建新实例
    clone := &Item{}
    
    // 反序列化JSON到新实例
    if err := json.Unmarshal(data, clone); err != nil {
        return nil, err
    }
    
    return clone, nil
}
```

### 何时使用原型模式

- 当对象的创建成本高，克隆成本低时
- 当需要创建与已有对象相似的新对象时
- 当想要隐藏创建对象的具体类时
- 当对象的初始状态可能有多种变化时

## 总结

创建型设计模式在Go语言中的实现通常更加简洁，这得益于Go的特性：

1. **单例模式** - 使用包级变量和`sync.Once`实现线程安全的单例
2. **工厂模式** - 利用接口和函数实现对象创建的抽象
3. **建造者模式** - 链式方法调用和函数选项模式提供灵活的对象构建API
4. **原型模式** - 通过接口定义克隆方法或使用序列化技术实现对象复制

在选择创建型模式时，应考虑：

- **灵活性需求** - 是否需要在运行时改变创建对象的方式
- **复杂度** - 对象的创建过程有多复杂
- **可维护性** - 模式是否会增加代码复杂度
- **Go语言特性** - 考虑是否可以使用Go特有的模式变体

创建型模式帮助我们将对象的创建与使用分离，提高代码的灵活性和可维护性。在Go中，这些模式常常能够以更简洁的方式实现，同时保持代码的可读性和效率。

## 推荐阅读

- [Go设计模式](https://github.com/tmrts/go-patterns)
- [Effective Go](https://golang.org/doc/effective_go.html)
- [Go语言高级编程](https://github.com/chai2010/advanced-go-programming-book)
- [设计模式：可复用面向对象软件的基础](https://book.douban.com/subject/1052241/)
