# 行为型模式

## 概述
行为型模式关注对象之间的通信、职责分配和算法封装。这类模式主要用于描述对象之间如何协作以及如何分配职责，使复杂行为更易于管理。在Go语言中，行为型模式特别重要，因为Go强调简单的接口和灵活的组合，这与行为型模式的设计理念高度契合。

## 主要行为型模式

### 1. 责任链模式（Chain of Responsibility Pattern）

责任链模式允许多个对象都有机会处理请求，将请求的发送者和接收者解耦。在Go中，这种模式常用于中间件实现。

```go
// 处理者接口
type Handler interface {
    SetNext(Handler)
    Handle(request string) string
}

// 抽象处理者
type AbstractHandler struct {
    next Handler
}

func (h *AbstractHandler) SetNext(next Handler) {
    h.next = next
}

func (h *AbstractHandler) Handle(request string) string {
    if h.next != nil {
        return h.next.Handle(request)
    }
    return ""
}

// 具体处理者A
type ConcreteHandlerA struct {
    AbstractHandler
}

func (h *ConcreteHandlerA) Handle(request string) string {
    if request == "A" {
        return "处理者A处理了请求"
    }
    return h.AbstractHandler.Handle(request)
}

// 具体处理者B
type ConcreteHandlerB struct {
    AbstractHandler
}

func (h *ConcreteHandlerB) Handle(request string) string {
    if request == "B" {
        return "处理者B处理了请求"
    }
    return h.AbstractHandler.Handle(request)
}

// 客户端代码
func main() {
    handlerA := &ConcreteHandlerA{}
    handlerB := &ConcreteHandlerB{}
    
    handlerA.SetNext(handlerB)
    
    fmt.Println(handlerA.Handle("A"))
    fmt.Println(handlerA.Handle("B"))
    fmt.Println(handlerA.Handle("C"))
}
```

### 2. 命令模式（Command Pattern）

命令模式将请求封装成对象，使不同的请求可以用相同的方式处理，同时支持操作的排队、记录和撤销。在Go中，命令模式常用于实现事件系统和任务队列。

```go
// 命令接口
type Command interface {
    Execute() string
}

// 接收者
type Receiver struct{}

func (r *Receiver) Action() string {
    return "接收者执行操作"
}

// 具体命令
type ConcreteCommand struct {
    receiver *Receiver
}

func NewConcreteCommand(receiver *Receiver) *ConcreteCommand {
    return &ConcreteCommand{receiver: receiver}
}

func (c *ConcreteCommand) Execute() string {
    return "命令: " + c.receiver.Action()
}

// 调用者
type Invoker struct {
    command Command
}

func NewInvoker(command Command) *Invoker {
    return &Invoker{command: command}
}

func (i *Invoker) ExecuteCommand() string {
    return "调用者: " + i.command.Execute()
}

// 客户端代码
func main() {
    receiver := &Receiver{}
    command := NewConcreteCommand(receiver)
    invoker := NewInvoker(command)
    
    fmt.Println(invoker.ExecuteCommand())
}
```

### 3. 解释器模式（Interpreter Pattern）

解释器模式定义一个语言的语法，并提供一个解释器来解释该语言中的句子。在Go中，这种模式常用于实现DSL（领域特定语言）解析器。

```go
// 表达式接口
type Expression interface {
    Interpret(context map[string]bool) bool
}

// 终结符表达式
type TerminalExpression struct {
    variable string
}

func NewTerminalExpression(variable string) *TerminalExpression {
    return &TerminalExpression{variable: variable}
}

func (t *TerminalExpression) Interpret(context map[string]bool) bool {
    return context[t.variable]
}

// 或表达式
type OrExpression struct {
    expr1, expr2 Expression
}

func NewOrExpression(expr1, expr2 Expression) *OrExpression {
    return &OrExpression{expr1: expr1, expr2: expr2}
}

func (o *OrExpression) Interpret(context map[string]bool) bool {
    return o.expr1.Interpret(context) || o.expr2.Interpret(context)
}

// 与表达式
type AndExpression struct {
    expr1, expr2 Expression
}

func NewAndExpression(expr1, expr2 Expression) *AndExpression {
    return &AndExpression{expr1: expr1, expr2: expr2}
}

func (a *AndExpression) Interpret(context map[string]bool) bool {
    return a.expr1.Interpret(context) && a.expr2.Interpret(context)
}

// 客户端代码
func main() {
    // 规则: A或B且C
    terminalA := NewTerminalExpression("A")
    terminalB := NewTerminalExpression("B")
    terminalC := NewTerminalExpression("C")
    
    alternation := NewOrExpression(terminalA, terminalB)
    expression := NewAndExpression(alternation, terminalC)
    
    // 上下文
    context := map[string]bool{
        "A": true,
        "B": false,
        "C": true,
    }
    
    result := expression.Interpret(context)
    fmt.Printf("A或B且C = %v\n", result)
}
```

### 4. 迭代器模式（Iterator Pattern）

迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。Go语言内置对迭代器的支持，通过`range`关键字和`for`循环。

```go
// 迭代器接口
type Iterator interface {
    HasNext() bool
    Next() interface{}
}

// 集合接口
type Collection interface {
    CreateIterator() Iterator
}

// 具体集合
type ConcreteCollection struct {
    items []interface{}
}

func NewConcreteCollection(items []interface{}) *ConcreteCollection {
    return &ConcreteCollection{items: items}
}

func (c *ConcreteCollection) CreateIterator() Iterator {
    return &ConcreteIterator{collection: c, index: 0}
}

// 具体迭代器
type ConcreteIterator struct {
    collection *ConcreteCollection
    index      int
}

func (i *ConcreteIterator) HasNext() bool {
    return i.index < len(i.collection.items)
}

func (i *ConcreteIterator) Next() interface{} {
    if i.HasNext() {
        item := i.collection.items[i.index]
        i.index++
        return item
    }
    return nil
}

// 客户端代码
func main() {
    collection := NewConcreteCollection([]interface{}{"A", "B", "C"})
    iterator := collection.CreateIterator()
    
    for iterator.HasNext() {
        item := iterator.Next()
        fmt.Println(item)
    }
    
    // Go语言内置迭代方式
    fmt.Println("\nGo内置迭代:")
    items := []string{"X", "Y", "Z"}
    for _, item := range items {
        fmt.Println(item)
    }
}
```

### 5. 中介者模式（Mediator Pattern）

中介者模式定义一个对象来封装一组对象之间的交互，从而使这些对象不需要显式地相互引用，降低它们之间的耦合。在Go中，这种模式常用于组件之间的通信。

```go
// 中介者接口
type Mediator interface {
    Notify(sender Colleague, event string)
}

// 同事接口
type Colleague interface {
    SetMediator(mediator Mediator)
}

// 具体中介者
type ConcreteMediator struct {
    colleague1 *ConcreteColleague1
    colleague2 *ConcreteColleague2
}

func (m *ConcreteMediator) Notify(sender Colleague, event string) {
    if sender == m.colleague1 {
        m.colleague2.ReceiveEvent(event)
    } else if sender == m.colleague2 {
        m.colleague1.ReceiveEvent(event)
    }
}

// 具体同事1
type ConcreteColleague1 struct {
    mediator Mediator
}

func (c *ConcreteColleague1) SetMediator(mediator Mediator) {
    c.mediator = mediator
}

func (c *ConcreteColleague1) Send(event string) {
    fmt.Println("同事1发送事件:", event)
    c.mediator.Notify(c, event)
}

func (c *ConcreteColleague1) ReceiveEvent(event string) {
    fmt.Println("同事1收到事件:", event)
}

// 具体同事2
type ConcreteColleague2 struct {
    mediator Mediator
}

func (c *ConcreteColleague2) SetMediator(mediator Mediator) {
    c.mediator = mediator
}

func (c *ConcreteColleague2) Send(event string) {
    fmt.Println("同事2发送事件:", event)
    c.mediator.Notify(c, event)
}

func (c *ConcreteColleague2) ReceiveEvent(event string) {
    fmt.Println("同事2收到事件:", event)
}

// 客户端代码
func main() {
    mediator := &ConcreteMediator{}
    
    colleague1 := &ConcreteColleague1{}
    colleague2 := &ConcreteColleague2{}
    
    mediator.colleague1 = colleague1
    mediator.colleague2 = colleague2
    
    colleague1.SetMediator(mediator)
    colleague2.SetMediator(mediator)
    
    colleague1.Send("你好")
    colleague2.Send("问候")
}
```

### 6. 备忘录模式（Memento Pattern）

备忘录模式在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后恢复对象为先前的状态。在Go中，这种模式常用于实现撤销功能。

```go
// 备忘录
type Memento struct {
    state string
}

func NewMemento(state string) *Memento {
    return &Memento{state: state}
}

func (m *Memento) GetState() string {
    return m.state
}

// 发起人
type Originator struct {
    state string
}

func (o *Originator) SetState(state string) {
    o.state = state
}

func (o *Originator) GetState() string {
    return o.state
}

func (o *Originator) SaveToMemento() *Memento {
    return NewMemento(o.state)
}

func (o *Originator) RestoreFromMemento(memento *Memento) {
    o.state = memento.GetState()
}

// 管理者
type Caretaker struct {
    mementoList []*Memento
}

func (c *Caretaker) Add(memento *Memento) {
    c.mementoList = append(c.mementoList, memento)
}

func (c *Caretaker) Get(index int) *Memento {
    return c.mementoList[index]
}

// 客户端代码
func main() {
    originator := &Originator{}
    caretaker := &Caretaker{}
    
    // 设置状态并保存
    originator.SetState("状态1")
    fmt.Println("当前状态:", originator.GetState())
    caretaker.Add(originator.SaveToMemento())
    
    // 修改状态并保存
    originator.SetState("状态2")
    fmt.Println("当前状态:", originator.GetState())
    caretaker.Add(originator.SaveToMemento())
    
    // 再次修改
    originator.SetState("状态3")
    fmt.Println("当前状态:", originator.GetState())
    
    // 恢复到之前的状态
    originator.RestoreFromMemento(caretaker.Get(1))
    fmt.Println("恢复后状态:", originator.GetState())
    
    originator.RestoreFromMemento(caretaker.Get(0))
    fmt.Println("恢复后状态:", originator.GetState())
}
```

### 7. 观察者模式（Observer Pattern）

观察者模式定义了对象之间的一对多依赖关系，当一个对象状态改变时，所有依赖它的对象都会收到通知并自动更新。在Go中，这种模式常用于事件处理系统。

```go
// 主题接口
type Subject interface {
    Attach(Observer)
    Detach(Observer)
    Notify()
}

// 观察者接口
type Observer interface {
    Update(Subject)
}

// 具体主题
type ConcreteSubject struct {
    observers []Observer
    state     int
}

func NewConcreteSubject() *ConcreteSubject {
    return &ConcreteSubject{
        observers: make([]Observer, 0),
    }
}

func (s *ConcreteSubject) Attach(observer Observer) {
    s.observers = append(s.observers, observer)
}

func (s *ConcreteSubject) Detach(observer Observer) {
    for i, obs := range s.observers {
        if obs == observer {
            s.observers = append(s.observers[:i], s.observers[i+1:]...)
            break
        }
    }
}

func (s *ConcreteSubject) Notify() {
    for _, observer := range s.observers {
        observer.Update(s)
    }
}

func (s *ConcreteSubject) SetState(state int) {
    s.state = state
    s.Notify()
}

func (s *ConcreteSubject) GetState() int {
    return s.state
}

// 具体观察者
type ConcreteObserver struct {
    id    int
    state int
}

func NewConcreteObserver(id int) *ConcreteObserver {
    return &ConcreteObserver{id: id}
}

func (o *ConcreteObserver) Update(subject Subject) {
    if concreteSubject, ok := subject.(*ConcreteSubject); ok {
        o.state = concreteSubject.GetState()
        fmt.Printf("观察者 %d 更新状态为: %d\n", o.id, o.state)
    }
}

// 客户端代码
func main() {
    subject := NewConcreteSubject()
    
    observer1 := NewConcreteObserver(1)
    observer2 := NewConcreteObserver(2)
    
    subject.Attach(observer1)
    subject.Attach(observer2)
    
    subject.SetState(10)
    subject.SetState(20)
    
    subject.Detach(observer1)
    subject.SetState(30)
}
```

### 8. 状态模式（State Pattern）

状态模式允许对象在内部状态改变时改变它的行为，看起来好像修改了它的类。在Go中，这种模式常用于实现有限状态机。

```go
// 状态接口
type State interface {
    Handle(context *Context)
    GetName() string
}

// 上下文
type Context struct {
    state State
}

func NewContext(initialState State) *Context {
    return &Context{state: initialState}
}

func (c *Context) SetState(state State) {
    c.state = state
}

func (c *Context) Request() {
    c.state.Handle(c)
}

// 具体状态A
type ConcreteStateA struct{}

func (s *ConcreteStateA) Handle(context *Context) {
    fmt.Println("状态A处理请求，切换到状态B")
    context.SetState(&ConcreteStateB{})
}

func (s *ConcreteStateA) GetName() string {
    return "状态A"
}

// 具体状态B
type ConcreteStateB struct{}

func (s *ConcreteStateB) Handle(context *Context) {
    fmt.Println("状态B处理请求，切换到状态A")
    context.SetState(&ConcreteStateA{})
}

func (s *ConcreteStateB) GetName() string {
    return "状态B"
}

// 客户端代码
func main() {
    context := NewContext(&ConcreteStateA{})
    
    fmt.Println("当前状态:", context.state.GetName())
    context.Request()
    
    fmt.Println("当前状态:", context.state.GetName())
    context.Request()
    
    fmt.Println("当前状态:", context.state.GetName())
}
```

### 9. 策略模式（Strategy Pattern）

策略模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。在Go中，这种模式常用于实现不同的业务规则。

```go
// 策略接口
type Strategy interface {
    Execute(int, int) int
}

// 具体策略A - 加法
type AddStrategy struct{}

func (s *AddStrategy) Execute(a, b int) int {
    return a + b
}

// 具体策略B - 减法
type SubtractStrategy struct{}

func (s *SubtractStrategy) Execute(a, b int) int {
    return a - b
}

// 具体策略C - 乘法
type MultiplyStrategy struct{}

func (s *MultiplyStrategy) Execute(a, b int) int {
    return a * b
}

// 上下文
type Context struct {
    strategy Strategy
}

func NewContext(strategy Strategy) *Context {
    return &Context{strategy: strategy}
}

func (c *Context) SetStrategy(strategy Strategy) {
    c.strategy = strategy
}

func (c *Context) ExecuteStrategy(a, b int) int {
    return c.strategy.Execute(a, b)
}

// 客户端代码
func main() {
    context := NewContext(&AddStrategy{})
    
    result := context.ExecuteStrategy(10, 5)
    fmt.Println("10 + 5 =", result)
    
    context.SetStrategy(&SubtractStrategy{})
    result = context.ExecuteStrategy(10, 5)
    fmt.Println("10 - 5 =", result)
    
    context.SetStrategy(&MultiplyStrategy{})
    result = context.ExecuteStrategy(10, 5)
    fmt.Println("10 * 5 =", result)
}
```

### 10. 模板方法模式（Template Method Pattern）

模板方法模式定义一个算法的骨架，而将一些步骤延迟到子类中。在Go中，由于没有继承，这种模式通常通过组合和接口实现。

```go
// 抽象模板
type AbstractClass struct {
    hookMethod func() // 钩子方法
}

func (a *AbstractClass) TemplateMethod() {
    a.BaseOperation1()
    
    // 如果设置了钩子方法，则调用
    if a.hookMethod != nil {
        a.hookMethod()
    } else {
        a.RequiredOperation1()
    }
    
    a.BaseOperation2()
}

func (a *AbstractClass) BaseOperation1() {
    fmt.Println("AbstractClass: 基础操作1")
}

func (a *AbstractClass) BaseOperation2() {
    fmt.Println("AbstractClass: 基础操作2")
}

func (a *AbstractClass) RequiredOperation1() {
    fmt.Println("AbstractClass: 默认必要操作1")
}

func (a *AbstractClass) SetHook(hook func()) {
    a.hookMethod = hook
}

// 具体实现
type ConcreteClass struct {
    AbstractClass
}

func NewConcreteClass() *ConcreteClass {
    concrete := &ConcreteClass{}
    // 设置钩子方法
    concrete.AbstractClass.SetHook(concrete.Hook)
    return concrete
}

func (c *ConcreteClass) Hook() {
    fmt.Println("ConcreteClass: 覆盖的钩子方法")
}

// 客户端代码
func main() {
    concrete := NewConcreteClass()
    concrete.TemplateMethod()
}
```

### 11. 访问者模式（Visitor Pattern）

访问者模式表示一个作用于某对象结构中的各元素的操作，使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。在Go中，这种模式通常用于对复杂对象结构的操作。

```go
// 元素接口
type Element interface {
    Accept(visitor Visitor)
}

// 访问者接口
type Visitor interface {
    VisitConcreteElementA(element *ConcreteElementA)
    VisitConcreteElementB(element *ConcreteElementB)
}

// 具体元素A
type ConcreteElementA struct{}

func (e *ConcreteElementA) Accept(visitor Visitor) {
    visitor.VisitConcreteElementA(e)
}

func (e *ConcreteElementA) OperationA() string {
    return "元素A的特有操作"
}

// 具体元素B
type ConcreteElementB struct{}

func (e *ConcreteElementB) Accept(visitor Visitor) {
    visitor.VisitConcreteElementB(e)
}

func (e *ConcreteElementB) OperationB() string {
    return "元素B的特有操作"
}

// 具体访问者1
type ConcreteVisitor1 struct{}

func (v *ConcreteVisitor1) VisitConcreteElementA(element *ConcreteElementA) {
    fmt.Println("访问者1访问"+element.OperationA())
}

func (v *ConcreteVisitor1) VisitConcreteElementB(element *ConcreteElementB) {
    fmt.Println("访问者1访问"+element.OperationB())
}

// 具体访问者2
type ConcreteVisitor2 struct{}

func (v *ConcreteVisitor2) VisitConcreteElementA(element *ConcreteElementA) {
    fmt.Println("访问者2访问"+element.OperationA())
}

func (v *ConcreteVisitor2) VisitConcreteElementB(element *ConcreteElementB) {
    fmt.Println("访问者2访问"+element.OperationB())
}

// 对象结构
type ObjectStructure struct {
    elements []Element
}

func (o *ObjectStructure) Attach(element Element) {
    o.elements = append(o.elements, element)
}

func (o *ObjectStructure) Accept(visitor Visitor) {
    for _, element := range o.elements {
        element.Accept(visitor)
    }
}

// 客户端代码
func main() {
    objectStructure := &ObjectStructure{}
    
    objectStructure.Attach(&ConcreteElementA{})
    objectStructure.Attach(&ConcreteElementB{})
    
    visitor1 := &ConcreteVisitor1{}
    visitor2 := &ConcreteVisitor2{}
    
    fmt.Println("访问者1访问元素:")
    objectStructure.Accept(visitor1)
    
    fmt.Println("\n访问者2访问元素:")
    objectStructure.Accept(visitor2)
}
```

## 行为型模式在Go中的应用场景

1. **责任链模式**: HTTP中间件、请求处理管道、日志记录链
2. **命令模式**: 任务队列、事件系统、撤销/重做功能
3. **解释器模式**: 配置解析器、简单DSL实现、规则引擎
4. **迭代器模式**: 集合遍历、数据流处理、分页查询
5. **中介者模式**: 组件间通信、消息中心、UI控制器
6. **备忘录模式**: 状态保存/恢复、撤销机制、事务回滚
7. **观察者模式**: 事件监听系统、数据绑定、消息发布/订阅
8. **状态模式**: 工作流引擎、游戏状态机、业务流程控制
9. **策略模式**: 算法封装、支付方式选择、验证策略
10. **模板方法模式**: 通用流程定义、框架扩展点
11. **访问者模式**: 复杂数据结构操作、报表生成、AST处理

## Go语言行为型模式的最佳实践

1. **灵活运用接口**: 使用接口定义行为契约，使模式实现更加灵活
2. **注重组合**: 采用组合而非继承来实现行为模式，符合Go的设计哲学
3. **保持简洁**: 避免过度复杂的设计，遵循"少即是多"的原则
4. **适应并发**: 在设计行为模式时考虑Go的并发特性，确保线程安全
5. **利用函数类型**: 使用函数类型和闭包简化某些行为模式的实现
6. **考虑上下文**: 在适当的场景使用context.Context实现请求范围的控制
7. **错误处理**: 合理处理错误，避免在模式实现中使用panic

## 相关知识点
- [创建型模式](创建型模式.md)
- [结构型模式](结构型模式.md)
- [工程实践/项目结构与组织](../工程实践/项目结构与组织.md)
- [并发编程/并发设计模式](../并发编程/并发设计模式.md)
