# 测试最佳实践

## 概述
测试是Go语言开发中不可或缺的一部分，Go语言通过标准库中的`testing`包和内置的工具链提供了强大的测试支持。良好的测试实践不仅能够确保代码质量，还能提高开发效率，简化重构过程，并作为代码的活文档。本文深入探讨Go语言测试的最佳实践、常用技术和模式，帮助开发者编写高质量、可维护的测试代码。

## Go测试基础

### 1. 测试文件命名和组织

Go语言的测试遵循一些约定：

- 测试文件以`_test.go`结尾
- 测试文件与被测代码放在同一个包中
- 测试函数名以`Test`开头，参数为`*testing.T`
- 基准测试函数名以`Benchmark`开头，参数为`*testing.B`
- 示例函数名以`Example`开头，无参数

```go
// 文件: calc.go
package calc

func Add(a, b int) int {
    return a + b
}

// 文件: calc_test.go
package calc

import "testing"

func TestAdd(t *testing.T) {
    sum := Add(2, 3)
    if sum != 5 {
        t.Errorf("Add(2, 3) = %d; want 5", sum)
    }
}

func BenchmarkAdd(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Add(2, 3)
    }
}

func ExampleAdd() {
    sum := Add(2, 3)
    fmt.Println(sum)
    // Output: 5
}
```

### 2. 运行测试

Go提供了多种运行测试的方式：

```bash
# 运行当前包中的所有测试
go test

# 运行特定测试文件
go test calc_test.go calc.go

# 运行特定测试函数
go test -run TestAdd

# 运行匹配模式的测试函数
go test -run "Test(Add|Sub)"

# 运行所有基准测试
go test -bench .

# 运行特定基准测试
go test -bench BenchmarkAdd

# 详细输出
go test -v

# 显示代码覆盖率
go test -cover

# 生成覆盖率分析文件
go test -coverprofile=coverage.out

# 查看覆盖率报告
go tool cover -html=coverage.out
```

### 3. 表格驱动测试

表格驱动测试是Go中常用的测试模式，允许用最少的代码测试多种情况：

```go
func TestAdd(t *testing.T) {
    tests := []struct {
        name     string
        a, b     int
        expected int
    }{
        {"positive", 2, 3, 5},
        {"negative", -2, -3, -5},
        {"mixed", -2, 3, 1},
        {"zero", 0, 0, 0},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := Add(tt.a, tt.b)
            if got != tt.expected {
                t.Errorf("Add(%d, %d) = %d; want %d", tt.a, tt.b, got, tt.expected)
            }
        })
    }
}
```

表格驱动测试的优点：
- 使测试案例清晰可见
- 易于添加新的测试案例
- 代码重复最小化
- 测试失败时提供清晰的上下文

### 4. 子测试

使用`t.Run()`可以创建子测试，这有助于组织复杂的测试并支持只运行特定子测试：

```go
func TestComplex(t *testing.T) {
    t.Run("addition", func(t *testing.T) {
        // 测试加法
    })

    t.Run("subtraction", func(t *testing.T) {
        // 测试减法
    })

    // 嵌套子测试
    t.Run("edge_cases", func(t *testing.T) {
        t.Run("division_by_zero", func(t *testing.T) {
            // 测试除零情况
        })
    })
}
```

运行特定子测试：

```bash
go test -run "TestComplex/addition"
```

### 5. 设置与清理

测试经常需要设置和清理操作，可以使用多种方式实现：

**函数级别**:
```go
func TestDatabase(t *testing.T) {
    // 设置
    db := setupTestDB()
    defer cleanupTestDB(db)

    // 测试逻辑
}
```

**子测试级别**:
```go
func TestSuite(t *testing.T) {
    // 公共设置
    resource := setupResource()
    defer cleanupResource(resource)

    t.Run("test1", func(t *testing.T) {
        // test1特定设置
        // 使用resource
    })

    t.Run("test2", func(t *testing.T) {
        // test2特定设置
        // 使用resource
    })
}
```

**TestMain**:
```go
func TestMain(m *testing.M) {
    // 全局设置
    setup()

    // 运行测试
    code := m.Run()

    // 全局清理
    teardown()

    // 退出
    os.Exit(code)
}
```

## 测试技巧与模式

### 1. 辅助函数

辅助函数可以减少测试中的重复代码并提高可读性：

```go
// 断言辅助函数
func assertEqualInt(t *testing.T, got, want int, msg string) {
    t.Helper() // 标记为辅助函数，错误报告会指向调用位置
    if got != want {
        t.Errorf("%s: got %d, want %d", msg, got, want)
    }
}

// 测试中使用
func TestSomething(t *testing.T) {
    result := Calculate()
    assertEqualInt(t, result, 42, "Calculate() result")
}
```

`t.Helper()`标记很重要，它告诉测试框架这是一个辅助函数，因此错误报告会指向调用辅助函数的位置，而不是辅助函数内部。

### 2. 并行测试

使用`t.Parallel()`可以并行运行测试，提高测试执行速度：

```go
func TestA(t *testing.T) {
    t.Parallel() // 标记此测试可以与其他并行测试并行运行
    // 测试逻辑
}

func TestB(t *testing.T) {
    t.Parallel()
    // 测试逻辑
}
```

但需要确保并行测试之间没有共享状态，或者共享状态是线程安全的。

### 3. 跳过测试

在某些情况下，可能需要有条件地跳过测试：

```go
func TestFeature(t *testing.T) {
    if !featureEnabled() {
        t.Skip("Skipping test because feature is not enabled")
    }
    // 测试逻辑
}

func TestLongRunning(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping long-running test in short mode")
    }
    // 长时间运行的测试
}
```

使用`-short`标志可以跳过长时间运行的测试：

```bash
go test -short
```

### 4. 构建标签

使用构建标签可以控制哪些测试文件被编译和执行：

```go
// +build integration

package mypackage

import "testing"

func TestIntegration(t *testing.T) {
    // 集成测试逻辑
}
```

运行特定标签的测试：

```bash
go test -tags=integration
```

### 5. 测试缓存

Go 1.10引入了测试缓存，默认情况下会缓存成功的测试结果：

```bash
# 强制重新运行测试，不使用缓存
go test -count=1
```

### 6. 测试覆盖率

Go提供了内置的代码覆盖率工具：

```bash
# 显示覆盖率百分比
go test -cover

# 生成覆盖率分析文件
go test -coverprofile=coverage.out

# 生成HTML报告
go tool cover -html=coverage.out -o coverage.html

# 设置覆盖率模式
go test -covermode=count -coverprofile=coverage.out
```

覆盖率模式：
- `set`: 是否执行（默认）
- `count`: 执行次数
- `atomic`: 类似count，但适用于并发代码

## 高级测试实践

### 1. 模拟与打桩

测试常常需要模拟外部依赖，Go通常通过接口和依赖注入实现这一点：

```go
// 定义接口
type Database interface {
    Get(id string) (string, error)
    Save(id, data string) error
}

// 服务依赖于Database接口
type UserService struct {
    db Database
}

func NewUserService(db Database) *UserService {
    return &UserService{db: db}
}

func (s *UserService) GetUser(id string) (string, error) {
    return s.db.Get(id)
}

// 创建模拟实现
type MockDatabase struct {
    GetFunc  func(id string) (string, error)
    SaveFunc func(id, data string) error
}

func (m *MockDatabase) Get(id string) (string, error) {
    return m.GetFunc(id)
}

func (m *MockDatabase) Save(id, data string) error {
    return m.SaveFunc(id, data)
}

// 测试
func TestUserService_GetUser(t *testing.T) {
    mockDB := &MockDatabase{
        GetFunc: func(id string) (string, error) {
            if id == "123" {
                return "user data", nil
            }
            return "", fmt.Errorf("user not found")
        },
    }

    service := NewUserService(mockDB)
    data, err := service.GetUser("123")

    if err != nil {
        t.Errorf("Unexpected error: %v", err)
    }
    
    if data != "user data" {
        t.Errorf("Expected 'user data', got '%s'", data)
    }
}
```

### 2. 表驱动测试的高级用法

表驱动测试可以更加灵活地处理复杂情况：

```go
func TestComplexFunction(t *testing.T) {
    tests := []struct {
        name     string
        input    string
        setup    func() // 测试前设置
        validate func(*testing.T, string, error) // 自定义验证逻辑
        cleanup  func() // 测试后清理
    }{
        {
            name:  "valid input",
            input: "valid",
            setup: func() {
                // 设置测试环境
            },
            validate: func(t *testing.T, output string, err error) {
                if err != nil {
                    t.Errorf("Expected no error, got %v", err)
                }
                if output != "processed" {
                    t.Errorf("Expected 'processed', got '%s'", output)
                }
            },
            cleanup: func() {
                // 清理资源
            },
        },
        // 更多测试用例...
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            if tt.setup != nil {
                tt.setup()
            }
            if tt.cleanup != nil {
                defer tt.cleanup()
            }

            output, err := ComplexFunction(tt.input)
            if tt.validate != nil {
                tt.validate(t, output, err)
            }
        })
    }
}
```

### 3. 测试HTTP服务器

Go的`net/http/httptest`包提供了测试HTTP服务器的工具：

```go
func TestHandler(t *testing.T) {
    // 创建请求
    req, err := http.NewRequest("GET", "/api/users?id=123", nil)
    if err != nil {
        t.Fatal(err)
    }

    // 创建响应记录器
    rr := httptest.NewRecorder()
    handler := http.HandlerFunc(UserHandler)

    // 调用处理函数
    handler.ServeHTTP(rr, req)

    // 检查状态码
    if status := rr.Code; status != http.StatusOK {
        t.Errorf("Handler returned wrong status code: got %v want %v",
            status, http.StatusOK)
    }

    // 检查响应体
    expected := `{"id":"123","name":"John"}`
    if rr.Body.String() != expected {
        t.Errorf("Handler returned unexpected body: got %v want %v",
            rr.Body.String(), expected)
    }
}

// 测试整个服务器
func TestServer(t *testing.T) {
    // 创建测试服务器
    server := httptest.NewServer(http.HandlerFunc(UserHandler))
    defer server.Close()

    // 发送请求到测试服务器
    resp, err := http.Get(server.URL + "/api/users?id=123")
    if err != nil {
        t.Fatal(err)
    }
    defer resp.Body.Close()

    // 检查响应
    if resp.StatusCode != http.StatusOK {
        t.Errorf("Expected status OK; got %v", resp.Status)
    }

    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        t.Fatal(err)
    }

    expected := `{"id":"123","name":"John"}`
    if string(body) != expected {
        t.Errorf("Expected %s; got %s", expected, string(body))
    }
}
```

### 4. 测试数据库交互

测试数据库代码通常使用实际的数据库实例或内存数据库：

```go
func TestDatabaseOperations(t *testing.T) {
    // 创建临时数据库
    db, err := sql.Open("sqlite3", ":memory:")
    if err != nil {
        t.Fatalf("Could not open test database: %v", err)
    }
    defer db.Close()

    // 初始化架构
    _, err = db.Exec(`CREATE TABLE users (id TEXT, name TEXT)`)
    if err != nil {
        t.Fatalf("Could not create table: %v", err)
    }

    // 创建Repository
    repo := NewUserRepository(db)

    // 测试插入
    err = repo.Save("123", "John")
    if err != nil {
        t.Errorf("Failed to save user: %v", err)
    }

    // 测试查询
    name, err := repo.GetNameByID("123")
    if err != nil {
        t.Errorf("Failed to get user: %v", err)
    }
    if name != "John" {
        t.Errorf("Expected name 'John', got '%s'", name)
    }
}
```

对于需要PostgreSQL、MySQL等数据库的测试，可以使用Docker容器：

```go
func TestWithRealDatabase(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping integration test")
    }

    // 使用Docker API或执行命令启动容器
    // ...

    // 建立连接
    db, err := sql.Open("postgres", "postgres://user:pass@localhost:5432/testdb")
    if err != nil {
        t.Fatal(err)
    }
    defer db.Close()

    // 测试代码
    // ...

    // 清理
    // 停止和删除Docker容器
}
```

### 5. 基准测试高级用法

基准测试可以用于比较不同实现的性能：

```go
func BenchmarkMethod1(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Method1()
    }
}

func BenchmarkMethod2(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Method2()
    }
}
```

基准测试可以使用不同的输入大小测试性能扩展性：

```go
func BenchmarkSearch(b *testing.B) {
    sizes := []int{100, 1000, 10000}
    for _, size := range sizes {
        b.Run(fmt.Sprintf("size-%d", size), func(b *testing.B) {
            data := generateData(size)
            b.ResetTimer() // 重置计时器，不包括数据生成时间
            for i := 0; i < b.N; i++ {
                Search(data, "needle")
            }
        })
    }
}
```

内存分配统计：

```bash
go test -bench=. -benchmem
```

### 6. 模糊测试(Fuzzing)

Go 1.18引入了内置的模糊测试支持，可以自动生成测试输入查找边界情况：

```go
func FuzzReverse(f *testing.F) {
    testcases := []string{"Hello, world", " ", "!12345"}
    for _, tc := range testcases {
        f.Add(tc) // 提供种子输入
    }
    
    f.Fuzz(func(t *testing.T, orig string) {
        rev := Reverse(orig)
        doubleRev := Reverse(rev)
        
        if orig != doubleRev {
            t.Errorf("Before: %q, after: %q", orig, doubleRev)
        }
        if utf8.ValidString(orig) && !utf8.ValidString(rev) {
            t.Errorf("Reverse produced invalid UTF-8 string %q", rev)
        }
    })
}
```

运行模糊测试：

```bash
go test -fuzz=Fuzz
```

## 测试最佳实践

### 1. 测试命名与组织

**命名约定**:
- 测试函数应该命名为`Test<FunctionName>`
- 测试文件应该命名为`<filename>_test.go`
- 子测试应该有描述性名称

**组织测试**:
- 按功能组织测试
- 使用子测试分组相关测试
- 提取公共测试逻辑到辅助函数

### 2. 编写有效的测试

**清晰的失败消息**:
```go
// 不好的失败消息
if got != want {
    t.Error("Failed")
}

// 好的失败消息
if got != want {
    t.Errorf("Calculate() = %v, want %v", got, want)
}
```

**测试一个功能点**:
每个测试函数应该关注一个功能点，这样当测试失败时，问题更容易定位。

**避免逻辑在测试中**:
测试中的条件逻辑应该最小化，避免测试本身出错。

**输入和期望明确**:
使用表格驱动测试使输入和预期输出更加明确。

### 3. 测试覆盖率目标

覆盖率是一个有用的指标，但不应该是唯一目标：
- 关注核心业务逻辑的覆盖率
- 针对边界条件和错误路径编写测试
- 平衡覆盖率和测试质量

覆盖率目标因项目而异，通常在70%到90%之间是合理的。

### 4. 测试速度优化

慢测试会降低开发效率：
- 使用`t.Parallel()`并行运行独立测试
- 使用内存数据库代替真实数据库
- 避免不必要的设置和清理
- 使用`-short`标志跳过长时间运行的测试
- 使用测试缓存避免重复运行未更改的测试

### 5. 测试与CI/CD集成

将测试集成到持续集成流程中：
- 在每次提交时运行测试
- 根据环境运行不同级别的测试
- 存储测试结果和覆盖率报告
- 设置覆盖率阈值

```yaml
# .github/workflows/test.yml 示例
name: Go Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - uses: actions/setup-go@v2
      with:
        go-version: '1.18'
    - name: Unit Tests
      run: go test ./... -v
    - name: Integration Tests
      run: go test ./... -tags=integration -v
    - name: Coverage
      run: |
        go test ./... -coverprofile=coverage.out
        go tool cover -html=coverage.out -o coverage.html
    - name: Upload Coverage
      uses: actions/upload-artifact@v2
      with:
        name: code-coverage
        path: coverage.html
```

## 常见测试模式

### 1. 黑盒与白盒测试

Go允许在同一个包中进行白盒测试，或者在`_test`包中进行黑盒测试：

```go
// 白盒测试: 与被测代码同一个包
package mypackage

import "testing"

func TestSomething(t *testing.T) {
    // 可以访问包内私有函数和变量
}

// 黑盒测试: 使用 _test 后缀
package mypackage_test

import (
    "testing"
    "example.com/mypackage"
)

func TestSomething(t *testing.T) {
    // 只能访问公开的API
}
```

### 2. 测试替身(Test Double)

测试替身分为几种类型：

**Stub**: 提供预定义的响应
```go
type StubUserRepository struct{}

func (s *StubUserRepository) GetUser(id string) (*User, error) {
    return &User{ID: id, Name: "Stub User"}, nil
}
```

**Mock**: 记录交互并验证
```go
type MockUserRepository struct {
    GetUserCalled bool
    GetUserID     string
}

func (m *MockUserRepository) GetUser(id string) (*User, error) {
    m.GetUserCalled = true
    m.GetUserID = id
    return &User{ID: id, Name: "Mock User"}, nil
}

// 验证
if !mockRepo.GetUserCalled {
    t.Error("GetUser was not called")
}
if mockRepo.GetUserID != "123" {
    t.Errorf("GetUser called with %s, want 123", mockRepo.GetUserID)
}
```

**Fake**: 简化版实现
```go
type FakeUserRepository struct {
    users map[string]*User
}

func NewFakeUserRepository() *FakeUserRepository {
    return &FakeUserRepository{
        users: make(map[string]*User),
    }
}

func (f *FakeUserRepository) GetUser(id string) (*User, error) {
    user, ok := f.users[id]
    if !ok {
        return nil, fmt.Errorf("user not found")
    }
    return user, nil
}

func (f *FakeUserRepository) SaveUser(user *User) error {
    f.users[user.ID] = user
    return nil
}
```

### 3. 测试容器模式

将测试资源封装到可重用的容器中：

```go
type TestContainer struct {
    DB     *sql.DB
    Server *httptest.Server
    Client *http.Client
    Cleanup func()
}

func NewTestContainer(t *testing.T) *TestContainer {
    // 设置数据库
    db, err := sql.Open("sqlite3", ":memory:")
    if err != nil {
        t.Fatalf("Failed to open DB: %v", err)
    }
    
    // 初始化数据库
    // ...
    
    // 设置服务器
    handler := NewHandler(db)
    server := httptest.NewServer(handler)
    
    // 创建客户端
    client := server.Client()
    
    // 返回容器
    return &TestContainer{
        DB:     db,
        Server: server,
        Client: client,
        Cleanup: func() {
            server.Close()
            db.Close()
        },
    }
}

// 使用
func TestAPI(t *testing.T) {
    container := NewTestContainer(t)
    defer container.Cleanup()
    
    // 使用 container.Client 进行API测试
}
```

### 4. 表格驱动BDD风格测试

结合表格驱动测试和行为驱动开发(BDD)风格：

```go
func TestUserService(t *testing.T) {
    // 定义测试用例
    tests := []struct {
        description string
        given       func() (*UserService, *MockUserRepo)
        when        func(*UserService) (interface{}, error)
        then        func(*testing.T, interface{}, error)
    }{
        {
            description: "should return user when user exists",
            given: func() (*UserService, *MockUserRepo) {
                mockRepo := &MockUserRepo{
                    GetUserFn: func(id string) (*User, error) {
                        return &User{ID: "123", Name: "John"}, nil
                    },
                }
                service := NewUserService(mockRepo)
                return service, mockRepo
            },
            when: func(service *UserService) (interface{}, error) {
                return service.GetUser("123")
            },
            then: func(t *testing.T, result interface{}, err error) {
                if err != nil {
                    t.Errorf("Expected no error, got %v", err)
                }
                user, ok := result.(*User)
                if !ok {
                    t.Fatal("Result is not a User")
                }
                if user.ID != "123" || user.Name != "John" {
                    t.Errorf("Got unexpected user: %+v", user)
                }
            },
        },
        // 更多测试用例...
    }

    // 执行测试
    for _, tt := range tests {
        t.Run(tt.description, func(t *testing.T) {
            service, _ := tt.given()
            result, err := tt.when(service)
            tt.then(t, result, err)
        })
    }
}
```

### 5. 属性测试

验证代码满足某些属性而不是特定输出：

```go
func TestSortProperties(t *testing.T) {
    // 测试排序算法的属性
    
    // 1. 排序后长度不变
    t.Run("length_invariant", func(t *testing.T) {
        for i := 0; i < 100; i++ {
            input := generateRandomSlice(rand.Intn(1000))
            original := make([]int, len(input))
            copy(original, input)
            
            Sort(input)
            
            if len(input) != len(original) {
                t.Errorf("Sort changed slice length: before %d, after %d", 
                    len(original), len(input))
            }
        }
    })
    
    // 2. 排序后元素是有序的
    t.Run("sorted_property", func(t *testing.T) {
        for i := 0; i < 100; i++ {
            input := generateRandomSlice(rand.Intn(1000))
            Sort(input)
            
            for j := 1; j < len(input); j++ {
                if input[j] < input[j-1] {
                    t.Errorf("Slice not sorted at index %d: %v", j, input)
                    break
                }
            }
        }
    })
    
    // 3. 排序是稳定的
    t.Run("stability_property", func(t *testing.T) {
        // 测试排序稳定性...
    })
}

func generateRandomSlice(n int) []int {
    result := make([]int, n)
    for i := range result {
        result[i] = rand.Intn(10000)
    }
    return result
}
```

## 测试高级工具

### 1. 第三方测试库

除了标准库外，Go还有许多有用的第三方测试库：

**testify**: 提供断言和模拟功能
```go
import (
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
)

func TestSomething(t *testing.T) {
    // 断言
    result := Calculate(2, 3)
    assert.Equal(t, 5, result, "They should be equal")
    assert.NotNil(t, object)
    assert.True(t, condition)
    
    // 模拟
    mockObj := new(MyMockedObject)
    mockObj.On("DoSomething", 123).Return(true, nil)
    
    // 使用模拟对象
    result, err := mockObj.DoSomething(123)
    
    // 验证
    mockObj.AssertExpectations(t)
}
```

**gomock**: Google的模拟框架
```go
//go:generate mockgen -source=user_repository.go -destination=mock_user_repository.go -package=repository

func TestUserService(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    
    mockRepo := repository.NewMockUserRepository(ctrl)
    mockRepo.EXPECT().GetUser("123").Return(&User{ID: "123", Name: "John"}, nil)
    
    service := NewUserService(mockRepo)
    user, err := service.GetUser("123")
    
    if err != nil {
        t.Errorf("Expected no error, got %v", err)
    }
    if user.Name != "John" {
        t.Errorf("Expected name 'John', got '%s'", user.Name)
    }
}
```

**ginkgo**: BDD风格测试框架
```go
import (
    . "github.com/onsi/ginkgo"
    . "github.com/onsi/gomega"
)

var _ = Describe("Calculator", func() {
    var calc *Calculator
    
    BeforeEach(func() {
        calc = NewCalculator()
    })
    
    Describe("Add", func() {
        It("should add two numbers", func() {
            result := calc.Add(2, 3)
            Expect(result).To(Equal(5))
        })
        
        It("should handle negative numbers", func() {
            result := calc.Add(-2, -3)
            Expect(result).To(Equal(-5))
        })
    })
})
```

### 2. 基于属性的测试

**go-quickcheck**: 基于属性的测试
```go
import (
    "testing"
    "github.com/leanovate/gopter"
    "github.com/leanovate/gopter/gen"
    "github.com/leanovate/gopter/prop"
)

func TestReverse(t *testing.T) {
    parameters := gopter.DefaultTestParameters()
    parameters.MinSuccessfulTests = 1000
    
    properties := gopter.NewProperties(parameters)
    
    properties.Property("reverse twice is identity", prop.ForAll(
        func(s string) bool {
            reversed := Reverse(s)
            doubleReversed := Reverse(reversed)
            return s == doubleReversed
        },
        gen.AnyString(),
    ))
    
    properties.TestingRun(t)
}
```

### 3. 性能分析

**pprof**: Go的内置性能分析工具
```go
import (
    "testing"
    "os"
    "runtime/pprof"
)

func TestMain(m *testing.M) {
    // CPU分析
    cpuProfile, _ := os.Create("cpu.pprof")
    pprof.StartCPUProfile(cpuProfile)
    defer pprof.StopCPUProfile()
    
    // 运行测试
    code := m.Run()
    
    // 内存分析
    memProfile, _ := os.Create("mem.pprof")
    pprof.WriteHeapProfile(memProfile)
    memProfile.Close()
    
    os.Exit(code)
}

// 分析: go tool pprof cpu.pprof
// 分析: go tool pprof mem.pprof
```

### 4. 测试覆盖率增强

**gocov**: 提供更详细的覆盖率报告
```bash
go get github.com/axw/gocov/gocov
go get -u gopkg.in/matm/v1/gocov-html

# 生成覆盖率报告
gocov test ./... > coverage.json
gocov-html coverage.json > coverage.html
```

### 5. 可视化测试结果

**gotestsum**: 提供更好的测试输出格式
```bash
go get gotest.tools/gotestsum

# 运行测试并生成JUnit报告
gotestsum --junitfile results.xml

# 运行测试并显示详细输出
gotestsum --format testname
```

## 实际案例分析

### 1. HTTP API测试

测试RESTful API的完整示例：

```go
package api

import (
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "strings"
    "testing"
)

// 处理函数
func UserHandler(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
    case "GET":
        // 处理GET请求
        id := r.URL.Query().Get("id")
        if id == "" {
            http.Error(w, "Missing id parameter", http.StatusBadRequest)
            return
        }
        
        // 在实际应用中，这里会从数据库获取用户
        user := map[string]interface{}{
            "id":   id,
            "name": "John Doe",
            "age":  30,
        }
        
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(user)
        
    case "POST":
        // 处理POST请求
        var user map[string]interface{}
        if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
            http.Error(w, err.Error(), http.StatusBadRequest)
            return
        }
        
        // 验证
        if _, ok := user["name"]; !ok {
            http.Error(w, "Missing name field", http.StatusBadRequest)
            return
        }
        
        // 在实际应用中，这里会保存用户到数据库
        w.WriteHeader(http.StatusCreated)
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"status": "created"})
        
    default:
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
    }
}

// 测试
func TestUserHandler(t *testing.T) {
    // 表格驱动测试
    tests := []struct {
        name           string
        method         string
        url            string
        body           string
        expectedStatus int
        expectedBody   string
        validateFunc   func(*testing.T, *httptest.ResponseRecorder)
    }{
        {
            name:           "get user",
            method:         "GET",
            url:            "/api/users?id=123",
            expectedStatus: http.StatusOK,
            validateFunc: func(t *testing.T, rr *httptest.ResponseRecorder) {
                var response map[string]interface{}
                json.Unmarshal(rr.Body.Bytes(), &response)
                
                if id, ok := response["id"].(string); !ok || id != "123" {
                    t.Errorf("Expected id '123', got %v", response["id"])
                }
                
                if name, ok := response["name"].(string); !ok || name != "John Doe" {
                    t.Errorf("Expected name 'John Doe', got %v", response["name"])
                }
            },
        },
        {
            name:           "get user missing id",
            method:         "GET",
            url:            "/api/users",
            expectedStatus: http.StatusBadRequest,
            expectedBody:   "Missing id parameter\n",
        },
        {
            name:           "create user",
            method:         "POST",
            url:            "/api/users",
            body:           `{"name":"Jane Doe","age":25}`,
            expectedStatus: http.StatusCreated,
            validateFunc: func(t *testing.T, rr *httptest.ResponseRecorder) {
                var response map[string]interface{}
                json.Unmarshal(rr.Body.Bytes(), &response)
                
                if status, ok := response["status"].(string); !ok || status != "created" {
                    t.Errorf("Expected status 'created', got %v", response["status"])
                }
            },
        },
        {
            name:           "create user missing name",
            method:         "POST",
            url:            "/api/users",
            body:           `{"age":25}`,
            expectedStatus: http.StatusBadRequest,
            expectedBody:   "Missing name field\n",
        },
        {
            name:           "method not allowed",
            method:         "PUT",
            url:            "/api/users",
            expectedStatus: http.StatusMethodNotAllowed,
            expectedBody:   "Method not allowed\n",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // 创建请求
            var req *http.Request
            var err error
            
            if tt.body != "" {
                req, err = http.NewRequest(tt.method, tt.url, strings.NewReader(tt.body))
            } else {
                req, err = http.NewRequest(tt.method, tt.url, nil)
            }
            
            if err != nil {
                t.Fatal(err)
            }
            
            // 设置内容类型
            if tt.method == "POST" {
                req.Header.Set("Content-Type", "application/json")
            }
            
            // 创建响应记录器
            rr := httptest.NewRecorder()
            handler := http.HandlerFunc(UserHandler)
            
            // 调用处理函数
            handler.ServeHTTP(rr, req)
            
            // 检查状态码
            if status := rr.Code; status != tt.expectedStatus {
                t.Errorf("Handler returned wrong status code: got %v want %v",
                    status, tt.expectedStatus)
            }
            
            // 检查响应体
            if tt.expectedBody != "" && rr.Body.String() != tt.expectedBody {
                t.Errorf("Handler returned unexpected body: got %v want %v",
                    rr.Body.String(), tt.expectedBody)
            }
            
            // 运行自定义验证
            if tt.validateFunc != nil {
                tt.validateFunc(t, rr)
            }
        })
    }
}
```

### 2. 数据库访问层测试

测试数据库访问层的完整示例：

```go
package repository

import (
    "database/sql"
    "testing"
    
    _ "github.com/mattn/go-sqlite3"
)

// 用户模型
type User struct {
    ID   string
    Name string
    Age  int
}

// 用户仓库
type UserRepository struct {
    db *sql.DB
}

func NewUserRepository(db *sql.DB) *UserRepository {
    return &UserRepository{db: db}
}

// 保存用户
func (r *UserRepository) SaveUser(user User) error {
    _, err := r.db.Exec(
        "INSERT INTO users (id, name, age) VALUES (?, ?, ?)",
        user.ID, user.Name, user.Age,
    )
    return err
}

// 获取用户
func (r *UserRepository) GetUser(id string) (User, error) {
    var user User
    err := r.db.QueryRow(
        "SELECT id, name, age FROM users WHERE id = ?",
        id,
    ).Scan(&user.ID, &user.Name, &user.Age)
    
    return user, err
}

// 更新用户
func (r *UserRepository) UpdateUser(user User) error {
    _, err := r.db.Exec(
        "UPDATE users SET name = ?, age = ? WHERE id = ?",
        user.Name, user.Age, user.ID,
    )
    return err
}

// 删除用户
func (r *UserRepository) DeleteUser(id string) error {
    _, err := r.db.Exec("DELETE FROM users WHERE id = ?", id)
    return err
}

// 测试
func TestUserRepository(t *testing.T) {
    // 创建内存数据库
    db, err := sql.Open("sqlite3", ":memory:")
    if err != nil {
        t.Fatalf("Failed to open database: %v", err)
    }
    defer db.Close()
    
    // 创建表
    _, err = db.Exec(`
        CREATE TABLE users (
            id TEXT PRIMARY KEY,
            name TEXT NOT NULL,
            age INTEGER
        )
    `)
    if err != nil {
        t.Fatalf("Failed to create table: %v", err)
    }
    
    // 创建仓库
    repo := NewUserRepository(db)
    
    // 测试保存用户
    t.Run("SaveUser", func(t *testing.T) {
        user := User{
            ID:   "1",
            Name: "John",
            Age:  30,
        }
        
        err := repo.SaveUser(user)
        if err != nil {
            t.Errorf("Failed to save user: %v", err)
        }
        
        // 验证保存是否成功
        var count int
        err = db.QueryRow("SELECT COUNT(*) FROM users WHERE id = ?", user.ID).Scan(&count)
        if err != nil {
            t.Errorf("Failed to query user count: %v", err)
        }
        
        if count != 1 {
            t.Errorf("Expected 1 user, got %d", count)
        }
    })
    
    // 测试获取用户
    t.Run("GetUser", func(t *testing.T) {
        // 先保存一个用户
        user := User{
            ID:   "2",
            Name: "Jane",
            Age:  25,
        }
        
        err := repo.SaveUser(user)
        if err != nil {
            t.Fatalf("Failed to save user for get test: %v", err)
        }
        
        // 获取用户
        retrievedUser, err := repo.GetUser(user.ID)
        if err != nil {
            t.Errorf("Failed to get user: %v", err)
        }
        
        // 验证用户信息
        if retrievedUser.ID != user.ID {
            t.Errorf("Expected ID %s, got %s", user.ID, retrievedUser.ID)
        }
        
        if retrievedUser.Name != user.Name {
            t.Errorf("Expected Name %s, got %s", user.Name, retrievedUser.Name)
        }
        
        if retrievedUser.Age != user.Age {
            t.Errorf("Expected Age %d, got %d", user.Age, retrievedUser.Age)
        }
    })
    
    // 测试更新用户
    t.Run("UpdateUser", func(t *testing.T) {
        // 先保存一个用户
        user := User{
            ID:   "3",
            Name: "Bob",
            Age:  40,
        }
        
        err := repo.SaveUser(user)
        if err != nil {
            t.Fatalf("Failed to save user for update test: %v", err)
        }
        
        // 更新用户
        user.Name = "Robert"
        user.Age = 41
        
        err = repo.UpdateUser(user)
        if err != nil {
            t.Errorf("Failed to update user: %v", err)
        }
        
        // 验证更新
        retrievedUser, err := repo.GetUser(user.ID)
        if err != nil {
            t.Errorf("Failed to get updated user: %v", err)
        }
        
        if retrievedUser.Name != "Robert" {
            t.Errorf("Expected updated Name 'Robert', got %s", retrievedUser.Name)
        }
        
        if retrievedUser.Age != 41 {
            t.Errorf("Expected updated Age 41, got %d", retrievedUser.Age)
        }
    })
    
    // 测试删除用户
    t.Run("DeleteUser", func(t *testing.T) {
        // 先保存一个用户
        user := User{
            ID:   "4",
            Name: "Alice",
            Age:  35,
        }
        
        err := repo.SaveUser(user)
        if err != nil {
            t.Fatalf("Failed to save user for delete test: %v", err)
        }
        
        // 删除用户
        err = repo.DeleteUser(user.ID)
        if err != nil {
            t.Errorf("Failed to delete user: %v", err)
        }
        
        // 验证删除
        var count int
        err = db.QueryRow("SELECT COUNT(*) FROM users WHERE id = ?", user.ID).Scan(&count)
        if err != nil {
            t.Errorf("Failed to query user count after delete: %v", err)
        }
        
        if count != 0 {
            t.Errorf("Expected 0 users after delete, got %d", count)
        }
    })
}
```

### 3. 复杂业务逻辑测试

测试复杂业务逻辑的完整示例：

```go
package service

import (
    "errors"
    "testing"
    "time"
)

// 订单状态
type OrderStatus string

const (
    OrderStatusPending   OrderStatus = "pending"
    OrderStatusApproved  OrderStatus = "approved"
    OrderStatusShipped   OrderStatus = "shipped"
    OrderStatusDelivered OrderStatus = "delivered"
    OrderStatusCancelled OrderStatus = "cancelled"
)

// 订单模型
type Order struct {
    ID            string
    CustomerID    string
    Items         []OrderItem
    TotalAmount   float64
    Status        OrderStatus
    PaymentStatus bool
    CreatedAt     time.Time
    UpdatedAt     time.Time
}

// 订单项
type OrderItem struct {
    ProductID string
    Quantity  int
    Price     float64
}

// 订单仓库接口
type OrderRepository interface {
    GetOrder(id string) (Order, error)
    SaveOrder(order Order) error
    UpdateOrder(order Order) error
}

// 支付服务接口
type PaymentService interface {
    ProcessPayment(orderID string, amount float64) (bool, error)
    RefundPayment(orderID string) error
}

// 库存服务接口
type InventoryService interface {
    CheckAvailability(productID string, quantity int) (bool, error)
    ReserveItems(orderID string, items []OrderItem) error
    ReleaseItems(orderID string) error
}

// 订单服务
type OrderService struct {
    orderRepo     OrderRepository
    paymentSvc    PaymentService
    inventorySvc  InventoryService
}

func NewOrderService(
    orderRepo OrderRepository,
    paymentSvc PaymentService,
    inventorySvc InventoryService,
) *OrderService {
    return &OrderService{
        orderRepo:    orderRepo,
        paymentSvc:   paymentSvc,
        inventorySvc: inventorySvc,
    }
}

// 创建订单
func (s *OrderService) CreateOrder(customerID string, items []OrderItem) (string, error) {
    // 验证项目
    if len(items) == 0 {
        return "", errors.New("order must have at least one item")
    }
    
    // 计算总金额
    var totalAmount float64
    for _, item := range items {
        // 检查库存
        available, err := s.inventorySvc.CheckAvailability(item.ProductID, item.Quantity)
        if err != nil {
            return "", err
        }
        if !available {
            return "", errors.New("product not available in requested quantity")
        }
        
        totalAmount += item.Price * float64(item.Quantity)
    }
    
    // 创建订单
    order := Order{
        ID:          generateOrderID(),
        CustomerID:  customerID,
        Items:       items,
        TotalAmount: totalAmount,
        Status:      OrderStatusPending,
        CreatedAt:   time.Now(),
        UpdatedAt:   time.Now(),
    }
    
    // 保存订单
    if err := s.orderRepo.SaveOrder(order); err != nil {
        return "", err
    }
    
    // 预留库存
    if err := s.inventorySvc.ReserveItems(order.ID, items); err != nil {
        return "", err
    }
    
    return order.ID, nil
}

// 支付订单
func (s *OrderService) PayOrder(orderID string) error {
    // 获取订单
    order, err := s.orderRepo.GetOrder(orderID)
    if err != nil {
        return err
    }
    
    // 检查状态
    if order.Status != OrderStatusPending {
        return errors.New("order is not in pending status")
    }
    
    // 处理支付
    success, err := s.paymentSvc.ProcessPayment(orderID, order.TotalAmount)
    if err != nil {
        return err
    }
    
    if !success {
        return errors.New("payment failed")
    }
    
    // 更新订单
    order.PaymentStatus = true
    order.Status = OrderStatusApproved
    order.UpdatedAt = time.Now()
    
    return s.orderRepo.UpdateOrder(order)
}

// 取消订单
func (s *OrderService) CancelOrder(orderID string) error {
    // 获取订单
    order, err := s.orderRepo.GetOrder(orderID)
    if err != nil {
        return err
    }
    
    // 检查状态
    if order.Status != OrderStatusPending && order.Status != OrderStatusApproved {
        return errors.New("order cannot be cancelled in current status")
    }
    
    // 如果已支付，退款
    if order.PaymentStatus {
        if err := s.paymentSvc.RefundPayment(orderID); err != nil {
            return err
        }
    }
    
    // 释放库存
    if err := s.inventorySvc.ReleaseItems(orderID); err != nil {
        return err
    }
    
    // 更新订单
    order.Status = OrderStatusCancelled
    order.UpdatedAt = time.Now()
    
    return s.orderRepo.UpdateOrder(order)
}

// 辅助函数
func generateOrderID() string {
    return "ORD-" + time.Now().Format("20060102-150405")
}

// 测试代码

// 模拟订单仓库
type MockOrderRepository struct {
    orders map[string]Order
}

func NewMockOrderRepository() *MockOrderRepository {
    return &MockOrderRepository{
        orders: make(map[string]Order),
    }
}

func (m *MockOrderRepository) GetOrder(id string) (Order, error) {
    order, exists := m.orders[id]
    if !exists {
        return Order{}, errors.New("order not found")
    }
    return order, nil
}

func (m *MockOrderRepository) SaveOrder(order Order) error {
    m.orders[order.ID] = order
    return nil
}

func (m *MockOrderRepository) UpdateOrder(order Order) error {
    _, exists := m.orders[order.ID]
    if !exists {
        return errors.New("order not found")
    }
    m.orders[order.ID] = order
    return nil
}

// 模拟支付服务
type MockPaymentService struct {
    shouldSucceed bool
    payments      map[string]float64
    refunds       map[string]bool
}

func NewMockPaymentService(shouldSucceed bool) *MockPaymentService {
    return &MockPaymentService{
        shouldSucceed: shouldSucceed,
        payments:      make(map[string]float64),
        refunds:       make(map[string]bool),
    }
}

func (m *MockPaymentService) ProcessPayment(orderID string, amount float64) (bool, error) {
    if !m.shouldSucceed {
        return false, nil
    }
    m.payments[orderID] = amount
    return true, nil
}

func (m *MockPaymentService) RefundPayment(orderID string) error {
    _, exists := m.payments[orderID]
    if !exists {
        return errors.New("payment not found")
    }
    m.refunds[orderID] = true
    return nil
}

// 模拟库存服务
type MockInventoryService struct {
    availability map[string]int
    reservations map[string][]OrderItem
    releases     map[string]bool
}

func NewMockInventoryService() *MockInventoryService {
    return &MockInventoryService{
        availability: make(map[string]int),
        reservations: make(map[string][]OrderItem),
        releases:     make(map[string]bool),
    }
}

func (m *MockInventoryService) SetAvailability(productID string, quantity int) {
    m.availability[productID] = quantity
}

func (m *MockInventoryService) CheckAvailability(productID string, quantity int) (bool, error) {
    available, exists := m.availability[productID]
    if !exists {
        return false, nil
    }
    return available >= quantity, nil
}

func (m *MockInventoryService) ReserveItems(orderID string, items []OrderItem) error {
    for _, item := range items {
        available, exists := m.availability[item.ProductID]
        if !exists || available < item.Quantity {
            return errors.New("insufficient inventory")
        }
        m.availability[item.ProductID] -= item.Quantity
    }
    m.reservations[orderID] = items
    return nil
}

func (m *MockInventoryService) ReleaseItems(orderID string) error {
    items, exists := m.reservations[orderID]
    if !exists {
        return errors.New("reservation not found")
    }
    
    for _, item := range items {
        m.availability[item.ProductID] += item.Quantity
    }
    
    m.releases[orderID] = true
    return nil
}

// 测试
func TestOrderService_CreateOrder(t *testing.T) {
    tests := []struct {
        name        string
        customerID  string
        items       []OrderItem
        inventory   map[string]int
        expectError bool
    }{
        {
            name:       "valid order",
            customerID: "cust-1",
            items: []OrderItem{
                {ProductID: "prod-1", Quantity: 2, Price: 10.0},
                {ProductID: "prod-2", Quantity: 1, Price: 20.0},
            },
            inventory: map[string]int{
                "prod-1": 5,
                "prod-2": 3,
            },
            expectError: false,
        },
        {
            name:       "empty order",
            customerID: "cust-1",
            items:      []OrderItem{},
            inventory:  map[string]int{},
            expectError: true,
        },
        {
            name:       "insufficient inventory",
            customerID: "cust-1",
            items: []OrderItem{
                {ProductID: "prod-1", Quantity: 10, Price: 10.0},
            },
            inventory: map[string]int{
                "prod-1": 5,
            },
            expectError: true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // 设置模拟服务
            orderRepo := NewMockOrderRepository()
            paymentSvc := NewMockPaymentService(true)
            inventorySvc := NewMockInventoryService()
            
            // 设置库存
            for product, quantity := range tt.inventory {
                inventorySvc.SetAvailability(product, quantity)
            }
            
            // 创建订单服务
            service := NewOrderService(orderRepo, paymentSvc, inventorySvc)
            
            // 调用创建订单
            orderID, err := service.CreateOrder(tt.customerID, tt.items)
            
            // 验证结果
            if tt.expectError {
                if err == nil {
                    t.Error("Expected error, got nil")
                }
            } else {
                if err != nil {
                    t.Errorf("Unexpected error: %v", err)
                }
                
                if orderID == "" {
                    t.Error("Expected order ID, got empty string")
                }
                
                // 验证订单已保存
                order, err := orderRepo.GetOrder(orderID)
                if err != nil {
                    t.Errorf("Failed to get created order: %v", err)
                }
                
                if order.CustomerID != tt.customerID {
                    t.Errorf("Expected customer ID %s, got %s", tt.customerID, order.CustomerID)
                }
                
                if order.Status != OrderStatusPending {
                    t.Errorf("Expected status %s, got %s", OrderStatusPending, order.Status)
                }
                
                // 验证库存已预留
                reservations, exists := inventorySvc.reservations[orderID]
                if !exists {
                    t.Error("Expected inventory reservation, but none found")
                }
                
                if len(reservations) != len(tt.items) {
                    t.Errorf("Expected %d reserved items, got %d", len(tt.items), len(reservations))
                }
            }
        })
    }
}

func TestOrderService_PayOrder(t *testing.T) {
    tests := []struct {
        name          string
        initialStatus OrderStatus
        paymentSuccess bool
        expectError   bool
    }{
        {
            name:          "valid payment",
            initialStatus: OrderStatusPending,
            paymentSuccess: true,
            expectError:   false,
        },
        {
            name:          "payment failure",
            initialStatus: OrderStatusPending,
            paymentSuccess: false,
            expectError:   true,
        },
        {
            name:          "invalid status",
            initialStatus: OrderStatusShipped,
            paymentSuccess: true,
            expectError:   true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // 设置模拟服务
            orderRepo := NewMockOrderRepository()
            paymentSvc := NewMockPaymentService(tt.paymentSuccess)
            inventorySvc := NewMockInventoryService()
            
            // 创建订单服务
            service := NewOrderService(orderRepo, paymentSvc, inventorySvc)
            
            // 创建初始订单
            orderID := "order-123"
            initialOrder := Order{
                ID:          orderID,
                CustomerID:  "cust-1",
                Items:       []OrderItem{{ProductID: "prod-1", Quantity: 1, Price: 10.0}},
                TotalAmount: 10.0,
                Status:      tt.initialStatus,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
            }
            
            // 保存初始订单
            err := orderRepo.SaveOrder(initialOrder)
            if err != nil {
                t.Fatalf("Failed to save initial order: %v", err)
            }
            
            // 调用支付订单
            err = service.PayOrder(orderID)
            
            // 验证结果
            if tt.expectError {
                if err == nil {
                    t.Error("Expected error, got nil")
                }
            } else {
                if err != nil {
                    t.Errorf("Unexpected error: %v", err)
                }
                
                // 验证订单状态已更新
                order, err := orderRepo.GetOrder(orderID)
                if err != nil {
                    t.Errorf("Failed to get updated order: %v", err)
                }
                
                if order.Status != OrderStatusApproved {
                    t.Errorf("Expected status %s, got %s", OrderStatusApproved, order.Status)
                }
                
                if !order.PaymentStatus {
                    t.Error("Expected payment status to be true")
                }
                
                // 验证支付已处理
                amount, exists := paymentSvc.payments[orderID]
                if !exists {
                    t.Error("Expected payment to be processed, but none found")
                }
                
                if amount != 10.0 {
                    t.Errorf("Expected payment amount 10.0, got %f", amount)
                }
            }
        })
    }
}

func TestOrderService_CancelOrder(t *testing.T) {
    tests := []struct {
        name          string
        initialStatus OrderStatus
        paymentStatus bool
        expectError   bool
    }{
        {
            name:          "cancel pending order",
            initialStatus: OrderStatusPending,
            paymentStatus: false,
            expectError:   false,
        },
        {
            name:          "cancel approved order with payment",
            initialStatus: OrderStatusApproved,
            paymentStatus: true,
            expectError:   false,
        },
        {
            name:          "cancel shipped order",
            initialStatus: OrderStatusShipped,
            paymentStatus: true,
            expectError:   true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // 设置模拟服务
            orderRepo := NewMockOrderRepository()
            paymentSvc := NewMockPaymentService(true)
            inventorySvc := NewMockInventoryService()
            
            // 创建订单服务
            service := NewOrderService(orderRepo, paymentSvc, inventorySvc)
            
            // 创建初始订单
            orderID := "order-123"
            initialOrder := Order{
                ID:            orderID,
                CustomerID:    "cust-1",
                Items:         []OrderItem{{ProductID: "prod-1", Quantity: 1, Price: 10.0}},
                TotalAmount:   10.0,
                Status:        tt.initialStatus,
                PaymentStatus: tt.paymentStatus,
                CreatedAt:     time.Now(),
                UpdatedAt:     time.Now(),
            }
            
            // 保存初始订单
            err := orderRepo.SaveOrder(initialOrder)
            if err != nil {
                t.Fatalf("Failed to save initial order: %v", err)
            }
            
            // 如果有支付，设置支付记录
            if tt.paymentStatus {
                paymentSvc.payments[orderID] = initialOrder.TotalAmount
            }
            
            // 设置库存预留
            inventorySvc.reservations[orderID] = initialOrder.Items
            
            // 调用取消订单
            err = service.CancelOrder(orderID)
            
            // 验证结果
            if tt.expectError {
                if err == nil {
                    t.Error("Expected error, got nil")
                }
            } else {
                if err != nil {
                    t.Errorf("Unexpected error: %v", err)
                }
                
                // 验证订单状态已更新
                order, err := orderRepo.GetOrder(orderID)
                if err != nil {
                    t.Errorf("Failed to get updated order: %v", err)
                }
                
                if order.Status != OrderStatusCancelled {
                    t.Errorf("Expected status %s, got %s", OrderStatusCancelled, order.Status)
                }
                
                // 如果有支付，验证退款
                if tt.paymentStatus {
                    refunded, exists := paymentSvc.refunds[orderID]
                    if !exists || !refunded {
                        t.Error("Expected refund to be processed, but none found")
                    }
                }
                
                // 验证库存已释放
                released, exists := inventorySvc.releases[orderID]
                if !exists || !released {
                    t.Error("Expected inventory to be released, but none found")
                }
            }
        })
    }
}
```

## 总结

Go语言提供了强大而灵活的测试工具，能够满足从简单单元测试到复杂集成测试的各种需求。本文涵盖了Go测试的基础知识、最佳实践和高级技术，包括：

1. **测试基础**：了解Go测试的命名约定、组织方式和基本工具
2. **表格驱动测试**：使用结构化数据测试多种情况
3. **模拟与依赖注入**：隔离测试单元和外部依赖
4. **子测试和并行测试**：组织和优化测试执行
5. **基准测试和性能分析**：测量和优化代码性能
6. **高级测试技术**：模糊测试、属性测试和BDD风格测试

通过遵循这些最佳实践，开发者可以编写出高质量、可维护的测试代码，提高软件质量并降低维护成本。记住，测试不仅仅是为了验证代码是否正确，还是代码的活文档，能够帮助理解代码的行为和意图。

## 相关知识点
- [基准测试与性能分析](./基准测试与性能分析.md)
- [模糊测试](./模糊测试.md)
- [Mock与测试替身](./Mock与测试替身.md)
- [集成测试与E2E测试](./集成测试与E2E测试.md)
- [调试工具与技巧](./调试工具与技巧.md)
