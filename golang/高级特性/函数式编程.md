# 函数式编程

## 概述
函数式编程是一种编程范式，它将计算视为数学函数的求值，并避免使用状态和可变数据。虽然Go不是纯函数式语言，但它提供了许多支持函数式编程风格的特性，如一等函数、闭包和延迟求值等。函数式编程在Go中可以与命令式编程结合使用，创建更加简洁、可维护和并发安全的代码。

## 函数式编程的核心概念

### 1. 一等函数
在Go中，函数是一等公民，这意味着函数可以像其他值一样被传递和使用：
- 可以将函数赋值给变量
- 可以将函数作为参数传递给其他函数
- 可以从函数中返回函数

```go
// 将函数赋值给变量
add := func(a, b int) int {
    return a + b
}
result := add(5, 3) // 8

// 将函数作为参数传递
func applyFunc(fn func(int, int) int, a, b int) int {
    return fn(a, b)
}
sum := applyFunc(add, 5, 3) // 8

// 从函数返回函数
func multiplier(factor int) func(int) int {
    return func(x int) int {
        return x * factor
    }
}
double := multiplier(2)
triple := multiplier(3)
fmt.Println(double(5)) // 10
fmt.Println(triple(5)) // 15
```

### 2. 闭包
Go支持闭包，即函数可以访问并绑定到其词法环境中的变量：

```go
func counter() func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}

c1 := counter()
fmt.Println(c1()) // 1
fmt.Println(c1()) // 2
fmt.Println(c1()) // 3

c2 := counter()   // 新的计数器
fmt.Println(c2()) // 1
```

### 3. 函数式选项模式
这是Go中广泛使用的一种函数式编程模式，用于配置复杂对象：

```go
type Server struct {
    host    string
    port    int
    timeout time.Duration
    maxConn int
}

type Option func(*Server)

func WithHost(host string) Option {
    return func(s *Server) {
        s.host = host
    }
}

func WithPort(port int) Option {
    return func(s *Server) {
        s.port = port
    }
}

func WithTimeout(timeout time.Duration) Option {
    return func(s *Server) {
        s.timeout = timeout
    }
}

func WithMaxConn(maxConn int) Option {
    return func(s *Server) {
        s.maxConn = maxConn
    }
}

func NewServer(options ...Option) *Server {
    // 默认配置
    server := &Server{
        host:    "localhost",
        port:    8080,
        timeout: 30 * time.Second,
        maxConn: 100,
    }
    
    // 应用选项
    for _, option := range options {
        option(server)
    }
    
    return server
}

// 使用
server := NewServer(
    WithHost("example.com"),
    WithPort(9000),
    WithTimeout(60 * time.Second),
)
```

## 函数式数据处理

### 1. Map 函数

Map函数对切片中的每个元素应用给定的函数，并返回结果：

```go
func Map[T, U any](slice []T, fn func(T) U) []U {
    result := make([]U, len(slice))
    for i, v := range slice {
        result[i] = fn(v)
    }
    return result
}

// 使用示例
nums := []int{1, 2, 3, 4, 5}
squared := Map(nums, func(x int) int {
    return x * x
})
// squared: [1, 4, 9, 16, 25]
```

### 2. Filter 函数

Filter函数保留切片中满足条件的元素：

```go
func Filter[T any](slice []T, fn func(T) bool) []T {
    var result []T
    for _, v := range slice {
        if fn(v) {
            result = append(result, v)
        }
    }
    return result
}

// 使用示例
nums := []int{1, 2, 3, 4, 5}
evens := Filter(nums, func(x int) bool {
    return x%2 == 0
})
// evens: [2, 4]
```

### 3. Reduce 函数

Reduce函数将切片中的元素组合成单个结果：

```go
func Reduce[T, U any](slice []T, initial U, fn func(U, T) U) U {
    result := initial
    for _, v := range slice {
        result = fn(result, v)
    }
    return result
}

// 使用示例
nums := []int{1, 2, 3, 4, 5}
sum := Reduce(nums, 0, func(acc, x int) int {
    return acc + x
})
// sum: 15
```

## 函数组合

函数组合是将多个简单函数组合成一个复杂函数的技术：

```go
// 函数组合
func Compose[A, B, C any](f func(B) C, g func(A) B) func(A) C {
    return func(x A) C {
        return f(g(x))
    }
}

// 使用示例
add1 := func(x int) int { return x + 1 }
mul3 := func(x int) int { return x * 3 }

add1ThenMul3 := Compose(mul3, add1)
result := add1ThenMul3(5) // (5+1)*3 = 18
```

## 柯里化与偏函数应用

柯里化是将接受多个参数的函数转换成一系列接受单个参数的函数：

```go
// 柯里化示例
func Curry(fn func(int, int) int) func(int) func(int) int {
    return func(a int) func(int) int {
        return func(b int) int {
            return fn(a, b)
        }
    }
}

// 使用示例
add := func(a, b int) int { return a + b }
curriedAdd := Curry(add)
plus5 := curriedAdd(5)
result := plus5(3) // 5+3 = 8
```

## 不可变数据和纯函数

### 1. 不可变数据

Go没有内置的不可变数据结构，但我们可以通过设计模式来模拟：

```go
// 不可变切片
type ImmutableSlice struct {
    values []int
}

func NewImmutableSlice(values []int) ImmutableSlice {
    // 创建副本以保证不可变性
    valuesCopy := make([]int, len(values))
    copy(valuesCopy, values)
    return ImmutableSlice{values: valuesCopy}
}

func (s ImmutableSlice) Get(index int) int {
    return s.values[index]
}

func (s ImmutableSlice) Append(value int) ImmutableSlice {
    newValues := make([]int, len(s.values)+1)
    copy(newValues, s.values)
    newValues[len(s.values)] = value
    return ImmutableSlice{values: newValues}
}
```

### 2. 纯函数

纯函数没有副作用，对于相同的输入总是返回相同的输出：

```go
// 纯函数示例
func add(a, b int) int {
    return a + b  // 无副作用，结果只依赖于输入
}

// 非纯函数示例
var counter int
func incrementAndGet() int {
    counter++     // 副作用：修改了外部状态
    return counter
}
```

## 在Go中实现函数式编程的实际应用

### 1. 数据转换管道

```go
type Person struct {
    Name string
    Age  int
}

func ProcessPeople(people []Person) []string {
    adults := Filter(people, func(p Person) bool {
        return p.Age >= 18
    })
    
    names := Map(adults, func(p Person) string {
        return p.Name
    })
    
    return names
}

// 使用
people := []Person{
    {"Alice", 25},
    {"Bob", 17},
    {"Charlie", 30},
    {"David", 15},
}
adultNames := ProcessPeople(people)
// adultNames: ["Alice", "Charlie"]
```

### 2. 错误处理模式

```go
// 定义一个包含错误的结果类型
type Result[T any] struct {
    Value T
    Err   error
}

// 链式操作
func (r Result[T]) Then(fn func(T) Result[T]) Result[T] {
    if r.Err != nil {
        return r
    }
    return fn(r.Value)
}

// 使用示例
func readFile(path string) Result[[]byte] {
    data, err := ioutil.ReadFile(path)
    return Result[[]byte]{Value: data, Err: err}
}

func parseJSON(data []byte) Result[map[string]interface{}] {
    var result map[string]interface{}
    err := json.Unmarshal(data, &result)
    return Result[map[string]interface{}]{Value: result, Err: err}
}

// 链式调用
func processConfig(path string) Result[map[string]interface{}] {
    return readFile(path).Then(func(data []byte) Result[map[string]interface{}] {
        return parseJSON(data)
    })
}
```

### 3. 并发处理模式

```go
func ConcurrentMap[T, U any](slice []T, fn func(T) U) []U {
    result := make([]U, len(slice))
    var wg sync.WaitGroup
    wg.Add(len(slice))
    
    for i, v := range slice {
        go func(i int, v T) {
            defer wg.Done()
            result[i] = fn(v)
        }(i, v)
    }
    
    wg.Wait()
    return result
}

// 使用
urls := []string{"http://example.com", "http://golang.org", "http://github.com"}
bodies := ConcurrentMap(urls, func(url string) string {
    resp, err := http.Get(url)
    if err != nil {
        return ""
    }
    defer resp.Body.Close()
    body, _ := ioutil.ReadAll(resp.Body)
    return string(body)
})
```

## Go函数式编程的优缺点

### 优点
1. **代码更简洁**：函数式风格通常需要更少的代码来完成复杂任务
2. **更易测试**：纯函数更容易测试，因为它们没有副作用
3. **并发安全**：不可变数据和纯函数使并发编程更安全
4. **更可组合**：函数式组件更容易组合成复杂系统
5. **更易维护**：函数之间的依赖更清晰，副作用更少

### 缺点
1. **性能开销**：某些函数式模式可能引入额外的内存分配和函数调用
2. **学习曲线**：对于习惯命令式编程的开发者，函数式思维可能需要时间适应
3. **库支持有限**：Go标准库没有内置函数式工具，需要自己实现或使用第三方库
4. **不适合所有场景**：某些问题用命令式风格解决更自然

## 最佳实践

1. **合理混用**：将函数式和命令式风格结合，选择最适合问题的方法
2. **关注性能**：在性能关键的部分，谨慎使用可能导致过多内存分配的函数式模式
3. **保持简单**：函数式风格应该使代码更简单，而不是更复杂
4. **利用泛型**：Go 1.18引入的泛型使函数式编程更加方便
5. **考虑团队**：考虑团队成员的熟悉度，不要为了函数式而函数式

## 相关知识点
- [高级特性/泛型编程](泛型编程.md)
- [高级特性/反射机制](反射机制.md)
- [并发编程/高级Goroutine管理](../并发编程/高级Goroutine管理.md)
- [设计模式/结构型模式](../设计模式/结构型模式.md)
