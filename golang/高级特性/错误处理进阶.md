# Goè¯­è¨€é”™è¯¯å¤„ç†è¿›é˜¶

## ğŸ“š å­¦ä¹ ç›®æ ‡
æŒæ¡Goè¯­è¨€çš„é”™è¯¯å¤„ç†æ¨¡å¼ï¼Œç†è§£è‡ªå®šä¹‰é”™è¯¯ç±»å‹å’Œé”™è¯¯é“¾çš„ä½¿ç”¨ï¼Œå­¦ä¼šåœ¨ä¸Šä¸‹æ–‡ä¸­å¤„ç†é”™è¯¯ï¼Œç†Ÿæ‚‰é”™è¯¯å¤„ç†çš„æœ€ä½³å®è·µã€‚

---

## 1. é”™è¯¯å¤„ç†åŸºç¡€å›é¡¾

### 1.1 é”™è¯¯æ˜¯å€¼
Goè¯­è¨€ä¸­çš„é”™è¯¯æ˜¯ä¸€ä¸ªå®ç°äº†`error`æ¥å£çš„æ™®é€šå€¼ï¼Œè€Œéç‰¹æ®Šçš„è¯­è¨€ç»“æ„ã€‚`error`æ¥å£åªæœ‰ä¸€ä¸ªæ–¹æ³•ï¼š
```go
type error interface {
    Error() string
}
```

### 1.2 åŸºæœ¬é”™è¯¯å¤„ç†æ¨¡å¼
```go
package main

import (
    "errors"
    "fmt"
)

func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("é™¤æ•°ä¸èƒ½ä¸ºé›¶")
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 0)
    if err != nil {
        fmt.Println("é”™è¯¯:", err)
        return
    }
    fmt.Println("ç»“æœ:", result)
}
```

### 1.3 `errors`åŒ…çš„åŸºæœ¬ä½¿ç”¨
```go
package main

import (
    "errors"
    "fmt"
)

var ErrDivideByZero = errors.New("é™¤æ•°ä¸èƒ½ä¸ºé›¶")

func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, ErrDivideByZero
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 0)
    if err != nil {
        if errors.Is(err, ErrDivideByZero) {
            fmt.Println("å‘ç”Ÿé™¤é›¶é”™è¯¯")
        } else {
            fmt.Println("å…¶ä»–é”™è¯¯:", err)
        }
        return
    }
    fmt.Println("ç»“æœ:", result)
}
```

---

## 2. è‡ªå®šä¹‰é”™è¯¯ç±»å‹

### 2.1 å®ç°è‡ªå®šä¹‰é”™è¯¯
```go
package main

import (
    "fmt"
)

// è‡ªå®šä¹‰é”™è¯¯ç±»å‹
type DivideError struct {
    Dividend int
    Divisor  int
    Message  string
}

// å®ç°erroræ¥å£
func (e DivideError) Error() string {
    return fmt.Sprintf("%s: %d / %d", e.Message, e.Dividend, e.Divisor)
}

// åˆ›å»ºé”™è¯¯çš„è¾…åŠ©å‡½æ•°
func NewDivideError(dividend, divisor int) error {
    return DivideError{
        Dividend: dividend,
        Divisor:  divisor,
        Message:  "é™¤æ³•è¿ç®—é”™è¯¯",
    }
}

func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, NewDivideError(a, b)
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 0)
    if err != nil {
        fmt.Println("é”™è¯¯:", err)
        
        // ç±»å‹æ–­è¨€è·å–è¯¦ç»†ä¿¡æ¯
        if divErr, ok := err.(DivideError); ok {
            fmt.Printf("è¯¦ç»†ä¿¡æ¯: å°è¯•ç”¨ %d é™¤ä»¥ %d\n", 
                       divErr.Dividend, divErr.Divisor)
        }
    } else {
        fmt.Println("ç»“æœ:", result)
    }
}
```

### 2.2 å¸¦æœ‰æ–¹æ³•çš„é”™è¯¯ç±»å‹
è‡ªå®šä¹‰é”™è¯¯ç±»å‹å¯ä»¥åŒ…å«é¢å¤–æ–¹æ³•ï¼Œæä¾›æ›´å¤šåŠŸèƒ½ï¼š

```go
package main

import (
    "fmt"
    "time"
)

// å¸¦æ—¶é—´æˆ³çš„é”™è¯¯
type TimeError struct {
    When time.Time
    What string
}

func (e TimeError) Error() string {
    return fmt.Sprintf("%v: %s", e.When.Format("2006-01-02 15:04:05"), e.What)
}

// åˆ¤æ–­é”™è¯¯æ˜¯å¦è¿‡æœŸ
func (e TimeError) IsExpired(duration time.Duration) bool {
    return time.Since(e.When) > duration
}

// åˆ›å»ºé”™è¯¯
func NewTimeError(what string) TimeError {
    return TimeError{
        When: time.Now(),
        What: what,
    }
}

func doSomething() error {
    // æ¨¡æ‹Ÿæ“ä½œå¤±è´¥
    return NewTimeError("æ“ä½œå¤±è´¥")
}

func main() {
    err := doSomething()
    if err != nil {
        fmt.Println("é”™è¯¯:", err)
        
        // ç±»å‹æ–­è¨€æ£€æŸ¥é”™è¯¯ç‰¹å®šæ–¹æ³•
        if timeErr, ok := err.(TimeError); ok {
            if timeErr.IsExpired(time.Second * 5) {
                fmt.Println("è¿™æ˜¯ä¸€ä¸ªè¿‡æœŸçš„é”™è¯¯")
            } else {
                fmt.Println("è¿™æ˜¯ä¸€ä¸ªè¿‘æœŸçš„é”™è¯¯")
            }
        }
    }
    
    // ç­‰å¾…6ç§’åå†æ¬¡æ£€æŸ¥
    time.Sleep(6 * time.Second)
    if timeErr, ok := err.(TimeError); ok {
        if timeErr.IsExpired(time.Second * 5) {
            fmt.Println("ç°åœ¨é”™è¯¯å·²ç»è¿‡æœŸ")
        }
    }
}
```

### 2.3 é”™è¯¯å¸¸é‡ä¸å˜é‡
Goç¨‹åºé€šå¸¸å®šä¹‰é”™è¯¯å¸¸é‡æˆ–å˜é‡ï¼Œä¾¿äºé”™è¯¯æ¯”è¾ƒå’Œæ–‡æ¡£åŒ–ï¼š

```go
package main

import (
    "errors"
    "fmt"
    "io"
    "os"
)

// ä½¿ç”¨å˜é‡å®šä¹‰é”™è¯¯
var (
    ErrNotFound     = errors.New("èµ„æºæœªæ‰¾åˆ°")
    ErrUnauthorized = errors.New("æœªæˆæƒè®¿é—®")
    ErrInternal     = errors.New("å†…éƒ¨æœåŠ¡é”™è¯¯")
)

// åŸºäºç¯å¢ƒçš„é”™è¯¯åˆ›å»º
var ErrEnvironment = func() error {
    if os.Getenv("DEBUG") == "true" {
        return errors.New("è°ƒè¯•æ¨¡å¼ä¸‹çš„ç¯å¢ƒé”™è¯¯")
    }
    return errors.New("ç”Ÿäº§ç¯å¢ƒé”™è¯¯")
}()

func findResource(id string) error {
    if id == "" {
        return ErrNotFound
    }
    
    if id == "admin" {
        return nil
    }
    
    return ErrUnauthorized
}

func main() {
    err := findResource("")
    
    // ä½¿ç”¨ç­‰å€¼æ¯”è¾ƒ
    if err == ErrNotFound {
        fmt.Println("èµ„æºæœªæ‰¾åˆ°ï¼Œè¯·æ£€æŸ¥ID")
    }
    
    // æ ‡å‡†åº“é”™è¯¯æ¯”è¾ƒ
    if err == io.EOF {
        fmt.Println("å·²åˆ°è¾¾æ–‡ä»¶æœ«å°¾")
    }
    
    // è¾“å‡ºç¯å¢ƒç›¸å…³é”™è¯¯
    fmt.Println("ç¯å¢ƒé”™è¯¯:", ErrEnvironment)
}
```

---

## 3. é”™è¯¯é“¾ä¸é”™è¯¯åŒ…è£…

### 3.1 ä½¿ç”¨`fmt.Errorf`å’Œ`%w`åŒ…è£…é”™è¯¯
Go 1.13å¼•å…¥çš„`%w`æ ¼å¼åŒ–åŠ¨è¯å¯ä»¥åŒ…è£…é”™è¯¯å¹¶ä¿ç•™åŸå§‹é”™è¯¯ä¿¡æ¯ï¼š

```go
package main

import (
    "errors"
    "fmt"
    "os"
)

func openFile(filename string) (*os.File, error) {
    file, err := os.Open(filename)
    if err != nil {
        return nil, fmt.Errorf("æ‰“å¼€æ–‡ä»¶ %s å¤±è´¥: %w", filename, err)
    }
    return file, nil
}

func readConfig() error {
    file, err := openFile("config.json")
    if err != nil {
        return fmt.Errorf("è¯»å–é…ç½®å¤±è´¥: %w", err)
    }
    defer file.Close()
    // ç»§ç»­å¤„ç†...
    return nil
}

func initializeApp() error {
    if err := readConfig(); err != nil {
        return fmt.Errorf("åˆå§‹åŒ–åº”ç”¨å¤±è´¥: %w", err)
    }
    // ç»§ç»­å¤„ç†...
    return nil
}

func main() {
    err := initializeApp()
    if err != nil {
        fmt.Printf("é”™è¯¯: %v\n", err)
        
        // ä½¿ç”¨errors.Isæ£€æŸ¥ç‰¹å®šé”™è¯¯ç±»å‹
        if errors.Is(err, os.ErrNotExist) {
            fmt.Println("é…ç½®æ–‡ä»¶ä¸å­˜åœ¨ï¼Œå°†åˆ›å»ºé»˜è®¤é…ç½®")
        }
    }
}
```

### 3.2 é”™è¯¯æ£€æŸ¥ï¼š`errors.Is`å’Œ`errors.As`
Go 1.13å¼•å…¥äº†ä¸¤ä¸ªç”¨äºé”™è¯¯æ£€æŸ¥çš„æ–°å‡½æ•°ï¼š

```go
package main

import (
    "errors"
    "fmt"
    "io/fs"
    "os"
)

// è‡ªå®šä¹‰é”™è¯¯ç±»å‹
type QueryError struct {
    Query string
    Err   error
}

func (e *QueryError) Error() string {
    return fmt.Sprintf("æŸ¥è¯¢ %q å¤±è´¥: %v", e.Query, e.Err)
}

func (e *QueryError) Unwrap() error {
    return e.Err
}

// æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
func queryDatabase(query string) error {
    if query == "" {
        return &QueryError{
            Query: query,
            Err:   os.ErrPermission,
        }
    }
    return nil
}

func main() {
    // ç¤ºä¾‹1: ä½¿ç”¨errors.Isè¿›è¡Œé”™è¯¯æ¯”è¾ƒ
    err := queryDatabase("")
    
    // æ£€æŸ¥é”™è¯¯é“¾ä¸­æ˜¯å¦åŒ…å«ç‰¹å®šé”™è¯¯
    if errors.Is(err, os.ErrPermission) {
        fmt.Println("æƒé™é”™è¯¯: æ²¡æœ‰è¶³å¤Ÿæƒé™æ‰§è¡ŒæŸ¥è¯¢")
    }
    
    // ç¤ºä¾‹2: ä½¿ç”¨errors.Asè·å–é”™è¯¯ç±»å‹
    var queryErr *QueryError
    if errors.As(err, &queryErr) {
        fmt.Printf("æŸ¥è¯¢é”™è¯¯: æŸ¥è¯¢=%q åŸå› =%v\n", 
                   queryErr.Query, queryErr.Err)
    }
    
    // ç¤ºä¾‹3: ä¸æ ‡å‡†åº“é”™è¯¯é…åˆä½¿ç”¨
    _, err = os.Open("ä¸å­˜åœ¨çš„æ–‡ä»¶.txt")
    
    if errors.Is(err, fs.ErrNotExist) {
        fmt.Println("æ–‡ä»¶ä¸å­˜åœ¨")
    }
    
    var pathErr *fs.PathError
    if errors.As(err, &pathErr) {
        fmt.Printf("è·¯å¾„é”™è¯¯: Op=%s Path=%s Err=%v\n", 
                   pathErr.Op, pathErr.Path, pathErr.Err)
    }
}
```

### 3.3 æ‰‹åŠ¨å®ç°`Unwrap`æ–¹æ³•
è¦æ”¯æŒé”™è¯¯é“¾ï¼Œè‡ªå®šä¹‰é”™è¯¯ç±»å‹å¯ä»¥å®ç°`Unwrap`æ–¹æ³•ï¼š

```go
package main

import (
    "errors"
    "fmt"
)

// å¤šçº§é”™è¯¯
type DatabaseError struct {
    Operation string
    Err       error
}

func (e *DatabaseError) Error() string {
    return fmt.Sprintf("æ•°æ®åº“æ“ä½œ %q å¤±è´¥: %v", e.Operation, e.Err)
}

func (e *DatabaseError) Unwrap() error {
    return e.Err
}

// æ›´æ·±å±‚é”™è¯¯
type SQLError struct {
    Code    int
    Message string
}

func (e *SQLError) Error() string {
    return fmt.Sprintf("SQLé”™è¯¯ %d: %s", e.Code, e.Message)
}

func queryData() error {
    // æ¨¡æ‹ŸSQLé”™è¯¯
    sqlErr := &SQLError{Code: 1064, Message: "SQLè¯­æ³•é”™è¯¯"}
    
    // åŒ…è£…æˆæ•°æ®åº“é”™è¯¯
    return &DatabaseError{
        Operation: "SELECT",
        Err:       sqlErr,
    }
}

func main() {
    err := queryData()
    fmt.Println("åŸå§‹é”™è¯¯:", err)
    
    // ä½¿ç”¨errors.Unwrapé€å±‚è§£åŒ…
    if dbErr := errors.Unwrap(err); dbErr != nil {
        fmt.Println("ç¬¬ä¸€å±‚è§£åŒ…:", dbErr)
        
        if sqlErr := errors.Unwrap(dbErr); sqlErr != nil {
            fmt.Println("ç¬¬äºŒå±‚è§£åŒ…:", sqlErr)
        }
    }
    
    // ä½¿ç”¨errors.Asæå–ç‰¹å®šç±»å‹
    var sqlErr *SQLError
    if errors.As(err, &sqlErr) {
        fmt.Printf("æå–SQLé”™è¯¯: ä»£ç =%d æ¶ˆæ¯=%q\n", 
                   sqlErr.Code, sqlErr.Message)
    }
}
```

---

## 4. ä¸Šä¸‹æ–‡é”™è¯¯å¤„ç†

### 4.1 ä½¿ç”¨`context.Context`ä¼ é€’å’Œå¤„ç†é”™è¯¯
`context`åŒ…åœ¨åˆ†å¸ƒå¼è®¡ç®—ä¸­ç”¨äºè·¨APIè¾¹ç•Œä¼ é€’æˆªæ­¢æ—¶é—´ã€å–æ¶ˆä¿¡å·å’Œå…¶ä»–è¯·æ±‚èŒƒå›´çš„å€¼ï¼š

```go
package main

import (
    "context"
    "fmt"
    "time"
)

// æ¨¡æ‹Ÿæ•°æ®åº“æ“ä½œ
func queryDatabase(ctx context.Context, query string) (string, error) {
    // åˆ›å»ºä¸€ä¸ªæ‰§è¡ŒæŸ¥è¯¢çš„é€šé“
    resultCh := make(chan string)
    errCh := make(chan error)
    
    go func() {
        // æ¨¡æ‹Ÿé•¿æ—¶é—´è¿è¡Œçš„æŸ¥è¯¢
        time.Sleep(2 * time.Second)
        resultCh <- "æŸ¥è¯¢ç»“æœ"
    }()
    
    // ç­‰å¾…æŸ¥è¯¢å®Œæˆæˆ–ä¸Šä¸‹æ–‡å–æ¶ˆ
    select {
    case result := <-resultCh:
        return result, nil
    case err := <-errCh:
        return "", err
    case <-ctx.Done():
        return "", ctx.Err()
    }
}

func main() {
    // åˆ›å»ºå¸¦è¶…æ—¶çš„ä¸Šä¸‹æ–‡
    ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
    defer cancel()
    
    result, err := queryDatabase(ctx, "SELECT * FROM users")
    if err != nil {
        fmt.Println("æŸ¥è¯¢é”™è¯¯:", err)
        return
    }
    
    fmt.Println("ç»“æœ:", result)
}
```

### 4.2 è‡ªå®šä¹‰contextå€¼ä¸é”™è¯¯å¤„ç†
ç»“åˆ`context`åŒ…å’Œè‡ªå®šä¹‰é”™è¯¯ï¼Œå¯ä»¥å®ç°æ›´ä¸°å¯Œçš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼š

```go
package main

import (
    "context"
    "errors"
    "fmt"
    "time"
)

// è¯·æ±‚IDçš„keyç±»å‹
type requestIDKey struct{}

// å¸¦æœ‰è¯·æ±‚IDçš„é”™è¯¯
type RequestError struct {
    RequestID string
    Err       error
}

func (e *RequestError) Error() string {
    return fmt.Sprintf("è¯·æ±‚ %s å¤±è´¥: %v", e.RequestID, e.Err)
}

func (e *RequestError) Unwrap() error {
    return e.Err
}

// ä»ä¸Šä¸‹æ–‡è·å–è¯·æ±‚ID
func getRequestID(ctx context.Context) string {
    id, ok := ctx.Value(requestIDKey{}).(string)
    if !ok {
        return "unknown"
    }
    return id
}

// åˆ›å»ºå¸¦è¯·æ±‚IDçš„é”™è¯¯
func newRequestError(ctx context.Context, err error) error {
    return &RequestError{
        RequestID: getRequestID(ctx),
        Err:       err,
    }
}

// å¤„ç†è¯·æ±‚
func handleRequest(ctx context.Context) error {
    // æ¨¡æ‹Ÿä¸€äº›æ“ä½œ
    if err := validateRequest(ctx); err != nil {
        return newRequestError(ctx, err)
    }
    
    if err := processRequest(ctx); err != nil {
        return newRequestError(ctx, err)
    }
    
    return nil
}

// éªŒè¯è¯·æ±‚
func validateRequest(ctx context.Context) error {
    // æ¨¡æ‹ŸéªŒè¯å¤±è´¥
    return errors.New("éªŒè¯å¤±è´¥: ç¼ºå°‘å¿…è¦å‚æ•°")
}

// å¤„ç†è¯·æ±‚
func processRequest(ctx context.Context) error {
    // ä¸ä¼šæ‰§è¡Œåˆ°è¿™é‡Œï¼Œå› ä¸ºéªŒè¯å·²ç»å¤±è´¥
    return nil
}

func main() {
    // åˆ›å»ºå¸¦æœ‰è¯·æ±‚IDçš„ä¸Šä¸‹æ–‡
    ctx := context.WithValue(context.Background(), 
                             requestIDKey{}, 
                             "req-123456")
    
    // å¤„ç†è¯·æ±‚
    err := handleRequest(ctx)
    if err != nil {
        fmt.Println("é”™è¯¯:", err)
        
        // æå–è¯·æ±‚é”™è¯¯
        var reqErr *RequestError
        if errors.As(err, &reqErr) {
            fmt.Printf("è¯·æ±‚ID: %s\n", reqErr.RequestID)
            fmt.Printf("åº•å±‚é”™è¯¯: %v\n", reqErr.Err)
        }
    }
}
```

---

## 5. é”™è¯¯å¤„ç†æ¨¡å¼ä¸æœ€ä½³å®è·µ

### 5.1 é”™è¯¯å¤„ç†çš„æ ¸å¿ƒåŸåˆ™
1. **é”™è¯¯åªå¤„ç†ä¸€æ¬¡**ï¼šè¦ä¹ˆè®°å½•æ—¥å¿—ï¼Œè¦ä¹ˆä¼ æ’­ï¼Œé¿å…é‡å¤å¤„ç†åŒä¸€é”™è¯¯
2. **ä¿æŒé”™è¯¯ä¸Šä¸‹æ–‡**ï¼šåŒ…è£…é”™è¯¯æ—¶æ·»åŠ æœ‰ç”¨çš„ä¸Šä¸‹æ–‡ä¿¡æ¯
3. **é€æ˜é”™è¯¯**ï¼šç¡®ä¿é”™è¯¯èƒ½å¤Ÿè¢«è°ƒç”¨è€…ç†è§£å’Œå¤„ç†
4. **æ˜ç¡®é”™è¯¯å¤„ç†è´£ä»»**ï¼šæ˜ç¡®æ¯ä¸€å±‚ä»£ç å¯¹é”™è¯¯çš„å¤„ç†è´£ä»»

```go
package main

import (
    "errors"
    "fmt"
    "log"
    "os"
)

// ä¸å¥½çš„åšæ³•: é‡å¤å¤„ç†é”™è¯¯
func badErrorHandling(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        log.Printf("æ‰“å¼€æ–‡ä»¶å¤±è´¥: %v", err) // è®°å½•æ—¥å¿—
        return fmt.Errorf("æ‰“å¼€æ–‡ä»¶å¤±è´¥: %v", err) // ä¹Ÿè¿”å›é”™è¯¯
    }
    defer file.Close()
    return nil
}

// å¥½çš„åšæ³•: åªåœ¨ä¸€ä¸ªåœ°æ–¹å¤„ç†é”™è¯¯
func goodErrorHandling(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        // åªæ·»åŠ ä¸Šä¸‹æ–‡å¹¶è¿”å›ï¼Œä¸è®°å½•æ—¥å¿—
        return fmt.Errorf("æ‰“å¼€æ–‡ä»¶ %s å¤±è´¥: %w", filename, err)
    }
    defer file.Close()
    return nil
}

// åœ¨é€‚å½“çš„åœ°æ–¹å¤„ç†é”™è¯¯
func main() {
    err := goodErrorHandling("config.json")
    if err != nil {
        // åœ¨ç¨‹åºçš„é¡¶å±‚è®°å½•å¹¶å¤„ç†é”™è¯¯
        log.Printf("åˆå§‹åŒ–å¤±è´¥: %v", err)
        os.Exit(1)
    }
}
```

### 5.2 å“¨å…µé”™è¯¯ä¸ç±»å‹é”™è¯¯çš„é€‰æ‹©
- **å“¨å…µé”™è¯¯**ï¼šä½¿ç”¨é¢„å®šä¹‰çš„é”™è¯¯å˜é‡è¿›è¡Œæ¯”è¾ƒ
- **ç±»å‹é”™è¯¯**ï¼šä½¿ç”¨ç±»å‹æ–­è¨€æˆ–`errors.As`æå–é”™è¯¯ä¿¡æ¯

```go
package main

import (
    "errors"
    "fmt"
    "io"
    "os"
)

// å“¨å…µé”™è¯¯ - é€‚ç”¨äºç®€å•æƒ…å†µ
var (
    ErrNotFound = errors.New("èµ„æºæœªæ‰¾åˆ°")
    ErrNoAccess = errors.New("æƒé™ä¸è¶³")
)

// ç±»å‹é”™è¯¯ - é€‚ç”¨äºéœ€è¦é¢å¤–ä¿¡æ¯çš„æƒ…å†µ
type NotFoundError struct {
    Resource string
}

func (e *NotFoundError) Error() string {
    return fmt.Sprintf("èµ„æº %s æœªæ‰¾åˆ°", e.Resource)
}

// æ ¹æ®åœºæ™¯é€‰æ‹©é”™è¯¯ç±»å‹
func findResource(id string) error {
    if id == "" {
        // ç®€å•æƒ…å†µï¼šä½¿ç”¨å“¨å…µé”™è¯¯
        return ErrNotFound
    }
    
    if len(id) < 3 {
        // éœ€è¦è¯¦ç»†ä¿¡æ¯ï¼šä½¿ç”¨ç±»å‹é”™è¯¯
        return &NotFoundError{Resource: id}
    }
    
    return nil
}

func main() {
    // å¤„ç†å“¨å…µé”™è¯¯
    err1 := findResource("")
    if errors.Is(err1, ErrNotFound) {
        fmt.Println("å¤„ç†æœªæ‰¾åˆ°é”™è¯¯")
    }
    
    // å¤„ç†ç±»å‹é”™è¯¯
    err2 := findResource("ab")
    var notFoundErr *NotFoundError
    if errors.As(err2, &notFoundErr) {
        fmt.Printf("å¤„ç†ç‰¹å®šèµ„æº %s æœªæ‰¾åˆ°\n", notFoundErr.Resource)
    }
    
    // å¤„ç†æ ‡å‡†åº“é”™è¯¯
    _, err3 := os.Open("ä¸å­˜åœ¨çš„æ–‡ä»¶.txt")
    if errors.Is(err3, os.ErrNotExist) {
        fmt.Println("æ–‡ä»¶ä¸å­˜åœ¨")
    }
    
    // io.EOFæ˜¯ç‰¹æ®Šæƒ…å†µï¼Œé€šå¸¸ä¸è§†ä¸ºé”™è¯¯
    var data []byte
    _, err4 := io.ReadFull(os.Stdin, data)
    if err4 == io.EOF {
        fmt.Println("å·²è¯»å–åˆ°æ–‡ä»¶æœ«å°¾")
    } else if err4 != nil {
        fmt.Println("è¯»å–é”™è¯¯:", err4)
    }
}
```

### 5.3 é€æ˜é”™è¯¯å¤„ç†
é€æ˜é”™è¯¯å…è®¸è°ƒç”¨è€…æ£€æŸ¥å’Œå¤„ç†ç‰¹å®šé”™è¯¯æ¡ä»¶ï¼š

```go
package main

import (
    "errors"
    "fmt"
    "io"
    "os"
)

// å®šä¹‰åŸŸé”™è¯¯
var (
    ErrInvalidInput = errors.New("è¾“å…¥æ— æ•ˆ")
    ErrNotFound     = errors.New("èµ„æºæœªæ‰¾åˆ°")
)

// ä½çº§å‡½æ•°ï¼šè¿”å›ç‰¹å®šé”™è¯¯
func validateInput(input string) error {
    if input == "" {
        return ErrInvalidInput
    }
    return nil
}

// ä¸­é—´å‡½æ•°ï¼šé€æ˜åœ°ä¼ é€’é”™è¯¯
func processInput(input string) error {
    if err := validateInput(input); err != nil {
        return fmt.Errorf("å¤„ç†è¾“å…¥å¤±è´¥: %w", err)
    }
    
    // ç»§ç»­å¤„ç†...
    return nil
}

// é«˜çº§å‡½æ•°ï¼šå¤„ç†ç‰¹å®šé”™è¯¯
func handleRequest(input string) error {
    if err := processInput(input); err != nil {
        // æ£€æŸ¥ç‰¹å®šé”™è¯¯ç±»å‹
        if errors.Is(err, ErrInvalidInput) {
            return fmt.Errorf("è¯·æ±‚å‚æ•°é”™è¯¯: %w", err)
        }
        
        // å¤„ç†å…¶ä»–é”™è¯¯
        return fmt.Errorf("è¯·æ±‚å¤„ç†å¤±è´¥: %w", err)
    }
    
    return nil
}

func main() {
    err := handleRequest("")
    
    // å³ä½¿ç»è¿‡å¤šå±‚åŒ…è£…ï¼Œä¹Ÿèƒ½æ£€æµ‹åˆ°åŸå§‹é”™è¯¯
    if errors.Is(err, ErrInvalidInput) {
        fmt.Println("è¾“å…¥éªŒè¯å¤±è´¥ï¼Œè¯·æä¾›æœ‰æ•ˆè¾“å…¥")
    } else {
        fmt.Println("é”™è¯¯:", err)
    }
}
```

### 5.4 é”™è¯¯å³æ§åˆ¶æµ
åœ¨Goä¸­ï¼Œé”™è¯¯å¤„ç†æ˜¯æ§åˆ¶æµçš„ä¸€éƒ¨åˆ†ï¼Œå¯ä»¥åˆ©ç”¨è¿™ä¸€ç‰¹æ€§è®¾è®¡ä¼˜é›…çš„é”™è¯¯å¤„ç†æµç¨‹ï¼š

```go
package main

import (
    "errors"
    "fmt"
)

// é”™è¯¯ç±»å‹
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("å­—æ®µ %s éªŒè¯å¤±è´¥: %s", e.Field, e.Message)
}

// éªŒè¯å‡½æ•°
func validateUser(name, email string) error {
    if name == "" {
        return &ValidationError{Field: "name", Message: "å§“åä¸èƒ½ä¸ºç©º"}
    }
    
    if len(name) < 3 {
        return &ValidationError{Field: "name", Message: "å§“åé•¿åº¦ä¸è¶³"}
    }
    
    if email == "" {
        return &ValidationError{Field: "email", Message: "é‚®ç®±ä¸èƒ½ä¸ºç©º"}
    }
    
    if !strings.Contains(email, "@") {
        return &ValidationError{Field: "email", Message: "é‚®ç®±æ ¼å¼æ— æ•ˆ"}
    }
    
    return nil
}

func main() {
    // ç¬¬ä¸€ä¸ªä¾‹å­ï¼šæœ‰æ•ˆè¾“å…¥
    if err := validateUser("å¼ ä¸‰", "zhangsan@example.com"); err != nil {
        fmt.Println("éªŒè¯å¤±è´¥:", err)
    } else {
        fmt.Println("éªŒè¯æˆåŠŸ")
    }
    
    // ç¬¬äºŒä¸ªä¾‹å­ï¼šæ— æ•ˆè¾“å…¥
    err := validateUser("", "invalid-email")
    
    // ä½¿ç”¨ç±»å‹æ–­è¨€å¤„ç†ç‰¹å®šé”™è¯¯
    var validErr *ValidationError
    if errors.As(err, &validErr) {
        switch validErr.Field {
        case "name":
            fmt.Println("å§“åé”™è¯¯:", validErr.Message)
        case "email":
            fmt.Println("é‚®ç®±é”™è¯¯:", validErr.Message)
        }
    }
}
```

---

## 6. é«˜çº§é”™è¯¯å¤„ç†æŠ€æœ¯

### 6.1 é”™è¯¯å¤„ç†å‡½æ•°
åˆ›å»ºè¾…åŠ©å‡½æ•°å¤„ç†å¸¸è§é”™è¯¯æ¨¡å¼ï¼š

```go
package main

import (
    "database/sql"
    "errors"
    "fmt"
    "log"
)

// é€šç”¨é”™è¯¯å¤„ç†å‡½æ•°
func handleError(err error, message string) {
    if err != nil {
        log.Printf("%s: %v", message, err)
    }
}

// ä¸“é—¨å¤„ç†SQLé”™è¯¯çš„å‡½æ•°
func handleSQLError(err error) error {
    if err == nil {
        return nil
    }
    
    if errors.Is(err, sql.ErrNoRows) {
        return fmt.Errorf("æœªæ‰¾åˆ°è®°å½•: %w", err)
    }
    
    return fmt.Errorf("æ•°æ®åº“é”™è¯¯: %w", err)
}

// åŒ…è£…å¹¶è®°å½•é”™è¯¯
func logAndWrapError(err error, message string) error {
    if err == nil {
        return nil
    }
    
    log.Printf("%s: %v", message, err)
    return fmt.Errorf("%s: %w", message, err)
}

// åœ¨ç‰¹å®šæ¡ä»¶ä¸‹å¿½ç•¥é”™è¯¯
func ignoreSpecificError(err error, ignoredErr error) error {
    if err == nil || errors.Is(err, ignoredErr) {
        return nil
    }
    return err
}

func main() {
    // ç¤ºä¾‹1: é€šç”¨é”™è¯¯å¤„ç†
    err1 := errors.New("ç¤ºä¾‹é”™è¯¯")
    handleError(err1, "æ“ä½œå¤±è´¥")
    
    // ç¤ºä¾‹2: å¤„ç†SQLé”™è¯¯
    err2 := sql.ErrNoRows
    wrappedErr := handleSQLError(err2)
    fmt.Println("åŒ…è£…åçš„é”™è¯¯:", wrappedErr)
    
    // ç¤ºä¾‹3: è®°å½•å¹¶åŒ…è£…é”™è¯¯
    err3 := errors.New("åº•å±‚é”™è¯¯")
    finalErr := logAndWrapError(err3, "ä¸šåŠ¡æ“ä½œå¤±è´¥")
    fmt.Println("æœ€ç»ˆé”™è¯¯:", finalErr)
    
    // ç¤ºä¾‹4: å¿½ç•¥ç‰¹å®šé”™è¯¯
    err4 := ignoreSpecificError(sql.ErrNoRows, sql.ErrNoRows)
    if err4 == nil {
        fmt.Println("é”™è¯¯å·²è¢«å¿½ç•¥")
    }
}
```

### 6.2 é”™è¯¯é‡è¯•ç­–ç•¥
å¯¹ä¸´æ—¶æ€§é”™è¯¯å®ç°é‡è¯•æœºåˆ¶ï¼š

```go
package main

import (
    "errors"
    "fmt"
    "math/rand"
    "time"
)

// æ¨¡æ‹Ÿä¸ç¨³å®šçš„æ“ä½œ
func unstableOperation() error {
    // 30%æ¦‚ç‡å¤±è´¥
    if rand.Float32() < 0.3 {
        return errors.New("ä¸´æ—¶æ€§ç½‘ç»œé”™è¯¯")
    }
    return nil
}

// å¸¦æŒ‡æ•°é€€é¿çš„é‡è¯•
func retryWithBackoff(maxRetries int, op func() error) error {
    var err error
    
    for attempt := 0; attempt < maxRetries; attempt++ {
        err = op()
        if err == nil {
            return nil // æˆåŠŸï¼Œæ— éœ€é‡è¯•
        }
        
        // è®¡ç®—é€€é¿æ—¶é—´ï¼š2^attempt * 100ms
        backoffTime := time.Duration(1<<uint(attempt)) * 100 * time.Millisecond
        maxJitter := time.Duration(10 * time.Millisecond)
        jitter := time.Duration(rand.Int63n(int64(maxJitter)))
        sleepTime := backoffTime + jitter
        
        fmt.Printf("å°è¯• %d å¤±è´¥: %v, å°†åœ¨ %v åé‡è¯•\n", 
                   attempt+1, err, sleepTime)
        
        time.Sleep(sleepTime)
    }
    
    return fmt.Errorf("æ“ä½œå¤±è´¥ï¼Œå·²é‡è¯• %d æ¬¡: %w", maxRetries, err)
}

func main() {
    rand.Seed(time.Now().UnixNano())
    
    // æ‰§è¡Œä¸ç¨³å®šæ“ä½œï¼Œæœ€å¤šé‡è¯•5æ¬¡
    err := retryWithBackoff(5, unstableOperation)
    if err != nil {
        fmt.Println("æœ€ç»ˆé”™è¯¯:", err)
    } else {
        fmt.Println("æ“ä½œæˆåŠŸå®Œæˆ")
    }
}
```

### 6.3 é”™è¯¯åˆ†ç»„å’Œèšåˆ
å¤„ç†å¤šä¸ªæ“ä½œäº§ç”Ÿçš„å¤šä¸ªé”™è¯¯ï¼š

```go
package main

import (
    "errors"
    "fmt"
    "strings"
    "sync"
)

// é”™è¯¯é›†åˆ
type ErrorGroup struct {
    errors []error
    mu     sync.Mutex
}

// æ·»åŠ é”™è¯¯
func (g *ErrorGroup) Add(err error) {
    if err == nil {
        return
    }
    
    g.mu.Lock()
    defer g.mu.Unlock()
    
    g.errors = append(g.errors, err)
}

// å®ç°erroræ¥å£
func (g *ErrorGroup) Error() string {
    if len(g.errors) == 0 {
        return ""
    }
    
    g.mu.Lock()
    defer g.mu.Unlock()
    
    messages := make([]string, len(g.errors))
    for i, err := range g.errors {
        messages[i] = err.Error()
    }
    
    return fmt.Sprintf("%d ä¸ªé”™è¯¯: [%s]", 
                       len(g.errors), 
                       strings.Join(messages, "; "))
}

// è·å–é”™è¯¯æ•°é‡
func (g *ErrorGroup) Count() int {
    g.mu.Lock()
    defer g.mu.Unlock()
    
    return len(g.errors)
}

// æ˜¯å¦æœ‰é”™è¯¯
func (g *ErrorGroup) HasErrors() bool {
    return g.Count() > 0
}

// å¹¶è¡Œæ‰§è¡Œä»»åŠ¡å¹¶æ”¶é›†é”™è¯¯
func main() {
    // åˆ›å»ºé”™è¯¯ç»„
    errGroup := &ErrorGroup{}
    
    // ä»»åŠ¡åˆ—è¡¨
    tasks := []func() error{
        func() error { return errors.New("ä»»åŠ¡1å¤±è´¥") },
        func() error { return nil }, // æˆåŠŸ
        func() error { return errors.New("ä»»åŠ¡3å¤±è´¥") },
        func() error { return nil }, // æˆåŠŸ
        func() error { return errors.New("ä»»åŠ¡5å¤±è´¥") },
    }
    
    // å¹¶è¡Œæ‰§è¡Œä»»åŠ¡
    var wg sync.WaitGroup
    for i, task := range tasks {
        wg.Add(1)
        go func(id int, t func() error) {
            defer wg.Done()
            
            if err := t(); err != nil {
                errGroup.Add(err)
                fmt.Printf("ä»»åŠ¡ %d å¤±è´¥: %v\n", id, err)
            } else {
                fmt.Printf("ä»»åŠ¡ %d æˆåŠŸ\n", id)
            }
        }(i, task)
    }
    
    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    wg.Wait()
    
    // æ£€æŸ¥é”™è¯¯
    if errGroup.HasErrors() {
        fmt.Printf("æœ‰ %d ä¸ªä»»åŠ¡å¤±è´¥: %v\n", errGroup.Count(), errGroup)
    } else {
        fmt.Println("æ‰€æœ‰ä»»åŠ¡æˆåŠŸå®Œæˆ")
    }
}
```

### 6.4 ä½¿ç”¨ä¸­é—´ä»¶å¤„ç†é”™è¯¯
åœ¨Webåº”ç”¨ä¸­ä½¿ç”¨ä¸­é—´ä»¶å¤„ç†é”™è¯¯ï¼š

```go
package main

import (
    "errors"
    "fmt"
    "log"
    "net/http"
)

// åº”ç”¨é”™è¯¯ç±»å‹
type AppError struct {
    Code    int
    Message string
    Err     error
}

func (e *AppError) Error() string {
    if e.Err != nil {
        return fmt.Sprintf("%s: %v", e.Message, e.Err)
    }
    return e.Message
}

func (e *AppError) Unwrap() error {
    return e.Err
}

// å¤„ç†å‡½æ•°ç±»å‹ï¼Œå¯ä»¥è¿”å›é”™è¯¯
type AppHandler func(http.ResponseWriter, *http.Request) error

// é”™è¯¯å¤„ç†ä¸­é—´ä»¶
func (fn AppHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    err := fn(w, r)
    if err == nil {
        return
    }
    
    // è®°å½•é”™è¯¯
    log.Printf("å¤„ç†è¯·æ±‚é”™è¯¯: %v", err)
    
    // è½¬æ¢ä¸ºHTTPé”™è¯¯
    var appErr *AppError
    if errors.As(err, &appErr) {
        http.Error(w, appErr.Message, appErr.Code)
        return
    }
    
    // é»˜è®¤ä¸ºå†…éƒ¨æœåŠ¡å™¨é”™è¯¯
    http.Error(w, "å†…éƒ¨æœåŠ¡å™¨é”™è¯¯", http.StatusInternalServerError)
}

// ç¤ºä¾‹å¤„ç†å‡½æ•°
func getUser(w http.ResponseWriter, r *http.Request) error {
    userID := r.URL.Query().Get("id")
    
    if userID == "" {
        return &AppError{
            Code:    http.StatusBadRequest,
            Message: "ç¼ºå°‘ç”¨æˆ·ID",
        }
    }
    
    if userID == "invalid" {
        return &AppError{
            Code:    http.StatusNotFound,
            Message: "ç”¨æˆ·ä¸å­˜åœ¨",
            Err:     errors.New("ç”¨æˆ·IDæ— æ•ˆ"),
        }
    }
    
    // æ¨¡æ‹Ÿæ•°æ®åº“é”™è¯¯
    if userID == "error" {
        dbErr := errors.New("æ•°æ®åº“è¿æ¥å¤±è´¥")
        return &AppError{
            Code:    http.StatusInternalServerError,
            Message: "æœåŠ¡å™¨é”™è¯¯",
            Err:     fmt.Errorf("æŸ¥è¯¢ç”¨æˆ·å¤±è´¥: %w", dbErr),
        }
    }
    
    // æˆåŠŸå¤„ç†
    fmt.Fprintf(w, "ç”¨æˆ·ID: %s\n", userID)
    return nil
}

func main() {
    // æ³¨å†Œå¤„ç†å‡½æ•°
    http.Handle("/user", AppHandler(getUser))
    
    // å¯åŠ¨æœåŠ¡å™¨
    port := ":8080"
    fmt.Printf("æœåŠ¡å™¨å¯åŠ¨åœ¨ %s\n", port)
    fmt.Println("å°è¯•è®¿é—®: http://localhost:8080/user?id=123")
    fmt.Println("æµ‹è¯•é”™è¯¯: http://localhost:8080/user?id=invalid")
    fmt.Println("æµ‹è¯•æœåŠ¡å™¨é”™è¯¯: http://localhost:8080/user?id=error")
    
    log.Fatal(http.ListenAndServe(port, nil))
}
```

---

## 7. ç¬¬ä¸‰æ–¹é”™è¯¯å¤„ç†åº“

### 7.1 pkg/errors
`github.com/pkg/errors`æ˜¯ä¸€ä¸ªæµè¡Œçš„é”™è¯¯å¤„ç†åº“ï¼Œæä¾›äº†é¢å¤–çš„é”™è¯¯åŒ…è£…å’Œå †æ ˆè·Ÿè¸ªåŠŸèƒ½ï¼š

```go
package main

import (
    "fmt"
    
    "github.com/pkg/errors"
)

// ä½å±‚å‡½æ•°
func readDatabase() error {
    return errors.New("æ•°æ®åº“è¿æ¥å¤±è´¥")
}

// ä¸­å±‚å‡½æ•°
func getUserData(id string) error {
    if err := readDatabase(); err != nil {
        return errors.Wrapf(err, "è·å–ç”¨æˆ· %s æ•°æ®å¤±è´¥", id)
    }
    return nil
}

// é«˜å±‚å‡½æ•°
func processUserRequest(id string) error {
    if err := getUserData(id); err != nil {
        return errors.Wrap(err, "å¤„ç†ç”¨æˆ·è¯·æ±‚å¤±è´¥")
    }
    return nil
}

// è¾…åŠ©å‡½æ•°ï¼šæ‰“å°é”™è¯¯å’Œå †æ ˆè·Ÿè¸ª
func printError(err error) {
    fmt.Printf("é”™è¯¯: %v\n", err)
    fmt.Printf("é”™è¯¯ç±»å‹: %T\n", errors.Cause(err))
    fmt.Printf("æ ¹æœ¬åŸå› : %v\n", errors.Cause(err))
    fmt.Println("\nå †æ ˆè·Ÿè¸ª:")
    fmt.Printf("%+v\n", err)
}

func main() {
    err := processUserRequest("123")
    if err != nil {
        printError(err)
    }
}
```

### 7.2 go-multierror
`github.com/hashicorp/go-multierror`æä¾›äº†èšåˆå¤šä¸ªé”™è¯¯çš„åŠŸèƒ½ï¼š

```go
package main

import (
    "fmt"
    
    "github.com/hashicorp/go-multierror"
)

// å¤šä¸ªæ“ä½œï¼Œå¯èƒ½æœ‰å¤šä¸ªé”™è¯¯
func performOperations() error {
    var result *multierror.Error
    
    // æ“ä½œ1
    if err := operation1(); err != nil {
        result = multierror.Append(result, err)
    }
    
    // æ“ä½œ2
    if err := operation2(); err != nil {
        result = multierror.Append(result, err)
    }
    
    // æ“ä½œ3
    if err := operation3(); err != nil {
        result = multierror.Append(result, err)
    }
    
    return result.ErrorOrNil()
}

// æ¨¡æ‹Ÿæ“ä½œ
func operation1() error {
    return nil // æˆåŠŸ
}

func operation2() error {
    return fmt.Errorf("æ“ä½œ2å¤±è´¥")
}

func operation3() error {
    return fmt.Errorf("æ“ä½œ3å¤±è´¥")
}

func main() {
    err := performOperations()
    if err != nil {
        fmt.Printf("é”™è¯¯: %v\n", err)
        
        // ç±»å‹æ–­è¨€æ£€æŸ¥æ˜¯å¦ä¸ºå¤šé”™è¯¯
        if merr, ok := err.(*multierror.Error); ok {
            fmt.Printf("é”™è¯¯æ•°é‡: %d\n", len(merr.Errors))
            
            // è¿­ä»£æ¯ä¸ªé”™è¯¯
            for i, err := range merr.Errors {
                fmt.Printf("é”™è¯¯ %d: %v\n", i+1, err)
            }
        }
    } else {
        fmt.Println("æ‰€æœ‰æ“ä½œæˆåŠŸ")
    }
}
```

---

## 8. ç»¼åˆæ¡ˆä¾‹ï¼šå¥å£®çš„WebæœåŠ¡

ä¸‹é¢æ˜¯ä¸€ä¸ªå®ç°äº†å¤šç§é”™è¯¯å¤„ç†æŠ€æœ¯çš„å®Œæ•´WebæœåŠ¡ç¤ºä¾‹ï¼š

```go
package main

import (
    "context"
    "database/sql"
    "encoding/json"
    "errors"
    "fmt"
    "log"
    "net/http"
    "os"
    "time"
    
    _ "github.com/mattn/go-sqlite3"
)

// =========== é”™è¯¯å®šä¹‰ ===========

// é”™è¯¯ç±»å‹
type APIError struct {
    Code       int
    Message    string
    Detail     string
    Err        error
    RequestID  string
    StatusCode int
}

func (e *APIError) Error() string {
    if e.Detail != "" {
        return fmt.Sprintf("%s: %s", e.Message, e.Detail)
    }
    return e.Message
}

func (e *APIError) Unwrap() error {
    return e.Err
}

// é¢„å®šä¹‰é”™è¯¯
var (
    ErrNotFound     = &APIError{Code: 1001, Message: "èµ„æºæœªæ‰¾åˆ°", StatusCode: http.StatusNotFound}
    ErrInvalidInput = &APIError{Code: 1002, Message: "æ— æ•ˆè¾“å…¥", StatusCode: http.StatusBadRequest}
    ErrInternal     = &APIError{Code: 1003, Message: "å†…éƒ¨æœåŠ¡é”™è¯¯", StatusCode: http.StatusInternalServerError}
    ErrUnauthorized = &APIError{Code: 1004, Message: "æœªæˆæƒ", StatusCode: http.StatusUnauthorized}
)

// åˆ›å»ºä¸šåŠ¡é”™è¯¯
func NewAPIError(base *APIError, detail string, err error, requestID string) *APIError {
    return &APIError{
        Code:       base.Code,
        Message:    base.Message,
        Detail:     detail,
        Err:        err,
        RequestID:  requestID,
        StatusCode: base.StatusCode,
    }
}

// =========== æ•°æ®æ¨¡å‹ ===========

type User struct {
    ID       int    `json:"id"`
    Name     string `json:"name"`
    Email    string `json:"email"`
    Password string `json:"-"` // ä¸ä¼šåœ¨JSONä¸­æš´éœ²
}

// =========== è¯·æ±‚ä¸Šä¸‹æ–‡ ===========

type requestIDKey struct{}

// ç”Ÿæˆè¯·æ±‚ID
func generateRequestID() string {
    return fmt.Sprintf("req-%d", time.Now().UnixNano())
}

// ä»ä¸Šä¸‹æ–‡è·å–è¯·æ±‚ID
func getRequestID(ctx context.Context) string {
    id, ok := ctx.Value(requestIDKey{}).(string)
    if !ok {
        return "unknown"
    }
    return id
}

// =========== æ•°æ®è®¿é—®å±‚ ===========

// æ•°æ®åº“æ“ä½œ
func getUserByID(ctx context.Context, db *sql.DB, id int) (*User, error) {
    // æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
    if id == 0 {
        return nil, sql.ErrNoRows
    }
    
    // å‡è®¾æ­£å¸¸æŸ¥è¯¢
    user := &User{
        ID:    id,
        Name:  fmt.Sprintf("ç”¨æˆ·%d", id),
        Email: fmt.Sprintf("user%d@example.com", id),
    }
    
    return user, nil
}

// =========== ä¸šåŠ¡é€»è¾‘å±‚ ===========

// è·å–ç”¨æˆ·æœåŠ¡
func getUserService(ctx context.Context, db *sql.DB, id int) (*User, error) {
    requestID := getRequestID(ctx)
    
    // å‚æ•°éªŒè¯
    if id <= 0 {
        return nil, NewAPIError(ErrInvalidInput, 
                               "ç”¨æˆ·IDå¿…é¡»ä¸ºæ­£æ•°", 
                               nil, 
                               requestID)
    }
    
    // æŸ¥è¯¢æ•°æ®åº“
    user, err := getUserByID(ctx, db, id)
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, NewAPIError(ErrNotFound, 
                                   fmt.Sprintf("IDä¸º%dçš„ç”¨æˆ·ä¸å­˜åœ¨", id), 
                                   err, 
                                   requestID)
        }
        
        return nil, NewAPIError(ErrInternal, 
                               "æ•°æ®åº“æŸ¥è¯¢å¤±è´¥", 
                               err, 
                               requestID)
    }
    
    return user, nil
}

// =========== APIå¤„ç†å±‚ ===========

// APIå¤„ç†å‡½æ•°ç±»å‹
type APIHandler func(http.ResponseWriter, *http.Request) error

// é”™è¯¯å¤„ç†ä¸­é—´ä»¶
func (fn APIHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // ç”Ÿæˆè¯·æ±‚ID
    requestID := generateRequestID()
    
    // æ·»åŠ è¯·æ±‚IDåˆ°ä¸Šä¸‹æ–‡
    ctx := context.WithValue(r.Context(), requestIDKey{}, requestID)
    r = r.WithContext(ctx)
    
    // è®¾ç½®è¯·æ±‚IDå“åº”å¤´
    w.Header().Set("X-Request-ID", requestID)
    
    // è°ƒç”¨å¤„ç†å‡½æ•°
    err := fn(w, r)
    if err == nil {
        return
    }
    
    // è®°å½•é”™è¯¯
    log.Printf("[é”™è¯¯] è¯·æ±‚ID=%s: %v", requestID, err)
    
    // å“åº”å¤„ç†
    w.Header().Set("Content-Type", "application/json")
    
    var apiErr *APIError
    if !errors.As(err, &apiErr) {
        // é»˜è®¤ä¸ºå†…éƒ¨é”™è¯¯
        apiErr = NewAPIError(ErrInternal, "æœªå¤„ç†çš„é”™è¯¯", err, requestID)
    }
    
    // è®¾ç½®çŠ¶æ€ç 
    w.WriteHeader(apiErr.StatusCode)
    
    // æ„å»ºé”™è¯¯å“åº”
    response := map[string]interface{}{
        "error": map[string]interface{}{
            "code":      apiErr.Code,
            "message":   apiErr.Message,
            "request_id": requestID,
        },
    }
    
    // åœ¨éç”Ÿäº§ç¯å¢ƒæ·»åŠ è¯¦æƒ…
    if os.Getenv("ENVIRONMENT") != "production" && apiErr.Detail != "" {
        response["error"].(map[string]interface{})["detail"] = apiErr.Detail
    }
    
    // åºåˆ—åŒ–å¹¶å“åº”
    if err := json.NewEncoder(w).Encode(response); err != nil {
        log.Printf("[é”™è¯¯] æ— æ³•ç¼–ç é”™è¯¯å“åº”: %v", err)
    }
}

// è·å–ç”¨æˆ·å¤„ç†å‡½æ•°
func getUserHandler(db *sql.DB) APIHandler {
    return func(w http.ResponseWriter, r *http.Request) error {
        // åªå…è®¸GETæ–¹æ³•
        if r.Method != http.MethodGet {
            return NewAPIError(ErrInvalidInput, 
                              fmt.Sprintf("ä¸æ”¯æŒçš„HTTPæ–¹æ³•: %s", r.Method), 
                              nil, 
                              getRequestID(r.Context()))
        }
        
        // è§£æç”¨æˆ·ID
        userID := 0
        if _, err := fmt.Sscanf(r.URL.Path, "/api/users/%d", &userID); err != nil {
            return NewAPIError(ErrInvalidInput, 
                              "æ— æ•ˆçš„ç”¨æˆ·IDæ ¼å¼", 
                              err, 
                              getRequestID(r.Context()))
        }
        
        // è°ƒç”¨ä¸šåŠ¡æœåŠ¡
        user, err := getUserService(r.Context(), db, userID)
        if err != nil {
            return err // æœåŠ¡å±‚å·²ç»åˆ›å»ºäº†APIError
        }
        
        // è®¾ç½®å†…å®¹ç±»å‹
        w.Header().Set("Content-Type", "application/json")
        
        // åºåˆ—åŒ–å“åº”
        if err := json.NewEncoder(w).Encode(user); err != nil {
            return NewAPIError(ErrInternal, 
                              "å“åº”åºåˆ—åŒ–å¤±è´¥", 
                              err, 
                              getRequestID(r.Context()))
        }
        
        return nil
    }
}

// =========== ä¸»ç¨‹åº ===========

func main() {
    // åˆå§‹åŒ–æ•°æ®åº“
    db, err := sql.Open("sqlite3", ":memory:")
    if err != nil {
        log.Fatalf("æ— æ³•æ‰“å¼€æ•°æ®åº“: %v", err)
    }
    defer db.Close()
    
    // æ³¨å†ŒAPIè·¯ç”±
    http.Handle("/api/users/", APIHandler(getUserHandler(db)))
    
    // å¯åŠ¨æœåŠ¡å™¨
    port := ":8080"
    log.Printf("æœåŠ¡å™¨å¯åŠ¨åœ¨ %s", port)
    log.Printf("ç¤ºä¾‹URL: http://localhost%s/api/users/1", port)
    log.Printf("é”™è¯¯ç¤ºä¾‹: http://localhost%s/api/users/0", port)
    
    log.Fatal(http.ListenAndServe(port, nil))
}
```

---

## 9. å­¦ä¹ æ£€æŸ¥ç‚¹

- [ ] ç†è§£Goè¯­è¨€çš„é”™è¯¯å¤„ç†æ¨¡å¼å’Œå“²å­¦
- [ ] æŒæ¡è‡ªå®šä¹‰é”™è¯¯ç±»å‹çš„å®šä¹‰å’Œä½¿ç”¨
- [ ] èƒ½ç”¨é”™è¯¯é“¾ä¼ é€’å’Œè§£åŒ…é”™è¯¯
- [ ] ç†Ÿç»ƒä½¿ç”¨`errors.Is`å’Œ`errors.As`å‡½æ•°
- [ ] äº†è§£ä¸Šä¸‹æ–‡ä¸­çš„é”™è¯¯å¤„ç†
- [ ] æŒæ¡é”™è¯¯å¤„ç†çš„æœ€ä½³å®è·µ
- [ ] èƒ½å®ç°é«˜çº§é”™è¯¯å¤„ç†æŠ€æœ¯
- [ ] åœ¨å®é™…é¡¹ç›®ä¸­åº”ç”¨ç»¼åˆé”™è¯¯å¤„ç†ç­–ç•¥

---

é”™è¯¯å¤„ç†æ˜¯Goè¯­è¨€çš„æ ¸å¿ƒç‰¹æ€§ä¹‹ä¸€ï¼ŒæŒæ¡è¿™äº›é«˜çº§æŠ€æœ¯å°†æ˜¾è‘—æå‡ç¨‹åºçš„å¥å£®æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚é€šè¿‡åˆç†çš„é”™è¯¯å¤„ç†è®¾è®¡ï¼Œä½ çš„ä»£ç å°†æ›´åŠ æ¸…æ™°ã€å¯é ä¸”æ˜“äºç»´æŠ¤ã€‚
