# Goè¯­è¨€é”™è¯¯å¤„ç†è¿›é˜¶

## ğŸ“š å­¦ä¹ ç›®æ ‡
æŒæ¡Goè¯­è¨€çš„é”™è¯¯å¤„ç†æ¨¡å¼ï¼Œç†è§£è‡ªå®šä¹‰é”™è¯¯ç±»å‹å’Œé”™è¯¯é“¾çš„ä½¿ç”¨ï¼Œå­¦ä¼šåœ¨ä¸Šä¸‹æ–‡ä¸­å¤„ç†é”™è¯¯ã€‚

---

## 1. é”™è¯¯å¤„ç†åŸºç¡€

### 1.1 ä½¿ç”¨`error`æ¥å£
```go
package main

import (
    "errors"
    "fmt"
)

func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("é™¤æ•°ä¸èƒ½ä¸ºé›¶")
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 0)
    if err != nil {
        fmt.Println("é”™è¯¯:", err)
    } else {
        fmt.Println("ç»“æœ:", result)
    }
}
```

---

## 2. è‡ªå®šä¹‰é”™è¯¯ç±»å‹

### 2.1 å®šä¹‰è‡ªå®šä¹‰é”™è¯¯
```go
package main

import (
    "fmt"
)

type DivideError struct {
    Dividend int
    Divisor  int
}

func (e DivideError) Error() string {
    return fmt.Sprintf("æ— æ³•è®¡ç®— %d / %d", e.Dividend, e.Divisor)
}

func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, DivideError{Dividend: a, Divisor: b}
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 0)
    if err != nil {
        fmt.Println("é”™è¯¯:", err)
    } else {
        fmt.Println("ç»“æœ:", result)
    }
}
```

---

## 3. é”™è¯¯é“¾

### 3.1 ä½¿ç”¨`fmt.Errorf`åˆ›å»ºé”™è¯¯é“¾
```go
package main

import (
    "fmt"
)

func readFile(filename string) error {
    return fmt.Errorf("è¯»å–æ–‡ä»¶å¤±è´¥: %w", fmt.Errorf("æ–‡ä»¶ %s ä¸å­˜åœ¨", filename))
}

func main() {
    err := readFile("data.txt")
    fmt.Println("é”™è¯¯é“¾:", err)
}
```

### 3.2 ä½¿ç”¨`errors.Unwrap`è§£åŒ…é”™è¯¯
```go
package main

import (
    "errors"
    "fmt"
)

func readFile(filename string) error {
    return fmt.Errorf("è¯»å–æ–‡ä»¶å¤±è´¥: %w", fmt.Errorf("æ–‡ä»¶ %s ä¸å­˜åœ¨", filename))
}

func main() {
    err := readFile("data.txt")
    fmt.Println("é”™è¯¯é“¾:", err)

    innerErr := errors.Unwrap(err)
    fmt.Println("å†…éƒ¨é”™è¯¯:", innerErr)
}
```

---

## 4. ä¸Šä¸‹æ–‡ä¸­çš„é”™è¯¯å¤„ç†

### 4.1 ä½¿ç”¨`context`ä¼ é€’é”™è¯¯
```go
package main

import (
    "context"
    "fmt"
    "time"
)

func doWork(ctx context.Context) error {
    select {
    case <-time.After(2 * time.Second):
        return fmt.Errorf("å·¥ä½œè¶…æ—¶")
    case <-ctx.Done():
        return ctx.Err()
    }
}

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
    defer cancel()

    err := doWork(ctx)
    if err != nil {
        fmt.Println("é”™è¯¯:", err)
    }
}
```

---

## 5. ç»¼åˆæ¡ˆä¾‹ï¼šæ–‡ä»¶å¤„ç†ç³»ç»Ÿ
```go
package main

import (
    "errors"
    "fmt"
    "os"
)

func readFile(filename string) (string, error) {
    file, err := os.Open(filename)
    if err != nil {
        return "", fmt.Errorf("æ‰“å¼€æ–‡ä»¶å¤±è´¥: %w", err)
    }
    defer file.Close()

    stat, err := file.Stat()
    if err != nil {
        return "", fmt.Errorf("è·å–æ–‡ä»¶ä¿¡æ¯å¤±è´¥: %w", err)
    }

    if stat.Size() == 0 {
        return "", errors.New("æ–‡ä»¶ä¸ºç©º")
    }

    content := make([]byte, stat.Size())
    _, err = file.Read(content)
    if err != nil {
        return "", fmt.Errorf("è¯»å–æ–‡ä»¶å¤±è´¥: %w", err)
    }

    return string(content), nil
}

func main() {
    content, err := readFile("data.txt")
    if err != nil {
        fmt.Println("é”™è¯¯:", err)
    } else {
        fmt.Println("æ–‡ä»¶å†…å®¹:", content)
    }
}
```

---

## 6. å­¦ä¹ æ£€æŸ¥ç‚¹

- [ ] ç†è§£Goè¯­è¨€çš„é”™è¯¯å¤„ç†æ¨¡å¼
- [ ] æŒæ¡è‡ªå®šä¹‰é”™è¯¯ç±»å‹çš„å®šä¹‰å’Œä½¿ç”¨
- [ ] èƒ½ç”¨é”™è¯¯é“¾ä¼ é€’å’Œè§£åŒ…é”™è¯¯
- [ ] èƒ½åœ¨ä¸Šä¸‹æ–‡ä¸­å¤„ç†é”™è¯¯
- [ ] èƒ½ç”¨é”™è¯¯å¤„ç†å®ç°å¤æ‚çš„ä¸šåŠ¡é€»è¾‘

---

é”™è¯¯å¤„ç†æ˜¯Goè¯­è¨€çš„æ ¸å¿ƒç‰¹æ€§ä¹‹ä¸€ï¼ŒæŒæ¡è¿™äº›åŸºç¡€å°†æ˜¾è‘—æå‡ç¨‹åºçš„å¥å£®æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚
