# Go语言错误处理进阶

## 📚 学习目标
掌握Go语言的错误处理模式，理解自定义错误类型和错误链的使用，学会在上下文中处理错误。

---

## 1. 错误处理基础

### 1.1 使用`error`接口
```go
package main

import (
    "errors"
    "fmt"
)

func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("除数不能为零")
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 0)
    if err != nil {
        fmt.Println("错误:", err)
    } else {
        fmt.Println("结果:", result)
    }
}
```

---

## 2. 自定义错误类型

### 2.1 定义自定义错误
```go
package main

import (
    "fmt"
)

type DivideError struct {
    Dividend int
    Divisor  int
}

func (e DivideError) Error() string {
    return fmt.Sprintf("无法计算 %d / %d", e.Dividend, e.Divisor)
}

func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, DivideError{Dividend: a, Divisor: b}
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 0)
    if err != nil {
        fmt.Println("错误:", err)
    } else {
        fmt.Println("结果:", result)
    }
}
```

---

## 3. 错误链

### 3.1 使用`fmt.Errorf`创建错误链
```go
package main

import (
    "fmt"
)

func readFile(filename string) error {
    return fmt.Errorf("读取文件失败: %w", fmt.Errorf("文件 %s 不存在", filename))
}

func main() {
    err := readFile("data.txt")
    fmt.Println("错误链:", err)
}
```

### 3.2 使用`errors.Unwrap`解包错误
```go
package main

import (
    "errors"
    "fmt"
)

func readFile(filename string) error {
    return fmt.Errorf("读取文件失败: %w", fmt.Errorf("文件 %s 不存在", filename))
}

func main() {
    err := readFile("data.txt")
    fmt.Println("错误链:", err)

    innerErr := errors.Unwrap(err)
    fmt.Println("内部错误:", innerErr)
}
```

---

## 4. 上下文中的错误处理

### 4.1 使用`context`传递错误
```go
package main

import (
    "context"
    "fmt"
    "time"
)

func doWork(ctx context.Context) error {
    select {
    case <-time.After(2 * time.Second):
        return fmt.Errorf("工作超时")
    case <-ctx.Done():
        return ctx.Err()
    }
}

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
    defer cancel()

    err := doWork(ctx)
    if err != nil {
        fmt.Println("错误:", err)
    }
}
```

---

## 5. 综合案例：文件处理系统
```go
package main

import (
    "errors"
    "fmt"
    "os"
)

func readFile(filename string) (string, error) {
    file, err := os.Open(filename)
    if err != nil {
        return "", fmt.Errorf("打开文件失败: %w", err)
    }
    defer file.Close()

    stat, err := file.Stat()
    if err != nil {
        return "", fmt.Errorf("获取文件信息失败: %w", err)
    }

    if stat.Size() == 0 {
        return "", errors.New("文件为空")
    }

    content := make([]byte, stat.Size())
    _, err = file.Read(content)
    if err != nil {
        return "", fmt.Errorf("读取文件失败: %w", err)
    }

    return string(content), nil
}

func main() {
    content, err := readFile("data.txt")
    if err != nil {
        fmt.Println("错误:", err)
    } else {
        fmt.Println("文件内容:", content)
    }
}
```

---

## 6. 学习检查点

- [ ] 理解Go语言的错误处理模式
- [ ] 掌握自定义错误类型的定义和使用
- [ ] 能用错误链传递和解包错误
- [ ] 能在上下文中处理错误
- [ ] 能用错误处理实现复杂的业务逻辑

---

错误处理是Go语言的核心特性之一，掌握这些基础将显著提升程序的健壮性和可维护性。
