# Goè¯­è¨€åå°„æœºåˆ¶

## ğŸ“š å­¦ä¹ ç›®æ ‡
æŒæ¡Goè¯­è¨€çš„åå°„æœºåˆ¶ï¼Œç†è§£è¿è¡Œæ—¶ç±»å‹ä¿¡æ¯ä¸æ“ä½œçš„åŸç†ï¼Œå­¦ä¼šåœ¨é€‚å½“åœºæ™¯ä¸‹ä½¿ç”¨åå°„å®ç°åŠ¨æ€ç¼–ç¨‹ï¼Œå¹¶äº†è§£åå°„çš„æ€§èƒ½å½±å“å’Œæœ€ä½³å®è·µã€‚

---

## 1. åå°„åŸºç¡€

### 1.1 ä»€ä¹ˆæ˜¯åå°„
åå°„æ˜¯ç¨‹åºåœ¨è¿è¡Œæ—¶æ£€æŸ¥ã€åˆ†æå’Œä¿®æ”¹è‡ªèº«ç»“æ„ä¸è¡Œä¸ºçš„èƒ½åŠ›ã€‚åœ¨Goè¯­è¨€ä¸­ï¼Œåå°„ä¸»è¦é€šè¿‡`reflect`åŒ…å®ç°ï¼Œå…è®¸ç¨‹åºï¼š

- æ£€æŸ¥å˜é‡çš„ç±»å‹ä¿¡æ¯
- è·å–å’Œä¿®æ”¹å˜é‡çš„å€¼
- è°ƒç”¨å‡½æ•°å’Œæ–¹æ³•
- åˆ›å»ºæ–°çš„æ•°æ®ç»“æ„
- æ“ä½œç»“æ„ä½“å­—æ®µå’Œæ ‡ç­¾

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    // åå°„çš„ä¸‰å¤§æ³•åˆ™æ¼”ç¤º
    
    // 1. ä»æ¥å£å€¼åˆ°åå°„å¯¹è±¡
    var x float64 = 3.14
    fmt.Println("åŸå§‹å€¼:", x)
    
    // æ¥å£å€¼ -> åå°„å¯¹è±¡
    v := reflect.ValueOf(x)
    t := reflect.TypeOf(x)
    
    fmt.Println("ç±»å‹:", t)
    fmt.Println("å€¼:", v)
    
    // 2. ä»åå°„å¯¹è±¡åˆ°æ¥å£å€¼
    i := v.Interface()
    y := i.(float64)
    fmt.Println("åå°„å›æ¥å£:", y)
    
    // 3. è¦ä¿®æ”¹åå°„å¯¹è±¡ï¼Œå¿…é¡»ä½¿å…¶å¯è®¾ç½®
    p := reflect.ValueOf(&x) // è·å–æŒ‡é’ˆçš„åå°„å€¼
    v2 := p.Elem()           // è·å–æŒ‡é’ˆæŒ‡å‘çš„å…ƒç´ 
    
    if v2.CanSet() {
        v2.SetFloat(2.71828)
        fmt.Println("ä¿®æ”¹å:", x)
    }
}
```

### 1.2 åå°„ä¸‰å¤§æ³•åˆ™

1. **ä»æ¥å£å€¼åˆ°åå°„å¯¹è±¡**ï¼š`reflect.ValueOf()` å’Œ `reflect.TypeOf()` å°†ä»»ä½•å€¼è½¬æ¢ä¸ºåå°„å¯¹è±¡
2. **ä»åå°„å¯¹è±¡åˆ°æ¥å£å€¼**ï¼š`Value.Interface()` å°†åå°„å¯¹è±¡è½¬å›æ¥å£å€¼
3. **è¦ä¿®æ”¹åå°„å¯¹è±¡ï¼Œå¿…é¡»ä½¿å…¶å¯è®¾ç½®**ï¼šåªæœ‰å½“åå°„å¯¹è±¡æ˜¯å¯è®¾ç½®çš„ï¼ˆè¡¨ç¤ºåº•å±‚å­˜å‚¨åœ°å€å¯è®¿é—®ï¼‰ï¼Œæ‰èƒ½ä¿®æ”¹å®ƒ

### 1.3 Typeå’ŒValue
åå°„åœ¨Goè¯­è¨€ä¸­ä¸»è¦æ¶‰åŠä¸¤ä¸ªé‡è¦ç±»å‹ï¼š

- **`reflect.Type`**ï¼šè¡¨ç¤ºGoè¯­è¨€çš„ç±»å‹ï¼Œç”±`reflect.TypeOf()`è¿”å›
- **`reflect.Value`**ï¼šè¡¨ç¤ºGoè¯­è¨€çš„å€¼ï¼Œç”±`reflect.ValueOf()`è¿”å›

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var num int = 42
    var str string = "Hello"
    
    // è·å–ç±»å‹ä¿¡æ¯
    numType := reflect.TypeOf(num)
    strType := reflect.TypeOf(str)
    
    fmt.Printf("numçš„ç±»å‹: %s\n", numType)
    fmt.Printf("strçš„ç±»å‹: %s\n", strType)
    
    // è·å–å€¼ä¿¡æ¯
    numValue := reflect.ValueOf(num)
    strValue := reflect.ValueOf(str)
    
    fmt.Printf("numçš„å€¼: %v\n", numValue)
    fmt.Printf("strçš„å€¼: %v\n", strValue)
    
    // ç±»å‹çš„ç§ç±»(Kind)
    fmt.Printf("numçš„ç§ç±»: %s\n", numType.Kind())
    fmt.Printf("strçš„ç§ç±»: %s\n", strType.Kind())
}
```

### 1.4 Kind vs Type
åœ¨åå°„ä¸­ï¼Œéœ€è¦ç†è§£ Typeï¼ˆç±»å‹ï¼‰å’Œ Kindï¼ˆç§ç±»ï¼‰çš„åŒºåˆ«ï¼š

- **Type**ï¼šç‰¹å®šçš„ç±»å‹ï¼Œå¦‚ `int`ã€`string`ã€`MyStruct` ç­‰
- **Kind**ï¼šåŸºç¡€ç±»å‹ç§ç±»ï¼Œå¦‚ `reflect.Int`ã€`reflect.String`ã€`reflect.Struct` ç­‰

```go
package main

import (
    "fmt"
    "reflect"
)

type MyInt int
type Person struct {
    Name string
    Age  int
}

func main() {
    var a MyInt = 42
    var p Person = Person{Name: "å¼ ä¸‰", Age: 30}
    
    ta := reflect.TypeOf(a)
    tp := reflect.TypeOf(p)
    
    fmt.Printf("açš„ç±»å‹: %s, ç§ç±»: %s\n", ta.Name(), ta.Kind())
    fmt.Printf("pçš„ç±»å‹: %s, ç§ç±»: %s\n", tp.Name(), tp.Kind())
    
    // å¯¹äºåˆ‡ç‰‡ã€æ˜ å°„ç­‰å¤åˆç±»å‹
    s := []int{1, 2, 3}
    ts := reflect.TypeOf(s)
    
    fmt.Printf("sçš„ç±»å‹: %s, ç§ç±»: %s\n", ts.Name(), ts.Kind())
    // æ³¨æ„ï¼šåˆ‡ç‰‡æ²¡æœ‰ç±»å‹åï¼Œåªæœ‰ç§ç±»
}
```

---

## 2. ç±»å‹ç³»ç»Ÿæ“ä½œ

### 2.1 åŸºæœ¬ç±»å‹æ“ä½œ
```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    // åŸºæœ¬ç±»å‹
    var i int = 42
    var f float64 = 3.14
    var b bool = true
    var s string = "hello"
    
    // æ£€æŸ¥ç±»å‹ä¿¡æ¯
    checkType(i)
    checkType(f)
    checkType(b)
    checkType(s)
    
    // æ£€æŸ¥ç±»å‹æ˜¯å¦å¯æ¯”è¾ƒ
    fmt.Printf("intæ˜¯å¦å¯æ¯”è¾ƒ: %v\n", reflect.TypeOf(i).Comparable())
    fmt.Printf("[]intæ˜¯å¦å¯æ¯”è¾ƒ: %v\n", reflect.TypeOf([]int{}).Comparable())
}

func checkType(v interface{}) {
    t := reflect.TypeOf(v)
    fmt.Printf("å€¼: %v, ç±»å‹: %s, ç§ç±»: %s, å¤§å°: %då­—èŠ‚\n", 
               v, t.Name(), t.Kind(), t.Size())
}
```

### 2.2 å¤åˆç±»å‹æ“ä½œ
```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    // æ•°ç»„ç±»å‹
    arr := [3]int{1, 2, 3}
    arrType := reflect.TypeOf(arr)
    fmt.Printf("æ•°ç»„: é•¿åº¦=%d, å…ƒç´ ç±»å‹=%s\n", 
               arrType.Len(), arrType.Elem())
    
    // åˆ‡ç‰‡ç±»å‹
    slice := []string{"a", "b", "c"}
    sliceType := reflect.TypeOf(slice)
    fmt.Printf("åˆ‡ç‰‡: å…ƒç´ ç±»å‹=%s\n", sliceType.Elem())
    
    // æ˜ å°„ç±»å‹
    m := map[string]int{"a": 1, "b": 2}
    mapType := reflect.TypeOf(m)
    fmt.Printf("æ˜ å°„: é”®ç±»å‹=%s, å€¼ç±»å‹=%s\n", 
               mapType.Key(), mapType.Elem())
    
    // é€šé“ç±»å‹
    ch := make(chan int)
    chType := reflect.TypeOf(ch)
    fmt.Printf("é€šé“: æ–¹å‘=%v, å…ƒç´ ç±»å‹=%s\n", 
               chType.ChanDir(), chType.Elem())
    
    // å‡½æ•°ç±»å‹
    fn := func(a int, b string) bool { return true }
    fnType := reflect.TypeOf(fn)
    fmt.Printf("å‡½æ•°: å…¥å‚æ•°é‡=%d, è¿”å›å€¼æ•°é‡=%d\n", 
               fnType.NumIn(), fnType.NumOut())
    
    for i := 0; i < fnType.NumIn(); i++ {
        fmt.Printf("  å‚æ•° %d: %s\n", i, fnType.In(i))
    }
    
    for i := 0; i < fnType.NumOut(); i++ {
        fmt.Printf("  è¿”å›å€¼ %d: %s\n", i, fnType.Out(i))
    }
}
```

### 2.3 ç»“æ„ä½“ç±»å‹è¯¦è§£
```go
package main

import (
    "fmt"
    "reflect"
)

type Address struct {
    City   string
    Street string
}

type Person struct {
    Name    string  `json:"name" validate:"required"`
    Age     int     `json:"age" validate:"min=0,max=150"`
    Address Address `json:"address"`
}

func main() {
    p := Person{
        Name: "å¼ ä¸‰",
        Age:  30,
        Address: Address{
            City:   "åŒ—äº¬",
            Street: "æœé˜³åŒº",
        },
    }
    
    t := reflect.TypeOf(p)
    
    // éå†ç»“æ„ä½“å­—æ®µ
    fmt.Printf("%s ç»“æ„ä½“æœ‰ %d ä¸ªå­—æ®µ:\n", t.Name(), t.NumField())
    
    for i := 0; i < t.NumField(); i++ {
        field := t.Field(i)
        fmt.Printf("  å­—æ®µ #%d: %s (%s)\n", i, field.Name, field.Type)
        
        // å­—æ®µæ ‡ç­¾
        if tag := field.Tag.Get("json"); tag != "" {
            fmt.Printf("    jsonæ ‡ç­¾: %s\n", tag)
        }
        
        if tag := field.Tag.Get("validate"); tag != "" {
            fmt.Printf("    éªŒè¯æ ‡ç­¾: %s\n", tag)
        }
        
        // æ£€æŸ¥åµŒå¥—å­—æ®µ
        if field.Type.Kind() == reflect.Struct {
            fmt.Printf("    åµŒå¥—ç»“æ„ä½“: %s æœ‰ %d ä¸ªå­—æ®µ\n", 
                      field.Type.Name(), field.Type.NumField())
        }
    }
    
    // é€šè¿‡åç§°è·å–å­—æ®µ
    if nameField, ok := t.FieldByName("Name"); ok {
        fmt.Printf("Nameå­—æ®µ: %+v\n", nameField)
    }
    
    // æ£€æŸ¥æ–¹æ³•
    fmt.Printf("%s ç±»å‹æœ‰ %d ä¸ªæ–¹æ³•\n", t.Name(), t.NumMethod())
}

// ä¸ºPersonæ·»åŠ æ–¹æ³•
func (p Person) SayHello() string {
    return "ä½ å¥½ï¼Œæˆ‘æ˜¯" + p.Name
}
```

---

## 3. å€¼æ“ä½œ

### 3.1 è·å–å’Œè®¾ç½®å€¼
```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    // åŸºæœ¬ç±»å‹æ“ä½œ
    var x int = 42
    v := reflect.ValueOf(&x).Elem() // è·å–å¯è®¾ç½®çš„å€¼
    
    fmt.Printf("åŸå§‹å€¼: %v\n", x)
    
    // æ£€æŸ¥æ˜¯å¦å¯è®¾ç½®
    if v.CanSet() {
        v.SetInt(100)
        fmt.Printf("æ–°å€¼: %v\n", x)
    }
    
    // å­—ç¬¦ä¸²æ“ä½œ
    var s string = "hello"
    sv := reflect.ValueOf(&s).Elem()
    
    if sv.CanSet() {
        sv.SetString("world")
        fmt.Printf("æ–°å­—ç¬¦ä¸²: %v\n", s)
    }
    
    // å¤åˆç±»å‹æ“ä½œ
    p := &struct {
        Name string
        Age  int
    }{"å¼ ä¸‰", 30}
    
    pv := reflect.ValueOf(p).Elem()
    
    // è·å–å­—æ®µå€¼
    nameField := pv.FieldByName("Name")
    ageField := pv.FieldByName("Age")
    
    fmt.Printf("åŸå§‹å­—æ®µ: Name=%v, Age=%v\n", nameField, ageField)
    
    // è®¾ç½®å­—æ®µå€¼
    if nameField.CanSet() {
        nameField.SetString("æå››")
    }
    
    if ageField.CanSet() {
        ageField.SetInt(35)
    }
    
    fmt.Printf("æ–°ç»“æ„ä½“: %+v\n", p)
}
```

### 3.2 æ•°ç»„å’Œåˆ‡ç‰‡æ“ä½œ
```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    // æ•°ç»„æ“ä½œ
    arr := [3]int{1, 2, 3}
    arrValue := reflect.ValueOf(&arr).Elem()
    
    fmt.Println("åŸå§‹æ•°ç»„:", arr)
    
    // ä¿®æ”¹æ•°ç»„å…ƒç´ 
    for i := 0; i < arrValue.Len(); i++ {
        elem := arrValue.Index(i)
        if elem.CanSet() {
            elem.SetInt(elem.Int() * 10)
        }
    }
    
    fmt.Println("ä¿®æ”¹åæ•°ç»„:", arr)
    
    // åˆ‡ç‰‡æ“ä½œ
    slice := []string{"a", "b", "c"}
    sliceValue := reflect.ValueOf(slice)
    
    fmt.Println("åŸå§‹åˆ‡ç‰‡:", slice)
    
    // éå†åˆ‡ç‰‡
    for i := 0; i < sliceValue.Len(); i++ {
        fmt.Printf("slice[%d] = %s\n", i, sliceValue.Index(i))
    }
    
    // åˆ›å»ºæ–°åˆ‡ç‰‡
    newSlice := reflect.MakeSlice(reflect.TypeOf(slice), 5, 10)
    
    // å¡«å……æ–°åˆ‡ç‰‡
    for i := 0; i < 5; i++ {
        newSlice.Index(i).SetString(fmt.Sprintf("å…ƒç´ %d", i))
    }
    
    // è½¬æ¢å›æ™®é€šåˆ‡ç‰‡
    result := newSlice.Interface().([]string)
    fmt.Println("æ–°åˆ‡ç‰‡:", result)
}
```

### 3.3 æ˜ å°„æ“ä½œ
```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    // æ˜ å°„æ“ä½œ
    m := map[string]int{"a": 1, "b": 2, "c": 3}
    mapValue := reflect.ValueOf(m)
    
    fmt.Println("åŸå§‹æ˜ å°„:", m)
    
    // è·å–æ‰€æœ‰é”®
    keys := mapValue.MapKeys()
    fmt.Println("æ‰€æœ‰é”®:")
    for _, key := range keys {
        fmt.Printf("  %s: %v\n", key, mapValue.MapIndex(key))
    }
    
    // åˆ›å»ºæ–°æ˜ å°„
    newMap := reflect.MakeMap(reflect.TypeOf(m))
    
    // æ·»åŠ é”®å€¼å¯¹
    newMap.SetMapIndex(
        reflect.ValueOf("x"),
        reflect.ValueOf(100),
    )
    newMap.SetMapIndex(
        reflect.ValueOf("y"),
        reflect.ValueOf(200),
    )
    
    // è½¬æ¢å›æ™®é€šæ˜ å°„
    result := newMap.Interface().(map[string]int)
    fmt.Println("æ–°æ˜ å°„:", result)
    
    // åˆ é™¤é”® (é€šè¿‡è®¾ç½®é›¶å€¼)
    newMap.SetMapIndex(reflect.ValueOf("x"), reflect.Value{})
    result = newMap.Interface().(map[string]int)
    fmt.Println("åˆ é™¤é”®å:", result)
}
```

### 3.4 å‡½æ•°å’Œæ–¹æ³•è°ƒç”¨
```go
package main

import (
    "fmt"
    "reflect"
)

func add(a, b int) int {
    return a + b
}

type Calculator struct {
    Name string
}

func (c Calculator) Multiply(a, b int) int {
    return a * b
}

func (c *Calculator) Divide(a, b int) (int, error) {
    if b == 0 {
        return 0, fmt.Errorf("é™¤æ•°ä¸èƒ½ä¸ºé›¶")
    }
    return a / b, nil
}

func main() {
    // å‡½æ•°è°ƒç”¨
    f := reflect.ValueOf(add)
    
    // å‡†å¤‡å‚æ•°
    args := []reflect.Value{
        reflect.ValueOf(10),
        reflect.ValueOf(20),
    }
    
    // è°ƒç”¨å‡½æ•°
    results := f.Call(args)
    
    // å¤„ç†ç»“æœ
    fmt.Println("10 + 20 =", results[0].Int())
    
    // æ–¹æ³•è°ƒç”¨
    c := Calculator{Name: "æˆ‘çš„è®¡ç®—å™¨"}
    cv := reflect.ValueOf(c)
    
    // è·å–æ–¹æ³•
    multiplyMethod := cv.MethodByName("Multiply")
    
    // è°ƒç”¨æ–¹æ³•
    multiplyArgs := []reflect.Value{
        reflect.ValueOf(5),
        reflect.ValueOf(7),
    }
    
    multiplyResults := multiplyMethod.Call(multiplyArgs)
    fmt.Println("5 * 7 =", multiplyResults[0].Int())
    
    // æŒ‡é’ˆæ¥æ”¶è€…æ–¹æ³•
    cp := &Calculator{Name: "æŒ‡é’ˆè®¡ç®—å™¨"}
    cpv := reflect.ValueOf(cp)
    
    divideMethod := cpv.MethodByName("Divide")
    
    divideArgs := []reflect.Value{
        reflect.ValueOf(20),
        reflect.ValueOf(4),
    }
    
    divideResults := divideMethod.Call(divideArgs)
    
    // å¤šè¿”å›å€¼å¤„ç†
    quotient := divideResults[0].Int()
    errValue := divideResults[1]
    
    if !errValue.IsNil() {
        fmt.Println("é”™è¯¯:", errValue.Interface().(error))
    } else {
        fmt.Println("20 / 4 =", quotient)
    }
}
```

---

## 4. åå°„ä¸æ¥å£

### 4.1 æ¥å£å€¼å‰–æ
```go
package main

import (
    "fmt"
    "reflect"
)

type Speaker interface {
    Speak() string
}

type Dog struct {
    Name string
}

func (d Dog) Speak() string {
    return d.Name + " says Woof!"
}

type Cat struct {
    Name string
}

func (c Cat) Speak() string {
    return c.Name + " says Meow!"
}

func examineInterface(i interface{}) {
    // è·å–æ¥å£çš„åŠ¨æ€ç±»å‹å’Œå€¼
    t := reflect.TypeOf(i)
    v := reflect.ValueOf(i)
    
    fmt.Printf("æ¥å£çš„åŠ¨æ€ç±»å‹: %s\n", t)
    fmt.Printf("æ¥å£çš„åŠ¨æ€å€¼: %+v\n", v)
    
    // æ£€æŸ¥æ˜¯å¦å®ç°äº†ç‰¹å®šæ¥å£
    speakerType := reflect.TypeOf((*Speaker)(nil)).Elem()
    fmt.Printf("æ˜¯å¦å®ç°Speakeræ¥å£: %v\n", t.Implements(speakerType))
    
    // å¦‚æœå®ç°äº†æ¥å£ï¼Œè°ƒç”¨æ¥å£æ–¹æ³•
    if t.Implements(speakerType) {
        method := v.MethodByName("Speak")
        result := method.Call(nil)
        fmt.Printf("è°ƒç”¨Speakæ–¹æ³•: %v\n", result[0])
    }
}

func main() {
    // æµ‹è¯•ä¸åŒç±»å‹
    examineInterface(Dog{Name: "Rover"})
    fmt.Println()
    examineInterface(Cat{Name: "Whiskers"})
    fmt.Println()
    examineInterface(42) // ä¸å®ç°Speakeræ¥å£
}
```

### 4.2 ç±»å‹æ–­è¨€ä¸åå°„å¯¹æ¯”
```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    // å‡†å¤‡ä¸€äº›å€¼
    values := []interface{}{
        42,
        "hello",
        true,
        []int{1, 2, 3},
        map[string]int{"a": 1, "b": 2},
    }
    
    fmt.Println("ä½¿ç”¨ç±»å‹æ–­è¨€:")
    for i, v := range values {
        switch x := v.(type) {
        case int:
            fmt.Printf("å€¼ %d æ˜¯æ•´æ•°: %d\n", i, x)
        case string:
            fmt.Printf("å€¼ %d æ˜¯å­—ç¬¦ä¸²: %s\n", i, x)
        case bool:
            fmt.Printf("å€¼ %d æ˜¯å¸ƒå°”å€¼: %v\n", i, x)
        case []int:
            fmt.Printf("å€¼ %d æ˜¯æ•´æ•°åˆ‡ç‰‡ï¼Œé•¿åº¦: %d\n", i, len(x))
        case map[string]int:
            fmt.Printf("å€¼ %d æ˜¯å­—ç¬¦ä¸²åˆ°æ•´æ•°çš„æ˜ å°„ï¼Œå¤§å°: %d\n", i, len(x))
        default:
            fmt.Printf("å€¼ %d æ˜¯æœªçŸ¥ç±»å‹\n", i)
        }
    }
    
    fmt.Println("\nä½¿ç”¨åå°„:")
    for i, v := range values {
        rv := reflect.ValueOf(v)
        rt := reflect.TypeOf(v)
        
        switch rt.Kind() {
        case reflect.Int:
            fmt.Printf("å€¼ %d æ˜¯æ•´æ•°: %d\n", i, rv.Int())
        case reflect.String:
            fmt.Printf("å€¼ %d æ˜¯å­—ç¬¦ä¸²: %s\n", i, rv.String())
        case reflect.Bool:
            fmt.Printf("å€¼ %d æ˜¯å¸ƒå°”å€¼: %v\n", i, rv.Bool())
        case reflect.Slice:
            fmt.Printf("å€¼ %d æ˜¯åˆ‡ç‰‡ï¼Œé•¿åº¦: %d\n", i, rv.Len())
        case reflect.Map:
            fmt.Printf("å€¼ %d æ˜¯æ˜ å°„ï¼Œå¤§å°: %d\n", i, rv.Len())
        default:
            fmt.Printf("å€¼ %d æ˜¯å…¶ä»–ç±»å‹: %s\n", i, rt.Kind())
        }
    }
}
```

### 4.3 åå°„å®ç°æ¥å£
```go
package main

import (
    "fmt"
    "reflect"
)

type Printer interface {
    Print()
}

// ä½¿ç”¨åå°„æ¥æ£€æŸ¥å’Œè°ƒç”¨æ¥å£æ–¹æ³•
func callPrint(p Printer) {
    // å¸¸è§„æ–¹å¼
    fmt.Println("å¸¸è§„è°ƒç”¨:")
    p.Print()
    
    // åå°„æ–¹å¼
    fmt.Println("åå°„è°ƒç”¨:")
    v := reflect.ValueOf(p)
    method := v.MethodByName("Print")
    method.Call(nil)
}

// ä¸¤ä¸ªå®ç°Printeræ¥å£çš„ç±»å‹
type Message struct {
    Text string
}

func (m Message) Print() {
    fmt.Println("æ¶ˆæ¯:", m.Text)
}

type Document struct {
    Title   string
    Content string
}

func (d Document) Print() {
    fmt.Println("æ–‡æ¡£:", d.Title)
    fmt.Println("å†…å®¹:", d.Content)
}

// ä½¿ç”¨åå°„åˆ›å»ºç±»å‹çš„æ–°å®ä¾‹
func createInstance(t reflect.Type) reflect.Value {
    // åˆ›å»ºç±»å‹çš„æ–°å®ä¾‹
    if t.Kind() == reflect.Struct {
        return reflect.New(t).Elem()
    }
    return reflect.Zero(t)
}

func main() {
    // æµ‹è¯•å¸¸è§„æ¥å£è°ƒç”¨
    m := Message{Text: "Hello, World!"}
    d := Document{Title: "åå°„æ–‡æ¡£", Content: "è¿™æ˜¯å…³äºåå°„çš„æ–‡æ¡£"}
    
    callPrint(m)
    fmt.Println()
    callPrint(d)
    
    // ä½¿ç”¨åå°„åˆ›å»ºæ–°å®ä¾‹
    messageType := reflect.TypeOf(Message{})
    newMessage := createInstance(messageType)
    
    // è®¾ç½®å­—æ®µå€¼
    if f := newMessage.FieldByName("Text"); f.IsValid() && f.CanSet() {
        f.SetString("è¿™æ˜¯é€šè¿‡åå°„åˆ›å»ºçš„æ¶ˆæ¯")
    }
    
    // è½¬æ¢ä¸ºæ¥å£å¹¶ä½¿ç”¨
    if msg, ok := newMessage.Interface().(Message); ok {
        fmt.Println("\nåå°„åˆ›å»ºçš„å®ä¾‹:")
        callPrint(msg)
    }
}
```

---

## 5. å®é™…åº”ç”¨åœºæ™¯

### 5.1 å®ç°ç®€å•çš„ORM
```go
package main

import (
    "database/sql"
    "fmt"
    "reflect"
    "strings"
)

// æ¨¡æ‹Ÿçš„æ•°æ®åº“è¿æ¥
type DB struct{}

func (db *DB) Query(query string, args ...interface{}) ([]map[string]interface{}, error) {
    // æ¨¡æ‹ŸæŸ¥è¯¢ç»“æœ
    result := []map[string]interface{}{
        {
            "id":      1,
            "name":    "å¼ ä¸‰",
            "age":     30,
            "email":   "zhangsan@example.com",
            "is_admin": true,
        },
        {
            "id":      2,
            "name":    "æå››",
            "age":     25,
            "email":   "lisi@example.com",
            "is_admin": false,
        },
    }
    return result, nil
}

// è¡¨ç»“æ„æ ‡ç­¾
type Table struct {
    Name string
}

// å­—æ®µæ ‡ç­¾
type Column struct {
    Name string
}

// ç”¨æˆ·æ¨¡å‹
type User struct {
    ID      int    `column:"id"`
    Name    string `column:"name"`
    Age     int    `column:"age"`
    Email   string `column:"email"`
    IsAdmin bool   `column:"is_admin"`
}

// ç®€å•ORM
type ORM struct {
    db *DB
}

func NewORM() *ORM {
    return &ORM{db: &DB{}}
}

// æ ¹æ®æ¨¡å‹ç”ŸæˆSQLæŸ¥è¯¢
func (orm *ORM) buildQuery(model interface{}) string {
    t := reflect.TypeOf(model)
    
    // æ£€æŸ¥æ˜¯å¦ä¸ºæŒ‡é’ˆï¼Œå¦‚æœæ˜¯åˆ™è·å–å…ƒç´ ç±»å‹
    if t.Kind() == reflect.Ptr {
        t = t.Elem()
    }
    
    // æ„å»ºå­—æ®µåˆ—è¡¨
    var columns []string
    
    // è·å–è¡¨å
    tableName := strings.ToLower(t.Name())
    
    // æ£€æŸ¥è¡¨åæ ‡ç­¾
    for i := 0; i < t.NumField(); i++ {
        field := t.Field(i)
        
        // ä»æ ‡ç­¾è·å–åˆ—å
        if column, ok := field.Tag.Lookup("column"); ok {
            columns = append(columns, column)
        } else {
            // é»˜è®¤ä½¿ç”¨å­—æ®µåè½¬å°å†™
            columns = append(columns, strings.ToLower(field.Name))
        }
    }
    
    // æ„å»ºæŸ¥è¯¢
    query := fmt.Sprintf("SELECT %s FROM %s", 
                         strings.Join(columns, ", "), 
                         tableName)
    return query
}

// å¡«å……ç»“æœåˆ°ç»“æ„ä½“
func (orm *ORM) scanIntoStruct(dest interface{}, data map[string]interface{}) {
    v := reflect.ValueOf(dest).Elem()
    t := v.Type()
    
    for i := 0; i < t.NumField(); i++ {
        field := t.Field(i)
        value := v.Field(i)
        
        // è·å–åˆ—å
        var columnName string
        if column, ok := field.Tag.Lookup("column"); ok {
            columnName = column
        } else {
            columnName = strings.ToLower(field.Name)
        }
        
        // è·å–æ•°æ®
        if dataValue, ok := data[columnName]; ok && value.CanSet() {
            // æ ¹æ®å­—æ®µç±»å‹è®¾ç½®å€¼
            switch value.Kind() {
            case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
                if intValue, ok := dataValue.(int); ok {
                    value.SetInt(int64(intValue))
                }
            case reflect.String:
                if strValue, ok := dataValue.(string); ok {
                    value.SetString(strValue)
                }
            case reflect.Bool:
                if boolValue, ok := dataValue.(bool); ok {
                    value.SetBool(boolValue)
                }
            }
        }
    }
}

// æŸ¥æ‰¾æ‰€æœ‰è®°å½•
func (orm *ORM) FindAll(dest interface{}) error {
    // è·å–åˆ‡ç‰‡å€¼
    sliceValue := reflect.ValueOf(dest).Elem()
    
    // è·å–åˆ‡ç‰‡å…ƒç´ ç±»å‹
    elemType := sliceValue.Type().Elem()
    
    // åˆ›å»ºä¸€ä¸ªå…ƒç´ çš„é›¶å€¼ç”¨äºç”ŸæˆæŸ¥è¯¢
    elemZero := reflect.Zero(elemType).Interface()
    
    // æ„å»ºæŸ¥è¯¢
    query := orm.buildQuery(elemZero)
    fmt.Println("æ‰§è¡ŒæŸ¥è¯¢:", query)
    
    // æ‰§è¡ŒæŸ¥è¯¢
    results, err := orm.db.Query(query)
    if err != nil {
        return err
    }
    
    // å¡«å……ç»“æœ
    for _, result := range results {
        // åˆ›å»ºæ–°å…ƒç´ 
        newElem := reflect.New(elemType)
        
        // å¡«å……æ•°æ®
        orm.scanIntoStruct(newElem.Interface(), result)
        
        // æ·»åŠ åˆ°åˆ‡ç‰‡
        sliceValue.Set(reflect.Append(sliceValue, newElem.Elem()))
    }
    
    return nil
}

func main() {
    orm := NewORM()
    
    // å‡†å¤‡æ¥æ”¶ç»“æœçš„åˆ‡ç‰‡
    var users []User
    
    // æŸ¥è¯¢æ‰€æœ‰ç”¨æˆ·
    err := orm.FindAll(&users)
    if err != nil {
        fmt.Println("æŸ¥è¯¢å‡ºé”™:", err)
        return
    }
    
    // æ˜¾ç¤ºç»“æœ
    fmt.Println("æŸ¥è¯¢åˆ°çš„ç”¨æˆ·:")
    for i, user := range users {
        fmt.Printf("ç”¨æˆ· #%d: ID=%d, åç§°=%s, å¹´é¾„=%d, é‚®ç®±=%s, æ˜¯å¦ç®¡ç†å‘˜=%v\n",
                  i+1, user.ID, user.Name, user.Age, user.Email, user.IsAdmin)
    }
}
```

### 5.2 å®ç°ä¾èµ–æ³¨å…¥
```go
package main

import (
    "fmt"
    "reflect"
)

// ä¾èµ–æ³¨å…¥å®¹å™¨
type Container struct {
    // å­˜å‚¨æ³¨å†Œçš„æœåŠ¡
    services map[reflect.Type]interface{}
}

// åˆ›å»ºæ–°å®¹å™¨
func NewContainer() *Container {
    return &Container{
        services: make(map[reflect.Type]interface{}),
    }
}

// æ³¨å†ŒæœåŠ¡
func (c *Container) Register(service interface{}) {
    t := reflect.TypeOf(service)
    c.services[t] = service
}

// æŒ‰ç±»å‹è·å–æœåŠ¡
func (c *Container) Get(t reflect.Type) (interface{}, bool) {
    service, ok := c.services[t]
    return service, ok
}

// è§£æç»“æ„ä½“å¹¶æ³¨å…¥ä¾èµ–
func (c *Container) Resolve(target interface{}) error {
    targetValue := reflect.ValueOf(target)
    
    // å¿…é¡»æ˜¯æŒ‡é’ˆ
    if targetValue.Kind() != reflect.Ptr {
        return fmt.Errorf("ç›®æ ‡å¿…é¡»æ˜¯æŒ‡é’ˆ")
    }
    
    // è·å–ç»“æ„ä½“å…ƒç´ 
    targetElem := targetValue.Elem()
    if targetElem.Kind() != reflect.Struct {
        return fmt.Errorf("ç›®æ ‡å¿…é¡»æ˜¯ç»“æ„ä½“æŒ‡é’ˆ")
    }
    
    targetType := targetElem.Type()
    
    // éå†æ‰€æœ‰å­—æ®µ
    for i := 0; i < targetElem.NumField(); i++ {
        field := targetElem.Field(i)
        fieldType := targetType.Field(i)
        
        // æ£€æŸ¥æ˜¯å¦å¯è®¾ç½®
        if !field.CanSet() {
            continue
        }
        
        // æŸ¥æ‰¾æ ‡è®°ä¸ºéœ€è¦æ³¨å…¥çš„å­—æ®µ
        if _, ok := fieldType.Tag.Lookup("inject"); ok {
            // æŸ¥æ‰¾å¯¹åº”ç±»å‹çš„æœåŠ¡
            service, found := c.Get(field.Type())
            if found {
                // æ³¨å…¥æœåŠ¡
                field.Set(reflect.ValueOf(service))
            }
        }
    }
    
    return nil
}

// ç¤ºä¾‹ä¾èµ–
type Logger interface {
    Log(message string)
}

type ConsoleLogger struct{}

func (l *ConsoleLogger) Log(message string) {
    fmt.Println("æ—¥å¿—:", message)
}

type Database interface {
    Query(sql string) []string
}

type SQLiteDatabase struct{}

func (db *SQLiteDatabase) Query(sql string) []string {
    return []string{"ç»“æœ1", "ç»“æœ2"}
}

// ä½¿ç”¨ä¾èµ–çš„æœåŠ¡
type UserService struct {
    Logger   Logger   `inject:""`
    Database Database `inject:""`
}

func (s *UserService) CreateUser(name string) {
    s.Logger.Log("åˆ›å»ºç”¨æˆ·: " + name)
    results := s.Database.Query("INSERT INTO users VALUES ('" + name + "')")
    s.Logger.Log(fmt.Sprintf("æŸ¥è¯¢ç»“æœ: %v", results))
}

func main() {
    // åˆ›å»ºå®¹å™¨
    container := NewContainer()
    
    // æ³¨å†ŒæœåŠ¡
    container.Register(&ConsoleLogger{})
    container.Register(&SQLiteDatabase{})
    
    // åˆ›å»ºæœåŠ¡å¹¶è§£æä¾èµ–
    userService := &UserService{}
    if err := container.Resolve(userService); err != nil {
        fmt.Println("è§£æé”™è¯¯:", err)
        return
    }
    
    // ä½¿ç”¨æœåŠ¡
    userService.CreateUser("å¼ ä¸‰")
}
```

### 5.3 å®ç°é…ç½®è§£æ
```go
package main

import (
    "encoding/json"
    "fmt"
    "os"
    "reflect"
    "strconv"
    "strings"
)

// é…ç½®è§£æå™¨
type ConfigParser struct{}

// ä»ç¯å¢ƒå˜é‡åŠ è½½é…ç½®
func (p *ConfigParser) LoadFromEnv(config interface{}) error {
    configValue := reflect.ValueOf(config)
    
    // ç¡®ä¿æ˜¯æŒ‡é’ˆ
    if configValue.Kind() != reflect.Ptr {
        return fmt.Errorf("é…ç½®å¿…é¡»æ˜¯æŒ‡é’ˆ")
    }
    
    // è·å–æŒ‡é’ˆæŒ‡å‘çš„å…ƒç´ 
    configElem := configValue.Elem()
    if configElem.Kind() != reflect.Struct {
        return fmt.Errorf("é…ç½®å¿…é¡»æ˜¯ç»“æ„ä½“æŒ‡é’ˆ")
    }
    
    configType := configElem.Type()
    
    // éå†æ‰€æœ‰å­—æ®µ
    for i := 0; i < configElem.NumField(); i++ {
        field := configElem.Field(i)
        fieldType := configType.Field(i)
        
        // æ£€æŸ¥æ˜¯å¦å¯è®¾ç½®
        if !field.CanSet() {
            continue
        }
        
        // è·å–ç¯å¢ƒå˜é‡å
        envName := fieldType.Tag.Get("env")
        if envName == "" {
            // é»˜è®¤ä½¿ç”¨å­—æ®µåè½¬å¤§å†™
            envName = strings.ToUpper(fieldType.Name)
        }
        
        // è·å–ç¯å¢ƒå˜é‡å€¼
        envValue, exists := os.LookupEnv(envName)
        if !exists {
            // æ£€æŸ¥æ˜¯å¦æœ‰é»˜è®¤å€¼
            if defaultValue := fieldType.Tag.Get("default"); defaultValue != "" {
                envValue = defaultValue
            } else {
                continue // æ²¡æœ‰ç¯å¢ƒå˜é‡ä¸”æ²¡æœ‰é»˜è®¤å€¼ï¼Œè·³è¿‡
            }
        }
        
        // æ ¹æ®å­—æ®µç±»å‹è®¾ç½®å€¼
        switch field.Kind() {
        case reflect.String:
            field.SetString(envValue)
        
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
            if intValue, err := strconv.ParseInt(envValue, 10, 64); err == nil {
                field.SetInt(intValue)
            }
        
        case reflect.Bool:
            if boolValue, err := strconv.ParseBool(envValue); err == nil {
                field.SetBool(boolValue)
            }
        
        case reflect.Float32, reflect.Float64:
            if floatValue, err := strconv.ParseFloat(envValue, 64); err == nil {
                field.SetFloat(floatValue)
            }
        
        case reflect.Slice:
            if field.Type().Elem().Kind() == reflect.String {
                // å¤„ç†å­—ç¬¦ä¸²åˆ‡ç‰‡
                values := strings.Split(envValue, ",")
                slice := reflect.MakeSlice(field.Type(), len(values), len(values))
                for i, v := range values {
                    slice.Index(i).SetString(strings.TrimSpace(v))
                }
                field.Set(slice)
            }
        
        case reflect.Map:
            if field.Type().Key().Kind() == reflect.String && 
               field.Type().Elem().Kind() == reflect.String {
                // å¤„ç†å­—ç¬¦ä¸²åˆ°å­—ç¬¦ä¸²çš„æ˜ å°„
                mapValue := reflect.MakeMap(field.Type())
                pairs := strings.Split(envValue, ",")
                for _, pair := range pairs {
                    kv := strings.SplitN(pair, "=", 2)
                    if len(kv) == 2 {
                        key := strings.TrimSpace(kv[0])
                        value := strings.TrimSpace(kv[1])
                        mapValue.SetMapIndex(reflect.ValueOf(key), reflect.ValueOf(value))
                    }
                }
                field.Set(mapValue)
            }
        
        case reflect.Struct:
            // å¯¹äºåµŒå¥—ç»“æ„ä½“ï¼Œå°è¯•è§£æJSON
            if envValue != "" {
                newValue := reflect.New(field.Type()).Interface()
                if err := json.Unmarshal([]byte(envValue), newValue); err == nil {
                    field.Set(reflect.ValueOf(newValue).Elem())
                }
            }
        }
    }
    
    return nil
}

// ç¤ºä¾‹é…ç½®ç»“æ„ä½“
type AppConfig struct {
    ServerHost     string            `env:"SERVER_HOST" default:"localhost"`
    ServerPort     int               `env:"SERVER_PORT" default:"8080"`
    Debug          bool              `env:"DEBUG" default:"false"`
    DatabaseURL    string            `env:"DATABASE_URL" required:"true"`
    AllowedOrigins []string          `env:"ALLOWED_ORIGINS" default:"http://localhost:3000"`
    Features       map[string]string `env:"FEATURES"`
}

func main() {
    // è®¾ç½®ä¸€äº›ç¯å¢ƒå˜é‡è¿›è¡Œæµ‹è¯•
    os.Setenv("SERVER_PORT", "9000")
    os.Setenv("DEBUG", "true")
    os.Setenv("DATABASE_URL", "postgres://user:pass@localhost:5432/db")
    os.Setenv("ALLOWED_ORIGINS", "http://example.com, http://localhost:8080")
    os.Setenv("FEATURES", "login=enabled, registration=disabled, admin=true")
    
    // åˆ›å»ºé…ç½®å®ä¾‹
    config := &AppConfig{}
    
    // è§£æé…ç½®
    parser := &ConfigParser{}
    if err := parser.LoadFromEnv(config); err != nil {
        fmt.Println("é…ç½®è§£æé”™è¯¯:", err)
        return
    }
    
    // æ˜¾ç¤ºé…ç½®
    fmt.Printf("æœåŠ¡å™¨ä¸»æœº: %s\n", config.ServerHost)
    fmt.Printf("æœåŠ¡å™¨ç«¯å£: %d\n", config.ServerPort)
    fmt.Printf("è°ƒè¯•æ¨¡å¼: %v\n", config.Debug)
    fmt.Printf("æ•°æ®åº“URL: %s\n", config.DatabaseURL)
    fmt.Printf("å…è®¸çš„æ¥æº: %v\n", config.AllowedOrigins)
    fmt.Printf("åŠŸèƒ½æ ‡å¿—: %v\n", config.Features)
}
```

---

## 6. é«˜çº§æŠ€å·§

### 6.1 åå°„ä¸å¹¶å‘
```go
package main

import (
    "fmt"
    "reflect"
    "sync"
    "time"
)

// ä½¿ç”¨åå°„å®ç°é€šç”¨çš„å¹¶è¡Œæ˜ å°„
func parallelMap(slice interface{}, fn interface{}) interface{} {
    sliceValue := reflect.ValueOf(slice)
    fnValue := reflect.ValueOf(fn)
    
    // éªŒè¯è¾“å…¥
    if sliceValue.Kind() != reflect.Slice {
        panic("ç¬¬ä¸€ä¸ªå‚æ•°å¿…é¡»æ˜¯åˆ‡ç‰‡")
    }
    
    if fnValue.Kind() != reflect.Func {
        panic("ç¬¬äºŒä¸ªå‚æ•°å¿…é¡»æ˜¯å‡½æ•°")
    }
    
    // æ£€æŸ¥å‡½æ•°ç­¾å
    fnType := fnValue.Type()
    if fnType.NumIn() != 1 || fnType.NumOut() != 1 {
        panic("å‡½æ•°å¿…é¡»æ¥å—ä¸€ä¸ªå‚æ•°å¹¶è¿”å›ä¸€ä¸ªå€¼")
    }
    
    // è·å–è¾“å…¥åˆ‡ç‰‡å…ƒç´ ç±»å‹å’Œè¾“å‡ºåˆ‡ç‰‡å…ƒç´ ç±»å‹
    inElemType := sliceValue.Type().Elem()
    outElemType := fnType.Out(0)
    
    // åˆ›å»ºè¾“å‡ºåˆ‡ç‰‡
    resultSlice := reflect.MakeSlice(
        reflect.SliceOf(outElemType),
        sliceValue.Len(),
        sliceValue.Len(),
    )
    
    // å¹¶è¡Œå¤„ç†
    var wg sync.WaitGroup
    for i := 0; i < sliceValue.Len(); i++ {
        wg.Add(1)
        go func(idx int) {
            defer wg.Done()
            
            // è·å–è¾“å…¥å…ƒç´ 
            elem := sliceValue.Index(idx)
            
            // è°ƒç”¨å‡½æ•°
            result := fnValue.Call([]reflect.Value{elem})
            
            // å­˜å‚¨ç»“æœ
            resultSlice.Index(idx).Set(result[0])
        }(i)
    }
    
    // ç­‰å¾…æ‰€æœ‰goroutineå®Œæˆ
    wg.Wait()
    
    return resultSlice.Interface()
}

func main() {
    // æµ‹è¯•æ•´æ•°åˆ‡ç‰‡
    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    
    squares := parallelMap(numbers, func(x int) int {
        time.Sleep(100 * time.Millisecond) // æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ
        return x * x
    })
    
    fmt.Println("åŸå§‹æ•°å­—:", numbers)
    fmt.Println("å¹¶è¡Œè®¡ç®—å¹³æ–¹:", squares)
    
    // æµ‹è¯•å­—ç¬¦ä¸²åˆ‡ç‰‡
    words := []string{"hello", "world", "parallel", "processing"}
    
    lengths := parallelMap(words, func(s string) int {
        time.Sleep(100 * time.Millisecond) // æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ
        return len(s)
    })
    
    fmt.Println("å•è¯:", words)
    fmt.Println("å¹¶è¡Œè®¡ç®—é•¿åº¦:", lengths)
    
    // æµ‹è¯•ç±»å‹è½¬æ¢
    stringified := parallelMap(numbers, func(x int) string {
        time.Sleep(100 * time.Millisecond) // æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ
        return fmt.Sprintf("æ•°å­—%d", x)
    })
    
    fmt.Println("æ•°å­—è½¬å­—ç¬¦ä¸²:", stringified)
}
```

### 6.2 æ·±æ‹·è´
```go
package main

import (
    "fmt"
    "reflect"
)

// æ·±åº¦å¤åˆ¶å‡½æ•°
func deepCopy(source interface{}) interface{} {
    // ç‰¹æ®Šæƒ…å†µï¼šnil
    if source == nil {
        return nil
    }
    
    sourceValue := reflect.ValueOf(source)
    
    // åˆ›å»ºå‰¯æœ¬çš„å‡½æ•°
    return deepCopyValue(sourceValue).Interface()
}

// å¤åˆ¶reflect.Value
func deepCopyValue(source reflect.Value) reflect.Value {
    // å¤„ç†æ— æ•ˆå€¼
    if !source.IsValid() {
        return reflect.Value{}
    }
    
    // è·å–ç±»å‹
    sourceType := source.Type()
    
    // å¤„ç†ä¸éœ€è¦æ·±åº¦å¤åˆ¶çš„ç±»å‹
    switch sourceType.Kind() {
    case reflect.Bool, reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
         reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr,
         reflect.Float32, reflect.Float64, reflect.Complex64, reflect.Complex128, reflect.String:
        return source
    }
    
    // å¤„ç†æŒ‡é’ˆ
    if sourceType.Kind() == reflect.Ptr {
        // nilæŒ‡é’ˆç›´æ¥è¿”å›
        if source.IsNil() {
            return reflect.Zero(sourceType)
        }
        
        // åˆ›å»ºæ–°æŒ‡é’ˆ
        targetValue := reflect.New(sourceType.Elem())
        
        // å¤åˆ¶æŒ‡é’ˆæŒ‡å‘çš„å€¼
        elemValue := deepCopyValue(source.Elem())
        targetValue.Elem().Set(elemValue)
        
        return targetValue
    }
    
    // å¤„ç†æ¥å£
    if sourceType.Kind() == reflect.Interface {
        // nilæ¥å£ç›´æ¥è¿”å›
        if source.IsNil() {
            return reflect.Zero(sourceType)
        }
        
        // å¤åˆ¶æ¥å£å†…çš„å€¼
        elemValue := deepCopyValue(source.Elem())
        return elemValue
    }
    
    // å¤„ç†åˆ‡ç‰‡
    if sourceType.Kind() == reflect.Slice {
        // nilåˆ‡ç‰‡ç›´æ¥è¿”å›
        if source.IsNil() {
            return reflect.Zero(sourceType)
        }
        
        // ç©ºåˆ‡ç‰‡å¤„ç†
        length := source.Len()
        if length == 0 {
            return reflect.MakeSlice(sourceType, 0, 0)
        }
        
        // åˆ›å»ºæ–°åˆ‡ç‰‡
        targetValue := reflect.MakeSlice(sourceType, length, length)
        
        // å¤åˆ¶æ¯ä¸ªå…ƒç´ 
        for i := 0; i < length; i++ {
            elemValue := deepCopyValue(source.Index(i))
            targetValue.Index(i).Set(elemValue)
        }
        
        return targetValue
    }
    
    // å¤„ç†æ˜ å°„
    if sourceType.Kind() == reflect.Map {
        // nilæ˜ å°„ç›´æ¥è¿”å›
        if source.IsNil() {
            return reflect.Zero(sourceType)
        }
        
        // åˆ›å»ºæ–°æ˜ å°„
        targetValue := reflect.MakeMap(sourceType)
        
        // å¤åˆ¶æ¯ä¸ªé”®å€¼å¯¹
        iter := source.MapRange()
        for iter.Next() {
            key := iter.Key()
            value := iter.Value()
            
            // å¤åˆ¶å€¼
            copiedValue := deepCopyValue(value)
            
            // æ·»åŠ åˆ°æ–°æ˜ å°„
            targetValue.SetMapIndex(key, copiedValue)
        }
        
        return targetValue
    }
    
    // å¤„ç†ç»“æ„ä½“
    if sourceType.Kind() == reflect.Struct {
        // åˆ›å»ºæ–°ç»“æ„ä½“
        targetValue := reflect.New(sourceType).Elem()
        
        // å¤åˆ¶æ¯ä¸ªå­—æ®µ
        for i := 0; i < sourceType.NumField(); i++ {
            field := source.Field(i)
            
            // æ£€æŸ¥æ˜¯å¦å¯è®¾ç½®
            if field.CanInterface() {
                // å¤åˆ¶å­—æ®µå€¼
                copiedField := deepCopyValue(field)
                
                // è®¾ç½®å­—æ®µ
                targetField := targetValue.Field(i)
                if targetField.CanSet() {
                    targetField.Set(copiedField)
                }
            }
        }
        
        return targetValue
    }
    
    // å…¶ä»–ç±»å‹ç›´æ¥è¿”å›é›¶å€¼
    return reflect.Zero(sourceType)
}

func main() {
    // æµ‹è¯•åŸºæœ¬ç±»å‹
    num := 42
    numCopy := deepCopy(num)
    fmt.Printf("æ•´æ•°: %d, å‰¯æœ¬: %d\n", num, numCopy)
    
    // æµ‹è¯•æŒ‡é’ˆ
    ptr := &num
    ptrCopy := deepCopy(ptr).(*int)
    *ptrCopy = 100 // ä¿®æ”¹å‰¯æœ¬ä¸å½±å“åŸå§‹å€¼
    fmt.Printf("æŒ‡é’ˆ: %d, å‰¯æœ¬: %d, åŸå§‹å€¼: %d\n", *ptr, *ptrCopy, num)
    
    // æµ‹è¯•ç»“æ„ä½“
    type Person struct {
        Name  string
        Age   int
        Hobby []string
        Info  map[string]string
    }
    
    person := Person{
        Name:  "å¼ ä¸‰",
        Age:   30,
        Hobby: []string{"è¯»ä¹¦", "æ—…æ¸¸"},
        Info: map[string]string{
            "email": "zhangsan@example.com",
            "phone": "123456789",
        },
    }
    
    personCopy := deepCopy(person).(Person)
    
    // ä¿®æ”¹å‰¯æœ¬
    personCopy.Name = "æå››"
    personCopy.Age = 25
    personCopy.Hobby[0] = "æ¸¸æ³³"
    personCopy.Info["email"] = "lisi@example.com"
    
    // æ¯”è¾ƒåŸå§‹å€¼å’Œå‰¯æœ¬
    fmt.Println("\nåŸå§‹ç»“æ„ä½“:")
    fmt.Printf("  å§“å: %s\n", person.Name)
    fmt.Printf("  å¹´é¾„: %d\n", person.Age)
    fmt.Printf("  çˆ±å¥½: %v\n", person.Hobby)
    fmt.Printf("  ä¿¡æ¯: %v\n", person.Info)
    
    fmt.Println("\nå¤åˆ¶çš„ç»“æ„ä½“:")
    fmt.Printf("  å§“å: %s\n", personCopy.Name)
    fmt.Printf("  å¹´é¾„: %d\n", personCopy.Age)
    fmt.Printf("  çˆ±å¥½: %v\n", personCopy.Hobby)
    fmt.Printf("  ä¿¡æ¯: %v\n", personCopy.Info)
}
```

### 6.3 ç±»å‹è½¬æ¢
```go
package main

import (
    "fmt"
    "reflect"
    "strconv"
)

// é€šç”¨ç±»å‹è½¬æ¢å‡½æ•°
func convert(value interface{}, targetType reflect.Type) (interface{}, error) {
    // æºå€¼
    v := reflect.ValueOf(value)
    
    // å¦‚æœæºç±»å‹å’Œç›®æ ‡ç±»å‹ç›¸åŒï¼Œç›´æ¥è¿”å›
    if v.Type() == targetType {
        return value, nil
    }
    
    // åˆ›å»ºç›®æ ‡ç±»å‹çš„é›¶å€¼
    target := reflect.New(targetType).Elem()
    
    // å°è¯•è½¬æ¢
    switch targetType.Kind() {
    case reflect.String:
        // ä»»ä½•ç±»å‹åˆ°å­—ç¬¦ä¸²
        switch v.Kind() {
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
            target.SetString(strconv.FormatInt(v.Int(), 10))
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
            target.SetString(strconv.FormatUint(v.Uint(), 10))
        case reflect.Float32, reflect.Float64:
            target.SetString(strconv.FormatFloat(v.Float(), 'f', -1, 64))
        case reflect.Bool:
            target.SetString(strconv.FormatBool(v.Bool()))
        default:
            return nil, fmt.Errorf("æ— æ³•å°†ç±»å‹ %s è½¬æ¢ä¸ºå­—ç¬¦ä¸²", v.Type())
        }
        
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
        // åˆ°æ•´æ•°çš„è½¬æ¢
        switch v.Kind() {
        case reflect.String:
            i, err := strconv.ParseInt(v.String(), 10, 64)
            if err != nil {
                return nil, err
            }
            target.SetInt(i)
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
            target.SetInt(v.Int())
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
            target.SetInt(int64(v.Uint()))
        case reflect.Float32, reflect.Float64:
            target.SetInt(int64(v.Float()))
        case reflect.Bool:
            if v.Bool() {
                target.SetInt(1)
            } else {
                target.SetInt(0)
            }
        default:
            return nil, fmt.Errorf("æ— æ³•å°†ç±»å‹ %s è½¬æ¢ä¸ºæ•´æ•°", v.Type())
        }
        
    case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
        // åˆ°æ— ç¬¦å·æ•´æ•°çš„è½¬æ¢
        switch v.Kind() {
        case reflect.String:
            u, err := strconv.ParseUint(v.String(), 10, 64)
            if err != nil {
                return nil, err
            }
            target.SetUint(u)
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
            if v.Int() < 0 {
                return nil, fmt.Errorf("æ— æ³•å°†è´Ÿæ•´æ•°è½¬æ¢ä¸ºæ— ç¬¦å·æ•´æ•°")
            }
            target.SetUint(uint64(v.Int()))
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
            target.SetUint(v.Uint())
        case reflect.Float32, reflect.Float64:
            if v.Float() < 0 {
                return nil, fmt.Errorf("æ— æ³•å°†è´Ÿæµ®ç‚¹æ•°è½¬æ¢ä¸ºæ— ç¬¦å·æ•´æ•°")
            }
            target.SetUint(uint64(v.Float()))
        case reflect.Bool:
            if v.Bool() {
                target.SetUint(1)
            } else {
                target.SetUint(0)
            }
        default:
            return nil, fmt.Errorf("æ— æ³•å°†ç±»å‹ %s è½¬æ¢ä¸ºæ— ç¬¦å·æ•´æ•°", v.Type())
        }
        
    case reflect.Float32, reflect.Float64:
        // åˆ°æµ®ç‚¹æ•°çš„è½¬æ¢
        switch v.Kind() {
        case reflect.String:
            f, err := strconv.ParseFloat(v.String(), 64)
            if err != nil {
                return nil, err
            }
            target.SetFloat(f)
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
            target.SetFloat(float64(v.Int()))
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
            target.SetFloat(float64(v.Uint()))
        case reflect.Float32, reflect.Float64:
            target.SetFloat(v.Float())
        case reflect.Bool:
            if v.Bool() {
                target.SetFloat(1.0)
            } else {
                target.SetFloat(0.0)
            }
        default:
            return nil, fmt.Errorf("æ— æ³•å°†ç±»å‹ %s è½¬æ¢ä¸ºæµ®ç‚¹æ•°", v.Type())
        }
        
    case reflect.Bool:
        // åˆ°å¸ƒå°”å€¼çš„è½¬æ¢
        switch v.Kind() {
        case reflect.String:
            b, err := strconv.ParseBool(v.String())
            if err != nil {
                return nil, err
            }
            target.SetBool(b)
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
            target.SetBool(v.Int() != 0)
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
            target.SetBool(v.Uint() != 0)
        case reflect.Float32, reflect.Float64:
            target.SetBool(v.Float() != 0)
        case reflect.Bool:
            target.SetBool(v.Bool())
        default:
            return nil, fmt.Errorf("æ— æ³•å°†ç±»å‹ %s è½¬æ¢ä¸ºå¸ƒå°”å€¼", v.Type())
        }
        
    case reflect.Slice:
        // å°è¯•åˆ›å»ºåˆ‡ç‰‡
        if v.Kind() == reflect.Slice {
            // æºå’Œç›®æ ‡éƒ½æ˜¯åˆ‡ç‰‡ï¼Œä½†å…ƒç´ ç±»å‹ä¸åŒ
            sourceElemType := v.Type().Elem()
            targetElemType := targetType.Elem()
            
            // åˆ›å»ºæ–°åˆ‡ç‰‡
            newSlice := reflect.MakeSlice(targetType, v.Len(), v.Cap())
            
            // è½¬æ¢æ¯ä¸ªå…ƒç´ 
            for i := 0; i < v.Len(); i++ {
                elem := v.Index(i).Interface()
                newElem, err := convert(elem, targetElemType)
                if err != nil {
                    return nil, fmt.Errorf("è½¬æ¢åˆ‡ç‰‡å…ƒç´  #%d å¤±è´¥: %v", i, err)
                }
                newSlice.Index(i).Set(reflect.ValueOf(newElem))
            }
            
            target.Set(newSlice)
        } else {
            return nil, fmt.Errorf("æ— æ³•å°†ç±»å‹ %s è½¬æ¢ä¸ºåˆ‡ç‰‡", v.Type())
        }
        
    default:
        return nil, fmt.Errorf("ä¸æ”¯æŒè½¬æ¢åˆ°ç±»å‹ %s", targetType)
    }
    
    return target.Interface(), nil
}

func main() {
    // æµ‹è¯•åŸºæœ¬ç±»å‹è½¬æ¢
    tests := []struct {
        value interface{}
        typ   reflect.Type
    }{
        {42, reflect.TypeOf("")},                  // int -> string
        {"123", reflect.TypeOf(0)},                // string -> int
        {3.14, reflect.TypeOf(0)},                 // float -> int
        {true, reflect.TypeOf("")},                // bool -> string
        {"true", reflect.TypeOf(false)},           // string -> bool
        {[]int{1, 2, 3}, reflect.TypeOf([]string{})}, // []int -> []string
    }
    
    for i, test := range tests {
        result, err := convert(test.value, test.typ)
        if err != nil {
            fmt.Printf("æµ‹è¯• #%d: è½¬æ¢ %v (%T) åˆ° %s å¤±è´¥: %v\n", 
                      i+1, test.value, test.value, test.typ, err)
        } else {
            fmt.Printf("æµ‹è¯• #%d: %v (%T) -> %v (%T)\n", 
                      i+1, test.value, test.value, result, result)
        }
    }
}
```

---

## 7. åå°„æ€§èƒ½å’Œæœ€ä½³å®è·µ

### 7.1 åå°„çš„æ€§èƒ½å¼€é”€
```go
package main

import (
    "fmt"
    "reflect"
    "testing"
    "time"
)

func directAccess(s []int) int {
    sum := 0
    for i := 0; i < len(s); i++ {
        sum += s[i]
    }
    return sum
}

func reflectAccess(s interface{}) int {
    sum := 0
    v := reflect.ValueOf(s)
    for i := 0; i < v.Len(); i++ {
        sum += int(v.Index(i).Int())
    }
    return sum
}

func BenchmarkDirectAccess(b *testing.B) {
    s := make([]int, 1000)
    for i := 0; i < len(s); i++ {
        s[i] = i
    }
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _ = directAccess(s)
    }
}

func BenchmarkReflectAccess(b *testing.B) {
    s := make([]int, 1000)
    for i := 0; i < len(s); i++ {
        s[i] = i
    }
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _ = reflectAccess(s)
    }
}

func main() {
    // ç›´æ¥æ¨¡æ‹Ÿä¸€ä¸ªç®€å•çš„åŸºå‡†æµ‹è¯•
    size := 1000000
    s := make([]int, size)
    for i := 0; i < size; i++ {
        s[i] = i
    }
    
    // ç›´æ¥è®¿é—®
    start := time.Now()
    directResult := directAccess(s)
    directDuration := time.Since(start)
    
    // åå°„è®¿é—®
    start = time.Now()
    reflectResult := reflectAccess(s)
    reflectDuration := time.Since(start)
    
    fmt.Printf("ç›´æ¥è®¿é—®ç»“æœ: %d, è€—æ—¶: %v\n", directResult, directDuration)
    fmt.Printf("åå°„è®¿é—®ç»“æœ: %d, è€—æ—¶: %v\n", reflectResult, reflectDuration)
    fmt.Printf("åå°„æ¯”ç›´æ¥è®¿é—®æ…¢ %.2f å€\n", 
              float64(reflectDuration.Nanoseconds()) / float64(directDuration.Nanoseconds()))
    
    fmt.Println("\nä½¿ç”¨ä»¥ä¸‹å‘½ä»¤è¿è¡Œå®Œæ•´åŸºå‡†æµ‹è¯•:")
    fmt.Println("go test -bench=. -benchmem")
}
```

### 7.2 ç¼“å­˜åå°„ç»“æœ
```go
package main

import (
    "fmt"
    "reflect"
    "sync"
    "time"
)

// ç¼“å­˜ç±»å‹ä¿¡æ¯
var (
    structFieldsCache = make(map[reflect.Type][]reflect.StructField)
    cacheMutex        sync.RWMutex
)

// ä¸ä½¿ç”¨ç¼“å­˜çš„å‡½æ•°
func getFieldsNoCache(t reflect.Type) []reflect.StructField {
    if t.Kind() != reflect.Struct {
        return nil
    }
    
    fields := make([]reflect.StructField, t.NumField())
    for i := 0; i < t.NumField(); i++ {
        fields[i] = t.Field(i)
    }
    
    return fields
}

// ä½¿ç”¨ç¼“å­˜çš„å‡½æ•°
func getFieldsWithCache(t reflect.Type) []reflect.StructField {
    if t.Kind() != reflect.Struct {
        return nil
    }
    
    // å…ˆæ£€æŸ¥ç¼“å­˜
    cacheMutex.RLock()
    fields, ok := structFieldsCache[t]
    cacheMutex.RUnlock()
    
    if ok {
        return fields
    }
    
    // ç¼“å­˜æœªå‘½ä¸­ï¼Œè·å–å­—æ®µ
    fields = make([]reflect.StructField, t.NumField())
    for i := 0; i < t.NumField(); i++ {
        fields[i] = t.Field(i)
    }
    
    // æ›´æ–°ç¼“å­˜
    cacheMutex.Lock()
    structFieldsCache[t] = fields
    cacheMutex.Unlock()
    
    return fields
}

// å¤æ‚ç»“æ„ä½“
type ComplexStruct struct {
    Field1  string
    Field2  int
    Field3  bool
    Field4  float64
    Field5  []int
    Field6  map[string]int
    Field7  struct {
        NestedField1 string
        NestedField2 int
    }
    Field8  string
    Field9  int
    Field10 bool
    Field11 float64
    Field12 []int
    Field13 map[string]int
    Field14 struct {
        NestedField1 string
        NestedField2 int
    }
    Field15 string
}

func main() {
    // è·å–ç»“æ„ä½“ç±»å‹
    t := reflect.TypeOf(ComplexStruct{})
    
    // æµ‹è¯•æ— ç¼“å­˜æ€§èƒ½
    start := time.Now()
    for i := 0; i < 100000; i++ {
        _ = getFieldsNoCache(t)
    }
    noCacheDuration := time.Since(start)
    
    // æµ‹è¯•æœ‰ç¼“å­˜æ€§èƒ½
    start = time.Now()
    for i := 0; i < 100000; i++ {
        _ = getFieldsWithCache(t)
    }
    withCacheDuration := time.Since(start)
    
    fmt.Printf("æ— ç¼“å­˜è€—æ—¶: %v\n", noCacheDuration)
    fmt.Printf("æœ‰ç¼“å­˜è€—æ—¶: %v\n", withCacheDuration)
    fmt.Printf("ç¼“å­˜æå‡æ€§èƒ½ %.2f å€\n", 
              float64(noCacheDuration.Nanoseconds()) / float64(withCacheDuration.Nanoseconds()))
    
    // æ£€æŸ¥ç¼“å­˜å†…å®¹
    cacheMutex.RLock()
    cachedTypes := make([]reflect.Type, 0, len(structFieldsCache))
    for k := range structFieldsCache {
        cachedTypes = append(cachedTypes, k)
    }
    cacheMutex.RUnlock()
    
    fmt.Println("\nç¼“å­˜ä¸­çš„ç±»å‹:")
    for _, t := range cachedTypes {
        fmt.Printf("  %s\n", t.Name())
    }
}
```

### 7.3 åå°„çš„æœ€ä½³å®è·µ
```go
package main

import (
    "fmt"
    "reflect"
)

// æœ€ä½³å®è·µ1: é™åˆ¶åå°„ä½¿ç”¨èŒƒå›´
// ä¸å¥½çš„ç¤ºä¾‹: åˆ°å¤„ä½¿ç”¨åå°„
func processBadExample(data interface{}) {
    v := reflect.ValueOf(data)
    if v.Kind() == reflect.Struct {
        for i := 0; i < v.NumField(); i++ {
            field := v.Field(i)
            processValue(field.Interface())
        }
    }
}

// å¥½çš„ç¤ºä¾‹: å°†åå°„é™åˆ¶åœ¨è¾¹ç•Œå†…
type DataProcessor struct {
    cache map[reflect.Type][]reflect.StructField
}

func NewDataProcessor() *DataProcessor {
    return &DataProcessor{
        cache: make(map[reflect.Type][]reflect.StructField),
    }
}

func (p *DataProcessor) ProcessData(data interface{}) {
    // åå°„åªåœ¨å¤„ç†å™¨å†…éƒ¨ä½¿ç”¨
    v := reflect.ValueOf(data)
    if v.Kind() == reflect.Struct {
        fields := p.getStructFields(v.Type())
        for _, field := range fields {
            fieldValue := v.FieldByIndex(field.Index)
            // å°†åå°„å€¼è½¬æ¢å›æ™®é€šå€¼
            typedValue := fieldValue.Interface()
            // ä½¿ç”¨éåå°„ä»£ç å¤„ç†
            processTypedValue(typedValue)
        }
    }
}

func (p *DataProcessor) getStructFields(t reflect.Type) []reflect.StructField {
    if fields, ok := p.cache[t]; ok {
        return fields
    }
    
    fields := make([]reflect.StructField, t.NumField())
    for i := 0; i < t.NumField(); i++ {
        fields[i] = t.Field(i)
    }
    
    p.cache[t] = fields
    return fields
}

// æœ€ä½³å®è·µ2: ä½¿ç”¨æ¥å£è€Œéåå°„
// ä¸å¥½çš„ç¤ºä¾‹: ä½¿ç”¨åå°„è°ƒç”¨æ–¹æ³•
func callMethodBadExample(obj interface{}, methodName string, args ...interface{}) interface{} {
    v := reflect.ValueOf(obj)
    method := v.MethodByName(methodName)
    
    // è½¬æ¢å‚æ•°
    reflectArgs := make([]reflect.Value, len(args))
    for i, arg := range args {
        reflectArgs[i] = reflect.ValueOf(arg)
    }
    
    // è°ƒç”¨æ–¹æ³•
    results := method.Call(reflectArgs)
    
    // è¿”å›ç¬¬ä¸€ä¸ªç»“æœ
    if len(results) > 0 {
        return results[0].Interface()
    }
    
    return nil
}

// å¥½çš„ç¤ºä¾‹: ä½¿ç”¨æ¥å£
type Worker interface {
    DoWork(data string) string
}

func ProcessWork(worker Worker, data string) string {
    return worker.DoWork(data)
}

// å®ç°Workeræ¥å£
type ConcreteWorker struct{}

func (w ConcreteWorker) DoWork(data string) string {
    return "å¤„ç†: " + data
}

// æœ€ä½³å®è·µ3: é”™è¯¯å¤„ç†
// ä¸å¥½çš„ç¤ºä¾‹: å¿½ç•¥é”™è¯¯æ£€æŸ¥
func setValueBadExample(target interface{}, value interface{}) {
    v := reflect.ValueOf(target).Elem()
    v.Set(reflect.ValueOf(value))
}

// å¥½çš„ç¤ºä¾‹: å®Œå–„çš„é”™è¯¯å¤„ç†
func setValueGoodExample(target interface{}, value interface{}) error {
    v := reflect.ValueOf(target)
    
    if v.Kind() != reflect.Ptr {
        return fmt.Errorf("ç›®æ ‡å¿…é¡»æ˜¯æŒ‡é’ˆ")
    }
    
    v = v.Elem()
    if !v.CanSet() {
        return fmt.Errorf("ç›®æ ‡ä¸å¯è®¾ç½®")
    }
    
    valueV := reflect.ValueOf(value)
    if v.Type() != valueV.Type() {
        return fmt.Errorf(
            "ç±»å‹ä¸åŒ¹é…: ç›®æ ‡ç±»å‹ä¸º %v, å€¼ç±»å‹ä¸º %v", 
            v.Type(), valueV.Type(),
        )
    }
    
    v.Set(valueV)
    return nil
}

// å¤„ç†å‡½æ•° - å‡è®¾è¿™æ˜¯æ­£å¸¸çš„ä¸šåŠ¡é€»è¾‘
func processValue(v interface{}) {
    fmt.Printf("å¤„ç†å€¼: %v\n", v)
}

func processTypedValue(v interface{}) {
    fmt.Printf("å¤„ç†ç±»å‹åŒ–å€¼: %v\n", v)
}

// ç¤ºä¾‹æ•°æ®
type Person struct {
    Name   string
    Age    int
    Active bool
}

func main() {
    // æœ€ä½³å®è·µæ¼”ç¤º
    
    fmt.Println("1. é™åˆ¶åå°„ä½¿ç”¨èŒƒå›´:")
    person := Person{Name: "å¼ ä¸‰", Age: 30, Active: true}
    
    processor := NewDataProcessor()
    processor.ProcessData(person)
    
    fmt.Println("\n2. ä½¿ç”¨æ¥å£è€Œéåå°„:")
    worker := ConcreteWorker{}
    
    // ä¸ä½¿ç”¨åå°„ï¼Œç›´æ¥é€šè¿‡æ¥å£è°ƒç”¨
    result := ProcessWork(worker, "æ ·æœ¬æ•°æ®")
    fmt.Println("æ¥å£è°ƒç”¨ç»“æœ:", result)
    
    // ä½¿ç”¨åå°„è°ƒç”¨ (ä»…ä½œå¯¹æ¯”ï¼Œå®é™…åº”é¿å…)
    reflectResult := callMethodBadExample(worker, "DoWork", "æ ·æœ¬æ•°æ®")
    fmt.Println("åå°„è°ƒç”¨ç»“æœ:", reflectResult)
    
    fmt.Println("\n3. é”™è¯¯å¤„ç†:")
    var target int = 0
    
    // ç±»å‹åŒ¹é…æƒ…å†µ
    err := setValueGoodExample(&target, 42)
    if err != nil {
        fmt.Println("é”™è¯¯:", err)
    } else {
        fmt.Println("è®¾ç½®å€¼æˆåŠŸ:", target)
    }
    
    // ç±»å‹ä¸åŒ¹é…æƒ…å†µ
    err = setValueGoodExample(&target, "å­—ç¬¦ä¸²")
    if err != nil {
        fmt.Println("é”™è¯¯:", err)
    }
    
    // éæŒ‡é’ˆæƒ…å†µ
    err = setValueGoodExample(target, 100)
    if err != nil {
        fmt.Println("é”™è¯¯:", err)
    }
}
```

### 7.4 é¿å…åå°„çš„æ›¿ä»£æ–¹æ¡ˆ
```go
package main

import (
    "encoding/json"
    "fmt"
    "reflect"
    "time"
)

// è¦å¤„ç†çš„æ•°æ®ç»“æ„
type Product struct {
    ID    int       `json:"id"`
    Name  string    `json:"name"`
    Price float64   `json:"price"`
    Date  time.Time `json:"date"`
}

// åå°„æ–¹å¼: åŠ¨æ€è§£æå’Œå¤„ç†ç»“æ„ä½“
func processWithReflection(product interface{}) map[string]interface{} {
    result := make(map[string]interface{})
    
    v := reflect.ValueOf(product)
    t := v.Type()
    
    for i := 0; i < v.NumField(); i++ {
        field := t.Field(i)
        fieldValue := v.Field(i)
        
        // è·å–JSONæ ‡ç­¾
        tag := field.Tag.Get("json")
        if tag == "" {
            tag = field.Name
        }
        
        // æ ¹æ®å­—æ®µç±»å‹å¤„ç†
        switch fieldValue.Kind() {
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
            result[tag] = fieldValue.Int()
        case reflect.Float32, reflect.Float64:
            result[tag] = fieldValue.Float()
        case reflect.String:
            result[tag] = fieldValue.String()
        case reflect.Struct:
            // å¤„ç†time.Timeç‰¹æ®Šæƒ…å†µ
            if fieldValue.Type() == reflect.TypeOf(time.Time{}) {
                timeValue := fieldValue.Interface().(time.Time)
                result[tag] = timeValue.Format("2006-01-02")
            } else {
                // é€’å½’å¤„ç†åµŒå¥—ç»“æ„ä½“
                result[tag] = processWithReflection(fieldValue.Interface())
            }
        default:
            result[tag] = fieldValue.Interface()
        }
    }
    
    return result
}

// æ›¿ä»£æ–¹æ¡ˆ1: ä½¿ç”¨JSONç¼–ç /è§£ç 
func processWithJSON(product interface{}) (map[string]interface{}, error) {
    // å…ˆå°†ç»“æ„ä½“ç¼–ç ä¸ºJSON
    data, err := json.Marshal(product)
    if err != nil {
        return nil, err
    }
    
    // å†è§£ç ä¸ºmap
    var result map[string]interface{}
    err = json.Unmarshal(data, &result)
    if err != nil {
        return nil, err
    }
    
    return result, nil
}

// æ›¿ä»£æ–¹æ¡ˆ2: ä½¿ç”¨è‡ªå®šä¹‰æ–¹æ³•
type ProductProcessor interface {
    ToMap() map[string]interface{}
}

func (p Product) ToMap() map[string]interface{} {
    return map[string]interface{}{
        "id":    p.ID,
        "name":  p.Name,
        "price": p.Price,
        "date":  p.Date.Format("2006-01-02"),
    }
}

// æ›¿ä»£æ–¹æ¡ˆ3: ä½¿ç”¨ä»£ç ç”Ÿæˆ
// æ³¨: è¿™é‡Œåªæ˜¯æ¼”ç¤ºï¼Œå®é™…ä»£ç ç”Ÿæˆéœ€è¦å•ç‹¬çš„å·¥å…·
// å‡è®¾è¿™æ˜¯ç”Ÿæˆçš„ä»£ç 
func ProductToMap(p Product) map[string]interface{} {
    return map[string]interface{}{
        "id":    p.ID,
        "name":  p.Name,
        "price": p.Price,
        "date":  p.Date.Format("2006-01-02"),
    }
}

func main() {
    product := Product{
        ID:    1,
        Name:  "ç¬”è®°æœ¬ç”µè„‘",
        Price: 6999.99,
        Date:  time.Now(),
    }
    
    // ä½¿ç”¨åå°„æ–¹å¼
    reflectResult := processWithReflection(product)
    fmt.Println("åå°„æ–¹å¼ç»“æœ:")
    for k, v := range reflectResult {
        fmt.Printf("  %s: %v\n", k, v)
    }
    
    // ä½¿ç”¨JSONæ–¹å¼
    jsonResult, err := processWithJSON(product)
    if err != nil {
        fmt.Println("JSONå¤„ç†é”™è¯¯:", err)
    } else {
        fmt.Println("\nJSONæ–¹å¼ç»“æœ:")
        for k, v := range jsonResult {
            fmt.Printf("  %s: %v\n", k, v)
        }
    }
    
    // ä½¿ç”¨æ¥å£æ–¹å¼
    interfaceResult := product.ToMap()
    fmt.Println("\næ¥å£æ–¹å¼ç»“æœ:")
    for k, v := range interfaceResult {
        fmt.Printf("  %s: %v\n", k, v)
    }
    
    // ä½¿ç”¨ç”Ÿæˆä»£ç æ–¹å¼
    generatedResult := ProductToMap(product)
    fmt.Println("\nä»£ç ç”Ÿæˆæ–¹å¼ç»“æœ:")
    for k, v := range generatedResult {
        fmt.Printf("  %s: %v\n", k, v)
    }
    
    // æ€§èƒ½æ¯”è¾ƒ
    iterations := 10000
    
    start := time.Now()
    for i := 0; i < iterations; i++ {
        _ = processWithReflection(product)
    }
    reflectDuration := time.Since(start)
    
    start = time.Now()
    for i := 0; i < iterations; i++ {
        _, _ = processWithJSON(product)
    }
    jsonDuration := time.Since(start)
    
    start = time.Now()
    for i := 0; i < iterations; i++ {
        _ = product.ToMap()
    }
    interfaceDuration := time.Since(start)
    
    start = time.Now()
    for i := 0; i < iterations; i++ {
        _ = ProductToMap(product)
    }
    generatedDuration := time.Since(start)
    
    fmt.Println("\næ€§èƒ½æ¯”è¾ƒ (è¿­ä»£æ¬¡æ•°:", iterations, "):")
    fmt.Printf("  åå°„æ–¹å¼: %v\n", reflectDuration)
    fmt.Printf("  JSONæ–¹å¼: %v\n", jsonDuration)
    fmt.Printf("  æ¥å£æ–¹å¼: %v\n", interfaceDuration)
    fmt.Printf("  ç”Ÿæˆä»£ç æ–¹å¼: %v\n", generatedDuration)
}
```

---

## 8. å­¦ä¹ æ£€æŸ¥ç‚¹

- [ ] ç†è§£åå°„çš„åŸºæœ¬æ¦‚å¿µå’ŒåŸç†
- [ ] æŒæ¡`reflect.Type`å’Œ`reflect.Value`çš„ä½¿ç”¨
- [ ] èƒ½å¤Ÿé€šè¿‡åå°„åˆ†æå’Œæ“ä½œåŸºæœ¬ç±»å‹
- [ ] èƒ½å¤Ÿé€šè¿‡åå°„åˆ†æå’Œæ“ä½œå¤åˆç±»å‹
- [ ] èƒ½å¤Ÿé€šè¿‡åå°„è°ƒç”¨å‡½æ•°å’Œæ–¹æ³•
- [ ] ç†è§£åå°„ä¸æ¥å£çš„å…³ç³»
- [ ] æŒæ¡åå°„çš„å®é™…åº”ç”¨åœºæ™¯
- [ ] äº†è§£åå°„çš„æ€§èƒ½å½±å“å’Œæœ€ä½³å®è·µ

---

åå°„æ˜¯Goè¯­è¨€ä¸­çš„é«˜çº§ç‰¹æ€§ï¼Œå®ƒæä¾›äº†åœ¨è¿è¡Œæ—¶æ£€æŸ¥å’Œæ“ä½œç¨‹åºç»“æ„çš„èƒ½åŠ›ã€‚è™½ç„¶å¼ºå¤§ï¼Œä½†åå°„åº”å½“è°¨æ…ä½¿ç”¨ï¼Œå¹¶éµå¾ªæœ€ä½³å®è·µä»¥é¿å…å¯ç»´æŠ¤æ€§å’Œæ€§èƒ½é—®é¢˜ã€‚æŒæ¡åå°„æœºåˆ¶å°†ä½¿ä½ èƒ½å¤Ÿåˆ›å»ºæ›´çµæ´»ã€æ›´é€šç”¨çš„Goç¨‹åºï¼Œç‰¹åˆ«æ˜¯åœ¨éœ€è¦å¤„ç†æœªçŸ¥ç±»å‹æˆ–ç¼–å†™é€šç”¨åº“æ—¶ã€‚
