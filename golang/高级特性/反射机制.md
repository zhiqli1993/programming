# Go语言反射机制

## 📚 学习目标
掌握Go语言的反射机制，理解运行时类型信息与操作的原理，学会在适当场景下使用反射实现动态编程，并了解反射的性能影响和最佳实践。

---

## 1. 反射基础

### 1.1 什么是反射
反射是程序在运行时检查、分析和修改自身结构与行为的能力。在Go语言中，反射主要通过`reflect`包实现，允许程序：

- 检查变量的类型信息
- 获取和修改变量的值
- 调用函数和方法
- 创建新的数据结构
- 操作结构体字段和标签

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    // 反射的三大法则演示
    
    // 1. 从接口值到反射对象
    var x float64 = 3.14
    fmt.Println("原始值:", x)
    
    // 接口值 -> 反射对象
    v := reflect.ValueOf(x)
    t := reflect.TypeOf(x)
    
    fmt.Println("类型:", t)
    fmt.Println("值:", v)
    
    // 2. 从反射对象到接口值
    i := v.Interface()
    y := i.(float64)
    fmt.Println("反射回接口:", y)
    
    // 3. 要修改反射对象，必须使其可设置
    p := reflect.ValueOf(&x) // 获取指针的反射值
    v2 := p.Elem()           // 获取指针指向的元素
    
    if v2.CanSet() {
        v2.SetFloat(2.71828)
        fmt.Println("修改后:", x)
    }
}
```

### 1.2 反射三大法则

1. **从接口值到反射对象**：`reflect.ValueOf()` 和 `reflect.TypeOf()` 将任何值转换为反射对象
2. **从反射对象到接口值**：`Value.Interface()` 将反射对象转回接口值
3. **要修改反射对象，必须使其可设置**：只有当反射对象是可设置的（表示底层存储地址可访问），才能修改它

### 1.3 Type和Value
反射在Go语言中主要涉及两个重要类型：

- **`reflect.Type`**：表示Go语言的类型，由`reflect.TypeOf()`返回
- **`reflect.Value`**：表示Go语言的值，由`reflect.ValueOf()`返回

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var num int = 42
    var str string = "Hello"
    
    // 获取类型信息
    numType := reflect.TypeOf(num)
    strType := reflect.TypeOf(str)
    
    fmt.Printf("num的类型: %s\n", numType)
    fmt.Printf("str的类型: %s\n", strType)
    
    // 获取值信息
    numValue := reflect.ValueOf(num)
    strValue := reflect.ValueOf(str)
    
    fmt.Printf("num的值: %v\n", numValue)
    fmt.Printf("str的值: %v\n", strValue)
    
    // 类型的种类(Kind)
    fmt.Printf("num的种类: %s\n", numType.Kind())
    fmt.Printf("str的种类: %s\n", strType.Kind())
}
```

### 1.4 Kind vs Type
在反射中，需要理解 Type（类型）和 Kind（种类）的区别：

- **Type**：特定的类型，如 `int`、`string`、`MyStruct` 等
- **Kind**：基础类型种类，如 `reflect.Int`、`reflect.String`、`reflect.Struct` 等

```go
package main

import (
    "fmt"
    "reflect"
)

type MyInt int
type Person struct {
    Name string
    Age  int
}

func main() {
    var a MyInt = 42
    var p Person = Person{Name: "张三", Age: 30}
    
    ta := reflect.TypeOf(a)
    tp := reflect.TypeOf(p)
    
    fmt.Printf("a的类型: %s, 种类: %s\n", ta.Name(), ta.Kind())
    fmt.Printf("p的类型: %s, 种类: %s\n", tp.Name(), tp.Kind())
    
    // 对于切片、映射等复合类型
    s := []int{1, 2, 3}
    ts := reflect.TypeOf(s)
    
    fmt.Printf("s的类型: %s, 种类: %s\n", ts.Name(), ts.Kind())
    // 注意：切片没有类型名，只有种类
}
```

---

## 2. 类型系统操作

### 2.1 基本类型操作
```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    // 基本类型
    var i int = 42
    var f float64 = 3.14
    var b bool = true
    var s string = "hello"
    
    // 检查类型信息
    checkType(i)
    checkType(f)
    checkType(b)
    checkType(s)
    
    // 检查类型是否可比较
    fmt.Printf("int是否可比较: %v\n", reflect.TypeOf(i).Comparable())
    fmt.Printf("[]int是否可比较: %v\n", reflect.TypeOf([]int{}).Comparable())
}

func checkType(v interface{}) {
    t := reflect.TypeOf(v)
    fmt.Printf("值: %v, 类型: %s, 种类: %s, 大小: %d字节\n", 
               v, t.Name(), t.Kind(), t.Size())
}
```

### 2.2 复合类型操作
```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    // 数组类型
    arr := [3]int{1, 2, 3}
    arrType := reflect.TypeOf(arr)
    fmt.Printf("数组: 长度=%d, 元素类型=%s\n", 
               arrType.Len(), arrType.Elem())
    
    // 切片类型
    slice := []string{"a", "b", "c"}
    sliceType := reflect.TypeOf(slice)
    fmt.Printf("切片: 元素类型=%s\n", sliceType.Elem())
    
    // 映射类型
    m := map[string]int{"a": 1, "b": 2}
    mapType := reflect.TypeOf(m)
    fmt.Printf("映射: 键类型=%s, 值类型=%s\n", 
               mapType.Key(), mapType.Elem())
    
    // 通道类型
    ch := make(chan int)
    chType := reflect.TypeOf(ch)
    fmt.Printf("通道: 方向=%v, 元素类型=%s\n", 
               chType.ChanDir(), chType.Elem())
    
    // 函数类型
    fn := func(a int, b string) bool { return true }
    fnType := reflect.TypeOf(fn)
    fmt.Printf("函数: 入参数量=%d, 返回值数量=%d\n", 
               fnType.NumIn(), fnType.NumOut())
    
    for i := 0; i < fnType.NumIn(); i++ {
        fmt.Printf("  参数 %d: %s\n", i, fnType.In(i))
    }
    
    for i := 0; i < fnType.NumOut(); i++ {
        fmt.Printf("  返回值 %d: %s\n", i, fnType.Out(i))
    }
}
```

### 2.3 结构体类型详解
```go
package main

import (
    "fmt"
    "reflect"
)

type Address struct {
    City   string
    Street string
}

type Person struct {
    Name    string  `json:"name" validate:"required"`
    Age     int     `json:"age" validate:"min=0,max=150"`
    Address Address `json:"address"`
}

func main() {
    p := Person{
        Name: "张三",
        Age:  30,
        Address: Address{
            City:   "北京",
            Street: "朝阳区",
        },
    }
    
    t := reflect.TypeOf(p)
    
    // 遍历结构体字段
    fmt.Printf("%s 结构体有 %d 个字段:\n", t.Name(), t.NumField())
    
    for i := 0; i < t.NumField(); i++ {
        field := t.Field(i)
        fmt.Printf("  字段 #%d: %s (%s)\n", i, field.Name, field.Type)
        
        // 字段标签
        if tag := field.Tag.Get("json"); tag != "" {
            fmt.Printf("    json标签: %s\n", tag)
        }
        
        if tag := field.Tag.Get("validate"); tag != "" {
            fmt.Printf("    验证标签: %s\n", tag)
        }
        
        // 检查嵌套字段
        if field.Type.Kind() == reflect.Struct {
            fmt.Printf("    嵌套结构体: %s 有 %d 个字段\n", 
                      field.Type.Name(), field.Type.NumField())
        }
    }
    
    // 通过名称获取字段
    if nameField, ok := t.FieldByName("Name"); ok {
        fmt.Printf("Name字段: %+v\n", nameField)
    }
    
    // 检查方法
    fmt.Printf("%s 类型有 %d 个方法\n", t.Name(), t.NumMethod())
}

// 为Person添加方法
func (p Person) SayHello() string {
    return "你好，我是" + p.Name
}
```

---

## 3. 值操作

### 3.1 获取和设置值
```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    // 基本类型操作
    var x int = 42
    v := reflect.ValueOf(&x).Elem() // 获取可设置的值
    
    fmt.Printf("原始值: %v\n", x)
    
    // 检查是否可设置
    if v.CanSet() {
        v.SetInt(100)
        fmt.Printf("新值: %v\n", x)
    }
    
    // 字符串操作
    var s string = "hello"
    sv := reflect.ValueOf(&s).Elem()
    
    if sv.CanSet() {
        sv.SetString("world")
        fmt.Printf("新字符串: %v\n", s)
    }
    
    // 复合类型操作
    p := &struct {
        Name string
        Age  int
    }{"张三", 30}
    
    pv := reflect.ValueOf(p).Elem()
    
    // 获取字段值
    nameField := pv.FieldByName("Name")
    ageField := pv.FieldByName("Age")
    
    fmt.Printf("原始字段: Name=%v, Age=%v\n", nameField, ageField)
    
    // 设置字段值
    if nameField.CanSet() {
        nameField.SetString("李四")
    }
    
    if ageField.CanSet() {
        ageField.SetInt(35)
    }
    
    fmt.Printf("新结构体: %+v\n", p)
}
```

### 3.2 数组和切片操作
```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    // 数组操作
    arr := [3]int{1, 2, 3}
    arrValue := reflect.ValueOf(&arr).Elem()
    
    fmt.Println("原始数组:", arr)
    
    // 修改数组元素
    for i := 0; i < arrValue.Len(); i++ {
        elem := arrValue.Index(i)
        if elem.CanSet() {
            elem.SetInt(elem.Int() * 10)
        }
    }
    
    fmt.Println("修改后数组:", arr)
    
    // 切片操作
    slice := []string{"a", "b", "c"}
    sliceValue := reflect.ValueOf(slice)
    
    fmt.Println("原始切片:", slice)
    
    // 遍历切片
    for i := 0; i < sliceValue.Len(); i++ {
        fmt.Printf("slice[%d] = %s\n", i, sliceValue.Index(i))
    }
    
    // 创建新切片
    newSlice := reflect.MakeSlice(reflect.TypeOf(slice), 5, 10)
    
    // 填充新切片
    for i := 0; i < 5; i++ {
        newSlice.Index(i).SetString(fmt.Sprintf("元素%d", i))
    }
    
    // 转换回普通切片
    result := newSlice.Interface().([]string)
    fmt.Println("新切片:", result)
}
```

### 3.3 映射操作
```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    // 映射操作
    m := map[string]int{"a": 1, "b": 2, "c": 3}
    mapValue := reflect.ValueOf(m)
    
    fmt.Println("原始映射:", m)
    
    // 获取所有键
    keys := mapValue.MapKeys()
    fmt.Println("所有键:")
    for _, key := range keys {
        fmt.Printf("  %s: %v\n", key, mapValue.MapIndex(key))
    }
    
    // 创建新映射
    newMap := reflect.MakeMap(reflect.TypeOf(m))
    
    // 添加键值对
    newMap.SetMapIndex(
        reflect.ValueOf("x"),
        reflect.ValueOf(100),
    )
    newMap.SetMapIndex(
        reflect.ValueOf("y"),
        reflect.ValueOf(200),
    )
    
    // 转换回普通映射
    result := newMap.Interface().(map[string]int)
    fmt.Println("新映射:", result)
    
    // 删除键 (通过设置零值)
    newMap.SetMapIndex(reflect.ValueOf("x"), reflect.Value{})
    result = newMap.Interface().(map[string]int)
    fmt.Println("删除键后:", result)
}
```

### 3.4 函数和方法调用
```go
package main

import (
    "fmt"
    "reflect"
)

func add(a, b int) int {
    return a + b
}

type Calculator struct {
    Name string
}

func (c Calculator) Multiply(a, b int) int {
    return a * b
}

func (c *Calculator) Divide(a, b int) (int, error) {
    if b == 0 {
        return 0, fmt.Errorf("除数不能为零")
    }
    return a / b, nil
}

func main() {
    // 函数调用
    f := reflect.ValueOf(add)
    
    // 准备参数
    args := []reflect.Value{
        reflect.ValueOf(10),
        reflect.ValueOf(20),
    }
    
    // 调用函数
    results := f.Call(args)
    
    // 处理结果
    fmt.Println("10 + 20 =", results[0].Int())
    
    // 方法调用
    c := Calculator{Name: "我的计算器"}
    cv := reflect.ValueOf(c)
    
    // 获取方法
    multiplyMethod := cv.MethodByName("Multiply")
    
    // 调用方法
    multiplyArgs := []reflect.Value{
        reflect.ValueOf(5),
        reflect.ValueOf(7),
    }
    
    multiplyResults := multiplyMethod.Call(multiplyArgs)
    fmt.Println("5 * 7 =", multiplyResults[0].Int())
    
    // 指针接收者方法
    cp := &Calculator{Name: "指针计算器"}
    cpv := reflect.ValueOf(cp)
    
    divideMethod := cpv.MethodByName("Divide")
    
    divideArgs := []reflect.Value{
        reflect.ValueOf(20),
        reflect.ValueOf(4),
    }
    
    divideResults := divideMethod.Call(divideArgs)
    
    // 多返回值处理
    quotient := divideResults[0].Int()
    errValue := divideResults[1]
    
    if !errValue.IsNil() {
        fmt.Println("错误:", errValue.Interface().(error))
    } else {
        fmt.Println("20 / 4 =", quotient)
    }
}
```

---

## 4. 反射与接口

### 4.1 接口值剖析
```go
package main

import (
    "fmt"
    "reflect"
)

type Speaker interface {
    Speak() string
}

type Dog struct {
    Name string
}

func (d Dog) Speak() string {
    return d.Name + " says Woof!"
}

type Cat struct {
    Name string
}

func (c Cat) Speak() string {
    return c.Name + " says Meow!"
}

func examineInterface(i interface{}) {
    // 获取接口的动态类型和值
    t := reflect.TypeOf(i)
    v := reflect.ValueOf(i)
    
    fmt.Printf("接口的动态类型: %s\n", t)
    fmt.Printf("接口的动态值: %+v\n", v)
    
    // 检查是否实现了特定接口
    speakerType := reflect.TypeOf((*Speaker)(nil)).Elem()
    fmt.Printf("是否实现Speaker接口: %v\n", t.Implements(speakerType))
    
    // 如果实现了接口，调用接口方法
    if t.Implements(speakerType) {
        method := v.MethodByName("Speak")
        result := method.Call(nil)
        fmt.Printf("调用Speak方法: %v\n", result[0])
    }
}

func main() {
    // 测试不同类型
    examineInterface(Dog{Name: "Rover"})
    fmt.Println()
    examineInterface(Cat{Name: "Whiskers"})
    fmt.Println()
    examineInterface(42) // 不实现Speaker接口
}
```

### 4.2 类型断言与反射对比
```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    // 准备一些值
    values := []interface{}{
        42,
        "hello",
        true,
        []int{1, 2, 3},
        map[string]int{"a": 1, "b": 2},
    }
    
    fmt.Println("使用类型断言:")
    for i, v := range values {
        switch x := v.(type) {
        case int:
            fmt.Printf("值 %d 是整数: %d\n", i, x)
        case string:
            fmt.Printf("值 %d 是字符串: %s\n", i, x)
        case bool:
            fmt.Printf("值 %d 是布尔值: %v\n", i, x)
        case []int:
            fmt.Printf("值 %d 是整数切片，长度: %d\n", i, len(x))
        case map[string]int:
            fmt.Printf("值 %d 是字符串到整数的映射，大小: %d\n", i, len(x))
        default:
            fmt.Printf("值 %d 是未知类型\n", i)
        }
    }
    
    fmt.Println("\n使用反射:")
    for i, v := range values {
        rv := reflect.ValueOf(v)
        rt := reflect.TypeOf(v)
        
        switch rt.Kind() {
        case reflect.Int:
            fmt.Printf("值 %d 是整数: %d\n", i, rv.Int())
        case reflect.String:
            fmt.Printf("值 %d 是字符串: %s\n", i, rv.String())
        case reflect.Bool:
            fmt.Printf("值 %d 是布尔值: %v\n", i, rv.Bool())
        case reflect.Slice:
            fmt.Printf("值 %d 是切片，长度: %d\n", i, rv.Len())
        case reflect.Map:
            fmt.Printf("值 %d 是映射，大小: %d\n", i, rv.Len())
        default:
            fmt.Printf("值 %d 是其他类型: %s\n", i, rt.Kind())
        }
    }
}
```

### 4.3 反射实现接口
```go
package main

import (
    "fmt"
    "reflect"
)

type Printer interface {
    Print()
}

// 使用反射来检查和调用接口方法
func callPrint(p Printer) {
    // 常规方式
    fmt.Println("常规调用:")
    p.Print()
    
    // 反射方式
    fmt.Println("反射调用:")
    v := reflect.ValueOf(p)
    method := v.MethodByName("Print")
    method.Call(nil)
}

// 两个实现Printer接口的类型
type Message struct {
    Text string
}

func (m Message) Print() {
    fmt.Println("消息:", m.Text)
}

type Document struct {
    Title   string
    Content string
}

func (d Document) Print() {
    fmt.Println("文档:", d.Title)
    fmt.Println("内容:", d.Content)
}

// 使用反射创建类型的新实例
func createInstance(t reflect.Type) reflect.Value {
    // 创建类型的新实例
    if t.Kind() == reflect.Struct {
        return reflect.New(t).Elem()
    }
    return reflect.Zero(t)
}

func main() {
    // 测试常规接口调用
    m := Message{Text: "Hello, World!"}
    d := Document{Title: "反射文档", Content: "这是关于反射的文档"}
    
    callPrint(m)
    fmt.Println()
    callPrint(d)
    
    // 使用反射创建新实例
    messageType := reflect.TypeOf(Message{})
    newMessage := createInstance(messageType)
    
    // 设置字段值
    if f := newMessage.FieldByName("Text"); f.IsValid() && f.CanSet() {
        f.SetString("这是通过反射创建的消息")
    }
    
    // 转换为接口并使用
    if msg, ok := newMessage.Interface().(Message); ok {
        fmt.Println("\n反射创建的实例:")
        callPrint(msg)
    }
}
```

---

## 5. 实际应用场景

### 5.1 实现简单的ORM
```go
package main

import (
    "database/sql"
    "fmt"
    "reflect"
    "strings"
)

// 模拟的数据库连接
type DB struct{}

func (db *DB) Query(query string, args ...interface{}) ([]map[string]interface{}, error) {
    // 模拟查询结果
    result := []map[string]interface{}{
        {
            "id":      1,
            "name":    "张三",
            "age":     30,
            "email":   "zhangsan@example.com",
            "is_admin": true,
        },
        {
            "id":      2,
            "name":    "李四",
            "age":     25,
            "email":   "lisi@example.com",
            "is_admin": false,
        },
    }
    return result, nil
}

// 表结构标签
type Table struct {
    Name string
}

// 字段标签
type Column struct {
    Name string
}

// 用户模型
type User struct {
    ID      int    `column:"id"`
    Name    string `column:"name"`
    Age     int    `column:"age"`
    Email   string `column:"email"`
    IsAdmin bool   `column:"is_admin"`
}

// 简单ORM
type ORM struct {
    db *DB
}

func NewORM() *ORM {
    return &ORM{db: &DB{}}
}

// 根据模型生成SQL查询
func (orm *ORM) buildQuery(model interface{}) string {
    t := reflect.TypeOf(model)
    
    // 检查是否为指针，如果是则获取元素类型
    if t.Kind() == reflect.Ptr {
        t = t.Elem()
    }
    
    // 构建字段列表
    var columns []string
    
    // 获取表名
    tableName := strings.ToLower(t.Name())
    
    // 检查表名标签
    for i := 0; i < t.NumField(); i++ {
        field := t.Field(i)
        
        // 从标签获取列名
        if column, ok := field.Tag.Lookup("column"); ok {
            columns = append(columns, column)
        } else {
            // 默认使用字段名转小写
            columns = append(columns, strings.ToLower(field.Name))
        }
    }
    
    // 构建查询
    query := fmt.Sprintf("SELECT %s FROM %s", 
                         strings.Join(columns, ", "), 
                         tableName)
    return query
}

// 填充结果到结构体
func (orm *ORM) scanIntoStruct(dest interface{}, data map[string]interface{}) {
    v := reflect.ValueOf(dest).Elem()
    t := v.Type()
    
    for i := 0; i < t.NumField(); i++ {
        field := t.Field(i)
        value := v.Field(i)
        
        // 获取列名
        var columnName string
        if column, ok := field.Tag.Lookup("column"); ok {
            columnName = column
        } else {
            columnName = strings.ToLower(field.Name)
        }
        
        // 获取数据
        if dataValue, ok := data[columnName]; ok && value.CanSet() {
            // 根据字段类型设置值
            switch value.Kind() {
            case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
                if intValue, ok := dataValue.(int); ok {
                    value.SetInt(int64(intValue))
                }
            case reflect.String:
                if strValue, ok := dataValue.(string); ok {
                    value.SetString(strValue)
                }
            case reflect.Bool:
                if boolValue, ok := dataValue.(bool); ok {
                    value.SetBool(boolValue)
                }
            }
        }
    }
}

// 查找所有记录
func (orm *ORM) FindAll(dest interface{}) error {
    // 获取切片值
    sliceValue := reflect.ValueOf(dest).Elem()
    
    // 获取切片元素类型
    elemType := sliceValue.Type().Elem()
    
    // 创建一个元素的零值用于生成查询
    elemZero := reflect.Zero(elemType).Interface()
    
    // 构建查询
    query := orm.buildQuery(elemZero)
    fmt.Println("执行查询:", query)
    
    // 执行查询
    results, err := orm.db.Query(query)
    if err != nil {
        return err
    }
    
    // 填充结果
    for _, result := range results {
        // 创建新元素
        newElem := reflect.New(elemType)
        
        // 填充数据
        orm.scanIntoStruct(newElem.Interface(), result)
        
        // 添加到切片
        sliceValue.Set(reflect.Append(sliceValue, newElem.Elem()))
    }
    
    return nil
}

func main() {
    orm := NewORM()
    
    // 准备接收结果的切片
    var users []User
    
    // 查询所有用户
    err := orm.FindAll(&users)
    if err != nil {
        fmt.Println("查询出错:", err)
        return
    }
    
    // 显示结果
    fmt.Println("查询到的用户:")
    for i, user := range users {
        fmt.Printf("用户 #%d: ID=%d, 名称=%s, 年龄=%d, 邮箱=%s, 是否管理员=%v\n",
                  i+1, user.ID, user.Name, user.Age, user.Email, user.IsAdmin)
    }
}
```

### 5.2 实现依赖注入
```go
package main

import (
    "fmt"
    "reflect"
)

// 依赖注入容器
type Container struct {
    // 存储注册的服务
    services map[reflect.Type]interface{}
}

// 创建新容器
func NewContainer() *Container {
    return &Container{
        services: make(map[reflect.Type]interface{}),
    }
}

// 注册服务
func (c *Container) Register(service interface{}) {
    t := reflect.TypeOf(service)
    c.services[t] = service
}

// 按类型获取服务
func (c *Container) Get(t reflect.Type) (interface{}, bool) {
    service, ok := c.services[t]
    return service, ok
}

// 解析结构体并注入依赖
func (c *Container) Resolve(target interface{}) error {
    targetValue := reflect.ValueOf(target)
    
    // 必须是指针
    if targetValue.Kind() != reflect.Ptr {
        return fmt.Errorf("目标必须是指针")
    }
    
    // 获取结构体元素
    targetElem := targetValue.Elem()
    if targetElem.Kind() != reflect.Struct {
        return fmt.Errorf("目标必须是结构体指针")
    }
    
    targetType := targetElem.Type()
    
    // 遍历所有字段
    for i := 0; i < targetElem.NumField(); i++ {
        field := targetElem.Field(i)
        fieldType := targetType.Field(i)
        
        // 检查是否可设置
        if !field.CanSet() {
            continue
        }
        
        // 查找标记为需要注入的字段
        if _, ok := fieldType.Tag.Lookup("inject"); ok {
            // 查找对应类型的服务
            service, found := c.Get(field.Type())
            if found {
                // 注入服务
                field.Set(reflect.ValueOf(service))
            }
        }
    }
    
    return nil
}

// 示例依赖
type Logger interface {
    Log(message string)
}

type ConsoleLogger struct{}

func (l *ConsoleLogger) Log(message string) {
    fmt.Println("日志:", message)
}

type Database interface {
    Query(sql string) []string
}

type SQLiteDatabase struct{}

func (db *SQLiteDatabase) Query(sql string) []string {
    return []string{"结果1", "结果2"}
}

// 使用依赖的服务
type UserService struct {
    Logger   Logger   `inject:""`
    Database Database `inject:""`
}

func (s *UserService) CreateUser(name string) {
    s.Logger.Log("创建用户: " + name)
    results := s.Database.Query("INSERT INTO users VALUES ('" + name + "')")
    s.Logger.Log(fmt.Sprintf("查询结果: %v", results))
}

func main() {
    // 创建容器
    container := NewContainer()
    
    // 注册服务
    container.Register(&ConsoleLogger{})
    container.Register(&SQLiteDatabase{})
    
    // 创建服务并解析依赖
    userService := &UserService{}
    if err := container.Resolve(userService); err != nil {
        fmt.Println("解析错误:", err)
        return
    }
    
    // 使用服务
    userService.CreateUser("张三")
}
```

### 5.3 实现配置解析
```go
package main

import (
    "encoding/json"
    "fmt"
    "os"
    "reflect"
    "strconv"
    "strings"
)

// 配置解析器
type ConfigParser struct{}

// 从环境变量加载配置
func (p *ConfigParser) LoadFromEnv(config interface{}) error {
    configValue := reflect.ValueOf(config)
    
    // 确保是指针
    if configValue.Kind() != reflect.Ptr {
        return fmt.Errorf("配置必须是指针")
    }
    
    // 获取指针指向的元素
    configElem := configValue.Elem()
    if configElem.Kind() != reflect.Struct {
        return fmt.Errorf("配置必须是结构体指针")
    }
    
    configType := configElem.Type()
    
    // 遍历所有字段
    for i := 0; i < configElem.NumField(); i++ {
        field := configElem.Field(i)
        fieldType := configType.Field(i)
        
        // 检查是否可设置
        if !field.CanSet() {
            continue
        }
        
        // 获取环境变量名
        envName := fieldType.Tag.Get("env")
        if envName == "" {
            // 默认使用字段名转大写
            envName = strings.ToUpper(fieldType.Name)
        }
        
        // 获取环境变量值
        envValue, exists := os.LookupEnv(envName)
        if !exists {
            // 检查是否有默认值
            if defaultValue := fieldType.Tag.Get("default"); defaultValue != "" {
                envValue = defaultValue
            } else {
                continue // 没有环境变量且没有默认值，跳过
            }
        }
        
        // 根据字段类型设置值
        switch field.Kind() {
        case reflect.String:
            field.SetString(envValue)
        
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
            if intValue, err := strconv.ParseInt(envValue, 10, 64); err == nil {
                field.SetInt(intValue)
            }
        
        case reflect.Bool:
            if boolValue, err := strconv.ParseBool(envValue); err == nil {
                field.SetBool(boolValue)
            }
        
        case reflect.Float32, reflect.Float64:
            if floatValue, err := strconv.ParseFloat(envValue, 64); err == nil {
                field.SetFloat(floatValue)
            }
        
        case reflect.Slice:
            if field.Type().Elem().Kind() == reflect.String {
                // 处理字符串切片
                values := strings.Split(envValue, ",")
                slice := reflect.MakeSlice(field.Type(), len(values), len(values))
                for i, v := range values {
                    slice.Index(i).SetString(strings.TrimSpace(v))
                }
                field.Set(slice)
            }
        
        case reflect.Map:
            if field.Type().Key().Kind() == reflect.String && 
               field.Type().Elem().Kind() == reflect.String {
                // 处理字符串到字符串的映射
                mapValue := reflect.MakeMap(field.Type())
                pairs := strings.Split(envValue, ",")
                for _, pair := range pairs {
                    kv := strings.SplitN(pair, "=", 2)
                    if len(kv) == 2 {
                        key := strings.TrimSpace(kv[0])
                        value := strings.TrimSpace(kv[1])
                        mapValue.SetMapIndex(reflect.ValueOf(key), reflect.ValueOf(value))
                    }
                }
                field.Set(mapValue)
            }
        
        case reflect.Struct:
            // 对于嵌套结构体，尝试解析JSON
            if envValue != "" {
                newValue := reflect.New(field.Type()).Interface()
                if err := json.Unmarshal([]byte(envValue), newValue); err == nil {
                    field.Set(reflect.ValueOf(newValue).Elem())
                }
            }
        }
    }
    
    return nil
}

// 示例配置结构体
type AppConfig struct {
    ServerHost     string            `env:"SERVER_HOST" default:"localhost"`
    ServerPort     int               `env:"SERVER_PORT" default:"8080"`
    Debug          bool              `env:"DEBUG" default:"false"`
    DatabaseURL    string            `env:"DATABASE_URL" required:"true"`
    AllowedOrigins []string          `env:"ALLOWED_ORIGINS" default:"http://localhost:3000"`
    Features       map[string]string `env:"FEATURES"`
}

func main() {
    // 设置一些环境变量进行测试
    os.Setenv("SERVER_PORT", "9000")
    os.Setenv("DEBUG", "true")
    os.Setenv("DATABASE_URL", "postgres://user:pass@localhost:5432/db")
    os.Setenv("ALLOWED_ORIGINS", "http://example.com, http://localhost:8080")
    os.Setenv("FEATURES", "login=enabled, registration=disabled, admin=true")
    
    // 创建配置实例
    config := &AppConfig{}
    
    // 解析配置
    parser := &ConfigParser{}
    if err := parser.LoadFromEnv(config); err != nil {
        fmt.Println("配置解析错误:", err)
        return
    }
    
    // 显示配置
    fmt.Printf("服务器主机: %s\n", config.ServerHost)
    fmt.Printf("服务器端口: %d\n", config.ServerPort)
    fmt.Printf("调试模式: %v\n", config.Debug)
    fmt.Printf("数据库URL: %s\n", config.DatabaseURL)
    fmt.Printf("允许的来源: %v\n", config.AllowedOrigins)
    fmt.Printf("功能标志: %v\n", config.Features)
}
```

---

## 6. 高级技巧

### 6.1 反射与并发
```go
package main

import (
    "fmt"
    "reflect"
    "sync"
    "time"
)

// 使用反射实现通用的并行映射
func parallelMap(slice interface{}, fn interface{}) interface{} {
    sliceValue := reflect.ValueOf(slice)
    fnValue := reflect.ValueOf(fn)
    
    // 验证输入
    if sliceValue.Kind() != reflect.Slice {
        panic("第一个参数必须是切片")
    }
    
    if fnValue.Kind() != reflect.Func {
        panic("第二个参数必须是函数")
    }
    
    // 检查函数签名
    fnType := fnValue.Type()
    if fnType.NumIn() != 1 || fnType.NumOut() != 1 {
        panic("函数必须接受一个参数并返回一个值")
    }
    
    // 获取输入切片元素类型和输出切片元素类型
    inElemType := sliceValue.Type().Elem()
    outElemType := fnType.Out(0)
    
    // 创建输出切片
    resultSlice := reflect.MakeSlice(
        reflect.SliceOf(outElemType),
        sliceValue.Len(),
        sliceValue.Len(),
    )
    
    // 并行处理
    var wg sync.WaitGroup
    for i := 0; i < sliceValue.Len(); i++ {
        wg.Add(1)
        go func(idx int) {
            defer wg.Done()
            
            // 获取输入元素
            elem := sliceValue.Index(idx)
            
            // 调用函数
            result := fnValue.Call([]reflect.Value{elem})
            
            // 存储结果
            resultSlice.Index(idx).Set(result[0])
        }(i)
    }
    
    // 等待所有goroutine完成
    wg.Wait()
    
    return resultSlice.Interface()
}

func main() {
    // 测试整数切片
    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    
    squares := parallelMap(numbers, func(x int) int {
        time.Sleep(100 * time.Millisecond) // 模拟耗时操作
        return x * x
    })
    
    fmt.Println("原始数字:", numbers)
    fmt.Println("并行计算平方:", squares)
    
    // 测试字符串切片
    words := []string{"hello", "world", "parallel", "processing"}
    
    lengths := parallelMap(words, func(s string) int {
        time.Sleep(100 * time.Millisecond) // 模拟耗时操作
        return len(s)
    })
    
    fmt.Println("单词:", words)
    fmt.Println("并行计算长度:", lengths)
    
    // 测试类型转换
    stringified := parallelMap(numbers, func(x int) string {
        time.Sleep(100 * time.Millisecond) // 模拟耗时操作
        return fmt.Sprintf("数字%d", x)
    })
    
    fmt.Println("数字转字符串:", stringified)
}
```

### 6.2 深拷贝
```go
package main

import (
    "fmt"
    "reflect"
)

// 深度复制函数
func deepCopy(source interface{}) interface{} {
    // 特殊情况：nil
    if source == nil {
        return nil
    }
    
    sourceValue := reflect.ValueOf(source)
    
    // 创建副本的函数
    return deepCopyValue(sourceValue).Interface()
}

// 复制reflect.Value
func deepCopyValue(source reflect.Value) reflect.Value {
    // 处理无效值
    if !source.IsValid() {
        return reflect.Value{}
    }
    
    // 获取类型
    sourceType := source.Type()
    
    // 处理不需要深度复制的类型
    switch sourceType.Kind() {
    case reflect.Bool, reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
         reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr,
         reflect.Float32, reflect.Float64, reflect.Complex64, reflect.Complex128, reflect.String:
        return source
    }
    
    // 处理指针
    if sourceType.Kind() == reflect.Ptr {
        // nil指针直接返回
        if source.IsNil() {
            return reflect.Zero(sourceType)
        }
        
        // 创建新指针
        targetValue := reflect.New(sourceType.Elem())
        
        // 复制指针指向的值
        elemValue := deepCopyValue(source.Elem())
        targetValue.Elem().Set(elemValue)
        
        return targetValue
    }
    
    // 处理接口
    if sourceType.Kind() == reflect.Interface {
        // nil接口直接返回
        if source.IsNil() {
            return reflect.Zero(sourceType)
        }
        
        // 复制接口内的值
        elemValue := deepCopyValue(source.Elem())
        return elemValue
    }
    
    // 处理切片
    if sourceType.Kind() == reflect.Slice {
        // nil切片直接返回
        if source.IsNil() {
            return reflect.Zero(sourceType)
        }
        
        // 空切片处理
        length := source.Len()
        if length == 0 {
            return reflect.MakeSlice(sourceType, 0, 0)
        }
        
        // 创建新切片
        targetValue := reflect.MakeSlice(sourceType, length, length)
        
        // 复制每个元素
        for i := 0; i < length; i++ {
            elemValue := deepCopyValue(source.Index(i))
            targetValue.Index(i).Set(elemValue)
        }
        
        return targetValue
    }
    
    // 处理映射
    if sourceType.Kind() == reflect.Map {
        // nil映射直接返回
        if source.IsNil() {
            return reflect.Zero(sourceType)
        }
        
        // 创建新映射
        targetValue := reflect.MakeMap(sourceType)
        
        // 复制每个键值对
        iter := source.MapRange()
        for iter.Next() {
            key := iter.Key()
            value := iter.Value()
            
            // 复制值
            copiedValue := deepCopyValue(value)
            
            // 添加到新映射
            targetValue.SetMapIndex(key, copiedValue)
        }
        
        return targetValue
    }
    
    // 处理结构体
    if sourceType.Kind() == reflect.Struct {
        // 创建新结构体
        targetValue := reflect.New(sourceType).Elem()
        
        // 复制每个字段
        for i := 0; i < sourceType.NumField(); i++ {
            field := source.Field(i)
            
            // 检查是否可设置
            if field.CanInterface() {
                // 复制字段值
                copiedField := deepCopyValue(field)
                
                // 设置字段
                targetField := targetValue.Field(i)
                if targetField.CanSet() {
                    targetField.Set(copiedField)
                }
            }
        }
        
        return targetValue
    }
    
    // 其他类型直接返回零值
    return reflect.Zero(sourceType)
}

func main() {
    // 测试基本类型
    num := 42
    numCopy := deepCopy(num)
    fmt.Printf("整数: %d, 副本: %d\n", num, numCopy)
    
    // 测试指针
    ptr := &num
    ptrCopy := deepCopy(ptr).(*int)
    *ptrCopy = 100 // 修改副本不影响原始值
    fmt.Printf("指针: %d, 副本: %d, 原始值: %d\n", *ptr, *ptrCopy, num)
    
    // 测试结构体
    type Person struct {
        Name  string
        Age   int
        Hobby []string
        Info  map[string]string
    }
    
    person := Person{
        Name:  "张三",
        Age:   30,
        Hobby: []string{"读书", "旅游"},
        Info: map[string]string{
            "email": "zhangsan@example.com",
            "phone": "123456789",
        },
    }
    
    personCopy := deepCopy(person).(Person)
    
    // 修改副本
    personCopy.Name = "李四"
    personCopy.Age = 25
    personCopy.Hobby[0] = "游泳"
    personCopy.Info["email"] = "lisi@example.com"
    
    // 比较原始值和副本
    fmt.Println("\n原始结构体:")
    fmt.Printf("  姓名: %s\n", person.Name)
    fmt.Printf("  年龄: %d\n", person.Age)
    fmt.Printf("  爱好: %v\n", person.Hobby)
    fmt.Printf("  信息: %v\n", person.Info)
    
    fmt.Println("\n复制的结构体:")
    fmt.Printf("  姓名: %s\n", personCopy.Name)
    fmt.Printf("  年龄: %d\n", personCopy.Age)
    fmt.Printf("  爱好: %v\n", personCopy.Hobby)
    fmt.Printf("  信息: %v\n", personCopy.Info)
}
```

### 6.3 类型转换
```go
package main

import (
    "fmt"
    "reflect"
    "strconv"
)

// 通用类型转换函数
func convert(value interface{}, targetType reflect.Type) (interface{}, error) {
    // 源值
    v := reflect.ValueOf(value)
    
    // 如果源类型和目标类型相同，直接返回
    if v.Type() == targetType {
        return value, nil
    }
    
    // 创建目标类型的零值
    target := reflect.New(targetType).Elem()
    
    // 尝试转换
    switch targetType.Kind() {
    case reflect.String:
        // 任何类型到字符串
        switch v.Kind() {
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
            target.SetString(strconv.FormatInt(v.Int(), 10))
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
            target.SetString(strconv.FormatUint(v.Uint(), 10))
        case reflect.Float32, reflect.Float64:
            target.SetString(strconv.FormatFloat(v.Float(), 'f', -1, 64))
        case reflect.Bool:
            target.SetString(strconv.FormatBool(v.Bool()))
        default:
            return nil, fmt.Errorf("无法将类型 %s 转换为字符串", v.Type())
        }
        
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
        // 到整数的转换
        switch v.Kind() {
        case reflect.String:
            i, err := strconv.ParseInt(v.String(), 10, 64)
            if err != nil {
                return nil, err
            }
            target.SetInt(i)
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
            target.SetInt(v.Int())
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
            target.SetInt(int64(v.Uint()))
        case reflect.Float32, reflect.Float64:
            target.SetInt(int64(v.Float()))
        case reflect.Bool:
            if v.Bool() {
                target.SetInt(1)
            } else {
                target.SetInt(0)
            }
        default:
            return nil, fmt.Errorf("无法将类型 %s 转换为整数", v.Type())
        }
        
    case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
        // 到无符号整数的转换
        switch v.Kind() {
        case reflect.String:
            u, err := strconv.ParseUint(v.String(), 10, 64)
            if err != nil {
                return nil, err
            }
            target.SetUint(u)
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
            if v.Int() < 0 {
                return nil, fmt.Errorf("无法将负整数转换为无符号整数")
            }
            target.SetUint(uint64(v.Int()))
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
            target.SetUint(v.Uint())
        case reflect.Float32, reflect.Float64:
            if v.Float() < 0 {
                return nil, fmt.Errorf("无法将负浮点数转换为无符号整数")
            }
            target.SetUint(uint64(v.Float()))
        case reflect.Bool:
            if v.Bool() {
                target.SetUint(1)
            } else {
                target.SetUint(0)
            }
        default:
            return nil, fmt.Errorf("无法将类型 %s 转换为无符号整数", v.Type())
        }
        
    case reflect.Float32, reflect.Float64:
        // 到浮点数的转换
        switch v.Kind() {
        case reflect.String:
            f, err := strconv.ParseFloat(v.String(), 64)
            if err != nil {
                return nil, err
            }
            target.SetFloat(f)
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
            target.SetFloat(float64(v.Int()))
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
            target.SetFloat(float64(v.Uint()))
        case reflect.Float32, reflect.Float64:
            target.SetFloat(v.Float())
        case reflect.Bool:
            if v.Bool() {
                target.SetFloat(1.0)
            } else {
                target.SetFloat(0.0)
            }
        default:
            return nil, fmt.Errorf("无法将类型 %s 转换为浮点数", v.Type())
        }
        
    case reflect.Bool:
        // 到布尔值的转换
        switch v.Kind() {
        case reflect.String:
            b, err := strconv.ParseBool(v.String())
            if err != nil {
                return nil, err
            }
            target.SetBool(b)
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
            target.SetBool(v.Int() != 0)
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
            target.SetBool(v.Uint() != 0)
        case reflect.Float32, reflect.Float64:
            target.SetBool(v.Float() != 0)
        case reflect.Bool:
            target.SetBool(v.Bool())
        default:
            return nil, fmt.Errorf("无法将类型 %s 转换为布尔值", v.Type())
        }
        
    case reflect.Slice:
        // 尝试创建切片
        if v.Kind() == reflect.Slice {
            // 源和目标都是切片，但元素类型不同
            sourceElemType := v.Type().Elem()
            targetElemType := targetType.Elem()
            
            // 创建新切片
            newSlice := reflect.MakeSlice(targetType, v.Len(), v.Cap())
            
            // 转换每个元素
            for i := 0; i < v.Len(); i++ {
                elem := v.Index(i).Interface()
                newElem, err := convert(elem, targetElemType)
                if err != nil {
                    return nil, fmt.Errorf("转换切片元素 #%d 失败: %v", i, err)
                }
                newSlice.Index(i).Set(reflect.ValueOf(newElem))
            }
            
            target.Set(newSlice)
        } else {
            return nil, fmt.Errorf("无法将类型 %s 转换为切片", v.Type())
        }
        
    default:
        return nil, fmt.Errorf("不支持转换到类型 %s", targetType)
    }
    
    return target.Interface(), nil
}

func main() {
    // 测试基本类型转换
    tests := []struct {
        value interface{}
        typ   reflect.Type
    }{
        {42, reflect.TypeOf("")},                  // int -> string
        {"123", reflect.TypeOf(0)},                // string -> int
        {3.14, reflect.TypeOf(0)},                 // float -> int
        {true, reflect.TypeOf("")},                // bool -> string
        {"true", reflect.TypeOf(false)},           // string -> bool
        {[]int{1, 2, 3}, reflect.TypeOf([]string{})}, // []int -> []string
    }
    
    for i, test := range tests {
        result, err := convert(test.value, test.typ)
        if err != nil {
            fmt.Printf("测试 #%d: 转换 %v (%T) 到 %s 失败: %v\n", 
                      i+1, test.value, test.value, test.typ, err)
        } else {
            fmt.Printf("测试 #%d: %v (%T) -> %v (%T)\n", 
                      i+1, test.value, test.value, result, result)
        }
    }
}
```

---

## 7. 反射性能和最佳实践

### 7.1 反射的性能开销
```go
package main

import (
    "fmt"
    "reflect"
    "testing"
    "time"
)

func directAccess(s []int) int {
    sum := 0
    for i := 0; i < len(s); i++ {
        sum += s[i]
    }
    return sum
}

func reflectAccess(s interface{}) int {
    sum := 0
    v := reflect.ValueOf(s)
    for i := 0; i < v.Len(); i++ {
        sum += int(v.Index(i).Int())
    }
    return sum
}

func BenchmarkDirectAccess(b *testing.B) {
    s := make([]int, 1000)
    for i := 0; i < len(s); i++ {
        s[i] = i
    }
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _ = directAccess(s)
    }
}

func BenchmarkReflectAccess(b *testing.B) {
    s := make([]int, 1000)
    for i := 0; i < len(s); i++ {
        s[i] = i
    }
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _ = reflectAccess(s)
    }
}

func main() {
    // 直接模拟一个简单的基准测试
    size := 1000000
    s := make([]int, size)
    for i := 0; i < size; i++ {
        s[i] = i
    }
    
    // 直接访问
    start := time.Now()
    directResult := directAccess(s)
    directDuration := time.Since(start)
    
    // 反射访问
    start = time.Now()
    reflectResult := reflectAccess(s)
    reflectDuration := time.Since(start)
    
    fmt.Printf("直接访问结果: %d, 耗时: %v\n", directResult, directDuration)
    fmt.Printf("反射访问结果: %d, 耗时: %v\n", reflectResult, reflectDuration)
    fmt.Printf("反射比直接访问慢 %.2f 倍\n", 
              float64(reflectDuration.Nanoseconds()) / float64(directDuration.Nanoseconds()))
    
    fmt.Println("\n使用以下命令运行完整基准测试:")
    fmt.Println("go test -bench=. -benchmem")
}
```

### 7.2 缓存反射结果
```go
package main

import (
    "fmt"
    "reflect"
    "sync"
    "time"
)

// 缓存类型信息
var (
    structFieldsCache = make(map[reflect.Type][]reflect.StructField)
    cacheMutex        sync.RWMutex
)

// 不使用缓存的函数
func getFieldsNoCache(t reflect.Type) []reflect.StructField {
    if t.Kind() != reflect.Struct {
        return nil
    }
    
    fields := make([]reflect.StructField, t.NumField())
    for i := 0; i < t.NumField(); i++ {
        fields[i] = t.Field(i)
    }
    
    return fields
}

// 使用缓存的函数
func getFieldsWithCache(t reflect.Type) []reflect.StructField {
    if t.Kind() != reflect.Struct {
        return nil
    }
    
    // 先检查缓存
    cacheMutex.RLock()
    fields, ok := structFieldsCache[t]
    cacheMutex.RUnlock()
    
    if ok {
        return fields
    }
    
    // 缓存未命中，获取字段
    fields = make([]reflect.StructField, t.NumField())
    for i := 0; i < t.NumField(); i++ {
        fields[i] = t.Field(i)
    }
    
    // 更新缓存
    cacheMutex.Lock()
    structFieldsCache[t] = fields
    cacheMutex.Unlock()
    
    return fields
}

// 复杂结构体
type ComplexStruct struct {
    Field1  string
    Field2  int
    Field3  bool
    Field4  float64
    Field5  []int
    Field6  map[string]int
    Field7  struct {
        NestedField1 string
        NestedField2 int
    }
    Field8  string
    Field9  int
    Field10 bool
    Field11 float64
    Field12 []int
    Field13 map[string]int
    Field14 struct {
        NestedField1 string
        NestedField2 int
    }
    Field15 string
}

func main() {
    // 获取结构体类型
    t := reflect.TypeOf(ComplexStruct{})
    
    // 测试无缓存性能
    start := time.Now()
    for i := 0; i < 100000; i++ {
        _ = getFieldsNoCache(t)
    }
    noCacheDuration := time.Since(start)
    
    // 测试有缓存性能
    start = time.Now()
    for i := 0; i < 100000; i++ {
        _ = getFieldsWithCache(t)
    }
    withCacheDuration := time.Since(start)
    
    fmt.Printf("无缓存耗时: %v\n", noCacheDuration)
    fmt.Printf("有缓存耗时: %v\n", withCacheDuration)
    fmt.Printf("缓存提升性能 %.2f 倍\n", 
              float64(noCacheDuration.Nanoseconds()) / float64(withCacheDuration.Nanoseconds()))
    
    // 检查缓存内容
    cacheMutex.RLock()
    cachedTypes := make([]reflect.Type, 0, len(structFieldsCache))
    for k := range structFieldsCache {
        cachedTypes = append(cachedTypes, k)
    }
    cacheMutex.RUnlock()
    
    fmt.Println("\n缓存中的类型:")
    for _, t := range cachedTypes {
        fmt.Printf("  %s\n", t.Name())
    }
}
```

### 7.3 反射的最佳实践
```go
package main

import (
    "fmt"
    "reflect"
)

// 最佳实践1: 限制反射使用范围
// 不好的示例: 到处使用反射
func processBadExample(data interface{}) {
    v := reflect.ValueOf(data)
    if v.Kind() == reflect.Struct {
        for i := 0; i < v.NumField(); i++ {
            field := v.Field(i)
            processValue(field.Interface())
        }
    }
}

// 好的示例: 将反射限制在边界内
type DataProcessor struct {
    cache map[reflect.Type][]reflect.StructField
}

func NewDataProcessor() *DataProcessor {
    return &DataProcessor{
        cache: make(map[reflect.Type][]reflect.StructField),
    }
}

func (p *DataProcessor) ProcessData(data interface{}) {
    // 反射只在处理器内部使用
    v := reflect.ValueOf(data)
    if v.Kind() == reflect.Struct {
        fields := p.getStructFields(v.Type())
        for _, field := range fields {
            fieldValue := v.FieldByIndex(field.Index)
            // 将反射值转换回普通值
            typedValue := fieldValue.Interface()
            // 使用非反射代码处理
            processTypedValue(typedValue)
        }
    }
}

func (p *DataProcessor) getStructFields(t reflect.Type) []reflect.StructField {
    if fields, ok := p.cache[t]; ok {
        return fields
    }
    
    fields := make([]reflect.StructField, t.NumField())
    for i := 0; i < t.NumField(); i++ {
        fields[i] = t.Field(i)
    }
    
    p.cache[t] = fields
    return fields
}

// 最佳实践2: 使用接口而非反射
// 不好的示例: 使用反射调用方法
func callMethodBadExample(obj interface{}, methodName string, args ...interface{}) interface{} {
    v := reflect.ValueOf(obj)
    method := v.MethodByName(methodName)
    
    // 转换参数
    reflectArgs := make([]reflect.Value, len(args))
    for i, arg := range args {
        reflectArgs[i] = reflect.ValueOf(arg)
    }
    
    // 调用方法
    results := method.Call(reflectArgs)
    
    // 返回第一个结果
    if len(results) > 0 {
        return results[0].Interface()
    }
    
    return nil
}

// 好的示例: 使用接口
type Worker interface {
    DoWork(data string) string
}

func ProcessWork(worker Worker, data string) string {
    return worker.DoWork(data)
}

// 实现Worker接口
type ConcreteWorker struct{}

func (w ConcreteWorker) DoWork(data string) string {
    return "处理: " + data
}

// 最佳实践3: 错误处理
// 不好的示例: 忽略错误检查
func setValueBadExample(target interface{}, value interface{}) {
    v := reflect.ValueOf(target).Elem()
    v.Set(reflect.ValueOf(value))
}

// 好的示例: 完善的错误处理
func setValueGoodExample(target interface{}, value interface{}) error {
    v := reflect.ValueOf(target)
    
    if v.Kind() != reflect.Ptr {
        return fmt.Errorf("目标必须是指针")
    }
    
    v = v.Elem()
    if !v.CanSet() {
        return fmt.Errorf("目标不可设置")
    }
    
    valueV := reflect.ValueOf(value)
    if v.Type() != valueV.Type() {
        return fmt.Errorf(
            "类型不匹配: 目标类型为 %v, 值类型为 %v", 
            v.Type(), valueV.Type(),
        )
    }
    
    v.Set(valueV)
    return nil
}

// 处理函数 - 假设这是正常的业务逻辑
func processValue(v interface{}) {
    fmt.Printf("处理值: %v\n", v)
}

func processTypedValue(v interface{}) {
    fmt.Printf("处理类型化值: %v\n", v)
}

// 示例数据
type Person struct {
    Name   string
    Age    int
    Active bool
}

func main() {
    // 最佳实践演示
    
    fmt.Println("1. 限制反射使用范围:")
    person := Person{Name: "张三", Age: 30, Active: true}
    
    processor := NewDataProcessor()
    processor.ProcessData(person)
    
    fmt.Println("\n2. 使用接口而非反射:")
    worker := ConcreteWorker{}
    
    // 不使用反射，直接通过接口调用
    result := ProcessWork(worker, "样本数据")
    fmt.Println("接口调用结果:", result)
    
    // 使用反射调用 (仅作对比，实际应避免)
    reflectResult := callMethodBadExample(worker, "DoWork", "样本数据")
    fmt.Println("反射调用结果:", reflectResult)
    
    fmt.Println("\n3. 错误处理:")
    var target int = 0
    
    // 类型匹配情况
    err := setValueGoodExample(&target, 42)
    if err != nil {
        fmt.Println("错误:", err)
    } else {
        fmt.Println("设置值成功:", target)
    }
    
    // 类型不匹配情况
    err = setValueGoodExample(&target, "字符串")
    if err != nil {
        fmt.Println("错误:", err)
    }
    
    // 非指针情况
    err = setValueGoodExample(target, 100)
    if err != nil {
        fmt.Println("错误:", err)
    }
}
```

### 7.4 避免反射的替代方案
```go
package main

import (
    "encoding/json"
    "fmt"
    "reflect"
    "time"
)

// 要处理的数据结构
type Product struct {
    ID    int       `json:"id"`
    Name  string    `json:"name"`
    Price float64   `json:"price"`
    Date  time.Time `json:"date"`
}

// 反射方式: 动态解析和处理结构体
func processWithReflection(product interface{}) map[string]interface{} {
    result := make(map[string]interface{})
    
    v := reflect.ValueOf(product)
    t := v.Type()
    
    for i := 0; i < v.NumField(); i++ {
        field := t.Field(i)
        fieldValue := v.Field(i)
        
        // 获取JSON标签
        tag := field.Tag.Get("json")
        if tag == "" {
            tag = field.Name
        }
        
        // 根据字段类型处理
        switch fieldValue.Kind() {
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
            result[tag] = fieldValue.Int()
        case reflect.Float32, reflect.Float64:
            result[tag] = fieldValue.Float()
        case reflect.String:
            result[tag] = fieldValue.String()
        case reflect.Struct:
            // 处理time.Time特殊情况
            if fieldValue.Type() == reflect.TypeOf(time.Time{}) {
                timeValue := fieldValue.Interface().(time.Time)
                result[tag] = timeValue.Format("2006-01-02")
            } else {
                // 递归处理嵌套结构体
                result[tag] = processWithReflection(fieldValue.Interface())
            }
        default:
            result[tag] = fieldValue.Interface()
        }
    }
    
    return result
}

// 替代方案1: 使用JSON编码/解码
func processWithJSON(product interface{}) (map[string]interface{}, error) {
    // 先将结构体编码为JSON
    data, err := json.Marshal(product)
    if err != nil {
        return nil, err
    }
    
    // 再解码为map
    var result map[string]interface{}
    err = json.Unmarshal(data, &result)
    if err != nil {
        return nil, err
    }
    
    return result, nil
}

// 替代方案2: 使用自定义方法
type ProductProcessor interface {
    ToMap() map[string]interface{}
}

func (p Product) ToMap() map[string]interface{} {
    return map[string]interface{}{
        "id":    p.ID,
        "name":  p.Name,
        "price": p.Price,
        "date":  p.Date.Format("2006-01-02"),
    }
}

// 替代方案3: 使用代码生成
// 注: 这里只是演示，实际代码生成需要单独的工具
// 假设这是生成的代码
func ProductToMap(p Product) map[string]interface{} {
    return map[string]interface{}{
        "id":    p.ID,
        "name":  p.Name,
        "price": p.Price,
        "date":  p.Date.Format("2006-01-02"),
    }
}

func main() {
    product := Product{
        ID:    1,
        Name:  "笔记本电脑",
        Price: 6999.99,
        Date:  time.Now(),
    }
    
    // 使用反射方式
    reflectResult := processWithReflection(product)
    fmt.Println("反射方式结果:")
    for k, v := range reflectResult {
        fmt.Printf("  %s: %v\n", k, v)
    }
    
    // 使用JSON方式
    jsonResult, err := processWithJSON(product)
    if err != nil {
        fmt.Println("JSON处理错误:", err)
    } else {
        fmt.Println("\nJSON方式结果:")
        for k, v := range jsonResult {
            fmt.Printf("  %s: %v\n", k, v)
        }
    }
    
    // 使用接口方式
    interfaceResult := product.ToMap()
    fmt.Println("\n接口方式结果:")
    for k, v := range interfaceResult {
        fmt.Printf("  %s: %v\n", k, v)
    }
    
    // 使用生成代码方式
    generatedResult := ProductToMap(product)
    fmt.Println("\n代码生成方式结果:")
    for k, v := range generatedResult {
        fmt.Printf("  %s: %v\n", k, v)
    }
    
    // 性能比较
    iterations := 10000
    
    start := time.Now()
    for i := 0; i < iterations; i++ {
        _ = processWithReflection(product)
    }
    reflectDuration := time.Since(start)
    
    start = time.Now()
    for i := 0; i < iterations; i++ {
        _, _ = processWithJSON(product)
    }
    jsonDuration := time.Since(start)
    
    start = time.Now()
    for i := 0; i < iterations; i++ {
        _ = product.ToMap()
    }
    interfaceDuration := time.Since(start)
    
    start = time.Now()
    for i := 0; i < iterations; i++ {
        _ = ProductToMap(product)
    }
    generatedDuration := time.Since(start)
    
    fmt.Println("\n性能比较 (迭代次数:", iterations, "):")
    fmt.Printf("  反射方式: %v\n", reflectDuration)
    fmt.Printf("  JSON方式: %v\n", jsonDuration)
    fmt.Printf("  接口方式: %v\n", interfaceDuration)
    fmt.Printf("  生成代码方式: %v\n", generatedDuration)
}
```

---

## 8. 学习检查点

- [ ] 理解反射的基本概念和原理
- [ ] 掌握`reflect.Type`和`reflect.Value`的使用
- [ ] 能够通过反射分析和操作基本类型
- [ ] 能够通过反射分析和操作复合类型
- [ ] 能够通过反射调用函数和方法
- [ ] 理解反射与接口的关系
- [ ] 掌握反射的实际应用场景
- [ ] 了解反射的性能影响和最佳实践

---

反射是Go语言中的高级特性，它提供了在运行时检查和操作程序结构的能力。虽然强大，但反射应当谨慎使用，并遵循最佳实践以避免可维护性和性能问题。掌握反射机制将使你能够创建更灵活、更通用的Go程序，特别是在需要处理未知类型或编写通用库时。
