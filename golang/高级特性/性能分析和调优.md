# Goè¯­è¨€æ€§èƒ½åˆ†æå’Œè°ƒä¼˜

## ğŸ“š å­¦ä¹ ç›®æ ‡
æŒæ¡Goè¯­è¨€çš„æ€§èƒ½åˆ†æå·¥å…·å’Œè°ƒä¼˜æ–¹æ³•ï¼Œç†è§£ä»£ç ä¼˜åŒ–çš„æœ€ä½³å®è·µã€‚

---

## 1. æ€§èƒ½åˆ†æå·¥å…·

### 1.1 ä½¿ç”¨`pprof`è¿›è¡Œæ€§èƒ½åˆ†æ
```go
package main

import (
    "fmt"
    "net/http"
    _ "net/http/pprof"
)

func main() {
    go func() {
        fmt.Println(http.ListenAndServe("localhost:6060", nil))
    }()

    for i := 0; i < 1000000; i++ {
        fmt.Sprintf("æµ‹è¯•æ•°æ® %d", i)
    }
}
```

### 1.2 åˆ†æCPUå’Œå†…å­˜
- å¯åŠ¨ç¨‹åºåï¼Œè®¿é—®`http://localhost:6060/debug/pprof/`æŸ¥çœ‹æ€§èƒ½æ•°æ®ã€‚
- ä½¿ç”¨`go tool pprof`åˆ†ææ€§èƒ½æŠ¥å‘Šã€‚

---

## 2. æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### 2.1 å‡å°‘å†…å­˜åˆ†é…
```go
package main

import "fmt"

func main() {
    data := make([]int, 0, 1000) // é¢„åˆ†é…å®¹é‡
    for i := 0; i < 1000; i++ {
        data = append(data, i)
    }
    fmt.Println("æ•°æ®é•¿åº¦:", len(data))
}
```

### 2.2 ä½¿ç”¨å¯¹è±¡æ± 
```go
package main

import (
    "fmt"
    "sync"
)

var pool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 1024) // åˆ†é…1KBçš„å†…å­˜
    },
}

func main() {
    buf := pool.Get().([]byte) // ä»å¯¹è±¡æ± è·å–
    fmt.Println("ä½¿ç”¨å¯¹è±¡æ± åˆ†é…å†…å­˜")

    pool.Put(buf) // å½’è¿˜å¯¹è±¡æ± 
}
```

---

## 3. å¹¶å‘æ€§èƒ½è°ƒä¼˜

### 3.1 ä½¿ç”¨`sync.WaitGroup`ä¼˜åŒ–åç¨‹ç®¡ç†
```go
package main

import (
    "fmt"
    "sync"
)

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()
    fmt.Printf("å·¥äºº%då¼€å§‹å·¥ä½œ\n", id)
}

func main() {
    var wg sync.WaitGroup

    for i := 1; i <= 10; i++ {
        wg.Add(1)
        go worker(i, &wg)
    }

    wg.Wait()
    fmt.Println("æ‰€æœ‰å·¥äººå®Œæˆä»»åŠ¡")
}
```

### 3.2 ä½¿ç”¨`sync.Map`ä¼˜åŒ–å¹¶å‘æ•°æ®è®¿é—®
```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    var m sync.Map

    m.Store("name", "Goè¯­è¨€")
    m.Store("version", "1.18")

    m.Range(func(key, value interface{}) bool {
        fmt.Printf("%s: %s\n", key, value)
        return true
    })
}
```

---

## 4. ç»¼åˆæ¡ˆä¾‹ï¼šæ€§èƒ½ä¼˜åŒ–å®è·µ
```go
package main

import (
    "fmt"
    "sync"
)

type Cache struct {
    data map[string]string
    mux  sync.RWMutex
}

func (c *Cache) Get(key string) string {
    c.mux.RLock()
    defer c.mux.RUnlock()
    return c.data[key]
}

func (c *Cache) Set(key, value string) {
    c.mux.Lock()
    defer c.mux.Unlock()
    c.data[key] = value
}

func main() {
    cache := Cache{data: make(map[string]string)}

    var wg sync.WaitGroup
    wg.Add(2)

    go func() {
        defer wg.Done()
        cache.Set("name", "Goè¯­è¨€")
    }()

    go func() {
        defer wg.Done()
        fmt.Println("è¯»å–ç¼“å­˜:", cache.Get("name"))
    }()

    wg.Wait()
}
```

---

## 5. å­¦ä¹ æ£€æŸ¥ç‚¹

- [ ] ç†è§£æ€§èƒ½åˆ†æå·¥å…·çš„ä½¿ç”¨æ–¹æ³•
- [ ] æŒæ¡ä»£ç ä¼˜åŒ–çš„å¸¸è§æŠ€å·§
- [ ] èƒ½ç”¨å¯¹è±¡æ± å‡å°‘å†…å­˜åˆ†é…
- [ ] èƒ½ç”¨å¹¶å‘ä¼˜åŒ–æå‡ç¨‹åºæ€§èƒ½
- [ ] èƒ½ç”¨æ€§èƒ½è°ƒä¼˜å®ç°å¤æ‚çš„ä¸šåŠ¡é€»è¾‘

---

æ€§èƒ½åˆ†æå’Œè°ƒä¼˜æ˜¯Goè¯­è¨€çš„é«˜çº§åº”ç”¨ï¼ŒæŒæ¡è¿™äº›åŸºç¡€å°†æ˜¾è‘—æå‡ç¨‹åºçš„è¿è¡Œæ•ˆç‡å’Œç¨³å®šæ€§ã€‚
