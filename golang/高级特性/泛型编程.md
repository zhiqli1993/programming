# Goè¯­è¨€æ³›å‹ç¼–ç¨‹

## ğŸ“š å­¦ä¹ ç›®æ ‡
æŒæ¡Goè¯­è¨€çš„æ³›å‹ç¼–ç¨‹ç‰¹æ€§ï¼Œç†è§£ç±»å‹å‚æ•°å’Œçº¦æŸçš„ä½¿ç”¨ï¼Œå­¦ä¼šè®¾è®¡çµæ´»çš„æ³›å‹å‡½æ•°å’Œæ•°æ®ç»“æ„ã€‚

---

## 1. æ³›å‹ç®€ä»‹

### 1.1 ä»€ä¹ˆæ˜¯æ³›å‹
æ³›å‹ç¼–ç¨‹å…è®¸æˆ‘ä»¬ç¼–å†™å¯ä»¥é€‚ç”¨äºå¤šç§ç±»å‹çš„ä»£ç ï¼ŒåŒæ—¶ä¿æŒç±»å‹å®‰å…¨ã€‚Goè¯­è¨€åœ¨1.18ç‰ˆæœ¬ï¼ˆ2022å¹´3æœˆï¼‰ä¸­æ­£å¼å¼•å…¥äº†æ³›å‹æ”¯æŒï¼Œä¸ºè¯­è¨€å¢åŠ äº†å¾ˆå¤§çš„è¡¨è¾¾èƒ½åŠ›ã€‚

### 1.2 ä¸ºä»€ä¹ˆéœ€è¦æ³›å‹
åœ¨Go 1.18ä¹‹å‰ï¼Œè¦å®ç°é€šç”¨ç®—æ³•ï¼Œé€šå¸¸æœ‰ä»¥ä¸‹å‡ ç§æ–¹å¼ï¼š
- ä¸ºæ¯ç§ç±»å‹ç¼–å†™é‡å¤ä»£ç 
- ä½¿ç”¨`interface{}`ç±»å‹ï¼ˆç°åœ¨æ˜¯`any`ï¼‰å’Œç±»å‹æ–­è¨€
- ä½¿ç”¨åå°„

è¿™äº›æ–¹æ³•å„æœ‰ç¼ºç‚¹ï¼šä»£ç é‡å¤ã€ä¸§å¤±ç±»å‹å®‰å…¨æˆ–æ€§èƒ½æŸå¤±ã€‚æ³›å‹æä¾›äº†ä¸€ç§ç¼–è¯‘æ—¶å®‰å…¨ä¸”é«˜æ•ˆçš„æ–¹å¼æ¥ç¼–å†™é€šç”¨ä»£ç ã€‚

### 1.3 æ³›å‹çš„ä¼˜ç¼ºç‚¹

**ä¼˜ç‚¹**ï¼š
- ä»£ç å¤ç”¨ï¼Œå‡å°‘é‡å¤ä»£ç 
- ç±»å‹å®‰å…¨ï¼Œç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥
- å¯è¯»æ€§ï¼Œä»£ç æ„å›¾æ›´æ¸…æ™°
- æ€§èƒ½æ¯”åå°„æ›´å¥½

**ç¼ºç‚¹**ï¼š
- å¢åŠ äº†è¯­æ³•å¤æ‚æ€§
- é”™è¯¯ä¿¡æ¯å¯èƒ½æ›´å¤æ‚
- åœ¨æŸäº›æƒ…å†µä¸‹å¯èƒ½å¯¼è‡´ä»£ç è†¨èƒ€

```go
package main

import "fmt"

// åœ¨æ³›å‹ä¹‹å‰ï¼šéœ€è¦é’ˆå¯¹ä¸åŒç±»å‹å†™å¤šä¸ªå‡½æ•°
func SumInts(numbers []int) int {
    var total int
    for _, n := range numbers {
        total += n
    }
    return total
}

func SumFloats(numbers []float64) float64 {
    var total float64
    for _, n := range numbers {
        total += n
    }
    return total
}

// ä½¿ç”¨æ³›å‹ï¼šä¸€ä¸ªå‡½æ•°å¤„ç†å¤šç§ç±»å‹
func Sum[T int | float64](numbers []T) T {
    var total T
    for _, n := range numbers {
        total += n
    }
    return total
}

func main() {
    // ä½¿ç”¨ç‰¹å®šç±»å‹å‡½æ•°
    fmt.Println("SumInts:", SumInts([]int{1, 2, 3}))
    fmt.Println("SumFloats:", SumFloats([]float64{1.1, 2.2, 3.3}))
    
    // ä½¿ç”¨æ³›å‹å‡½æ•°
    fmt.Println("Sum[int]:", Sum[int]([]int{1, 2, 3}))
    fmt.Println("Sum[float64]:", Sum[float64]([]float64{1.1, 2.2, 3.3}))
    
    // ä½¿ç”¨ç±»å‹æ¨æ–­
    fmt.Println("Sum:", Sum([]int{1, 2, 3}))
    fmt.Println("Sum:", Sum([]float64{1.1, 2.2, 3.3}))
}
```

---

## 2. ç±»å‹å‚æ•°å’Œçº¦æŸ

### 2.1 ç±»å‹å‚æ•°è¯­æ³•
ç±»å‹å‚æ•°ä½¿ç”¨æ–¹æ‹¬å·å®šä¹‰ï¼Œæ”¾åœ¨å‡½æ•°åæˆ–ç±»å‹åä¹‹åï¼š

```go
func Name[TypeParameter Constraint](params) ReturnType {
    // å‡½æ•°ä½“
}

type Name[TypeParameter Constraint] struct {
    // å­—æ®µ
}
```

### 2.2 çº¦æŸç±»å‹

#### 2.2.1 åŸºç¡€çº¦æŸ
çº¦æŸå®šä¹‰äº†ç±»å‹å‚æ•°å¯ä»¥æ¥å—å“ªäº›ç±»å‹ã€‚Goæä¾›äº†å‡ ç§åŸºæœ¬æ–¹å¼æ¥å®šä¹‰çº¦æŸï¼š

```go
package main

import "fmt"

// 1. ä½¿ç”¨ç±»å‹é›†åˆçº¦æŸ
func MaxBasic[T int | float64 | string](a, b T) T {
    if a > b {
        return a
    }
    return b
}

// 2. ä½¿ç”¨æ¥å£ä½œä¸ºçº¦æŸ
type Ordered interface {
    int | int8 | int16 | int32 | int64 |
        uint | uint8 | uint16 | uint32 | uint64 | uintptr |
        float32 | float64 |
        string
}

func MaxOrdered[T Ordered](a, b T) T {
    if a > b {
        return a
    }
    return b
}

// 3. ä½¿ç”¨æ–¹æ³•çº¦æŸ
type Comparable[T any] interface {
    CompareTo(T) int
}

func MaxComparable[T Comparable[T]](a, b T) T {
    if a.CompareTo(b) > 0 {
        return a
    }
    return b
}

// å®ç°Comparableæ¥å£çš„ç±»å‹
type Person struct {
    Age int
}

func (p Person) CompareTo(other Person) int {
    return p.Age - other.Age
}

func main() {
    fmt.Println("MaxBasic:", MaxBasic(10, 20))
    fmt.Println("MaxBasic:", MaxBasic(3.14, 2.71))
    fmt.Println("MaxBasic:", MaxBasic("Go", "Python"))
    
    fmt.Println("MaxOrdered:", MaxOrdered(10, 20))
    fmt.Println("MaxOrdered:", MaxOrdered(3.14, 2.71))
    fmt.Println("MaxOrdered:", MaxOrdered("Go", "Python"))
    
    p1 := Person{Age: 30}
    p2 := Person{Age: 25}
    fmt.Println("MaxComparable:", MaxComparable(p1, p2).Age)
}
```

#### 2.2.2 `constraints`åŒ…
Goå®˜æ–¹çš„`golang.org/x/exp/constraints`åŒ…æä¾›äº†ä¸€äº›å¸¸ç”¨çš„çº¦æŸç±»å‹ï¼š

```go
package main

import (
    "fmt"
    "golang.org/x/exp/constraints"
)

// ä½¿ç”¨constraintsåŒ…ä¸­çš„çº¦æŸ
func Max[T constraints.Ordered](a, b T) T {
    if a > b {
        return a
    }
    return b
}

func main() {
    fmt.Println("Max:", Max(10, 20))
    fmt.Println("Max:", Max(3.14, 2.71))
    fmt.Println("Max:", Max("Go", "Python"))
}
```

### 2.3 å¤åˆçº¦æŸ
çº¦æŸå¯ä»¥ç»„åˆä½¿ç”¨ï¼Œå½¢æˆæ›´å¤æ‚çš„çº¦æŸï¼š

```go
package main

import "fmt"

// å®šä¹‰ä¸€ä¸ªè¦æ±‚ç±»å‹åŒæ—¶å…·æœ‰åŠ æ³•å’Œä¹˜æ³•æ“ä½œçš„çº¦æŸ
type Number interface {
    int | int64 | float64
}

// åŠ æ³•æ“ä½œ
func Add[T Number](a, b T) T {
    return a + b
}

// ä¹˜æ³•æ“ä½œ
func Multiply[T Number](a, b T) T {
    return a * b
}

// å¤åˆæ“ä½œ
func AddAndMultiply[T Number](a, b, c T) T {
    return Add(a, b) * c
}

func main() {
    fmt.Println("AddAndMultiply:", AddAndMultiply(2, 3, 4))          // (2+3)*4 = 20
    fmt.Println("AddAndMultiply:", AddAndMultiply(2.5, 3.5, 2.0))    // (2.5+3.5)*2.0 = 12.0
}
```

### 2.4 è‡ªå®šä¹‰çº¦æŸ
å¯ä»¥ä½¿ç”¨æ¥å£å®šä¹‰è‡ªå®šä¹‰çº¦æŸï¼Œç»„åˆæ–¹æ³•å’Œç±»å‹é›†ï¼š

```go
package main

import "fmt"

// å®šä¹‰ä¸€ä¸ªå¤æ•°ç±»å‹
type Complex128 complex128

// è‡ªå®šä¹‰çº¦æŸï¼šè¦æ±‚ç±»å‹æ”¯æŒåŠ æ³•æ“ä½œå’ŒStringæ–¹æ³•
type Addable[T any] interface {
    ~int | ~int64 | ~float64 | ~Complex128
    String() string
}

// æ‰©å±•intç±»å‹
type MyInt int

func (i MyInt) String() string {
    return fmt.Sprintf("MyInt(%d)", i)
}

// æ‰©å±•float64ç±»å‹
type MyFloat float64

func (f MyFloat) String() string {
    return fmt.Sprintf("MyFloat(%f)", f)
}

// ä½¿ç”¨è‡ªå®šä¹‰çº¦æŸçš„å‡½æ•°
func AddAndPrint[T Addable[T]](a, b T) T {
    result := a + b
    fmt.Println(result.String())
    return result
}

func main() {
    a := MyInt(10)
    b := MyInt(20)
    AddAndPrint(a, b)
    
    c := MyFloat(3.14)
    d := MyFloat(2.71)
    AddAndPrint(c, d)
}
```

### 2.5 æ³¢æµªè¿ç®—ç¬¦(~)
æ³¢æµªè¿ç®—ç¬¦å…è®¸çº¦æŸåŒ…å«æ‰€æœ‰ä»¥ç‰¹å®šç±»å‹ä¸ºåº•å±‚ç±»å‹çš„ç±»å‹ï¼š

```go
package main

import "fmt"

// å®šä¹‰ä¸€ä¸ªåŸºäºintçš„ç±»å‹
type MyInt int

// ä¸ä½¿ç”¨~ï¼šåªæ¥å—ç²¾ç¡®çš„intç±»å‹
func AddExact[T int](a, b T) T {
    return a + b
}

// ä½¿ç”¨~ï¼šæ¥å—ä»»ä½•åº•å±‚ç±»å‹ä¸ºintçš„ç±»å‹
func AddWide[T ~int](a, b T) T {
    return a + b
}

func main() {
    a := 10
    b := 20
    c := MyInt(30)
    d := MyInt(40)
    
    fmt.Println("AddExact:", AddExact(a, b))
    // ä¸‹é¢è¿™è¡Œä¼šç¼–è¯‘é”™è¯¯ï¼š
    // fmt.Println(AddExact(c, d))
    
    fmt.Println("AddWide:", AddWide(a, b))
    fmt.Println("AddWide:", AddWide(c, d))
}
```

---

## 3. æ³›å‹å‡½æ•°å’Œæ–¹æ³•

### 3.1 æ³›å‹å‡½æ•°å®šä¹‰å’Œä½¿ç”¨

```go
package main

import "fmt"

// å•ç±»å‹å‚æ•°
func First[T any](slice []T) T {
    return slice[0]
}

// å¤šç±»å‹å‚æ•°
func Map[T, U any](slice []T, f func(T) U) []U {
    result := make([]U, len(slice))
    for i, v := range slice {
        result[i] = f(v)
    }
    return result
}

// å¸¦çº¦æŸçš„ç±»å‹å‚æ•°
func Sum[T int | float64](slice []T) T {
    var sum T
    for _, v := range slice {
        sum += v
    }
    return sum
}

func main() {
    // ä½¿ç”¨å•ç±»å‹å‚æ•°å‡½æ•°
    ints := []int{1, 2, 3}
    fmt.Println("First int:", First(ints))
    
    strings := []string{"Go", "Python", "Java"}
    fmt.Println("First string:", First(strings))
    
    // ä½¿ç”¨å¤šç±»å‹å‚æ•°å‡½æ•°
    doubled := Map(ints, func(x int) int { return x * 2 })
    fmt.Println("Doubled:", doubled)
    
    uppercased := Map(strings, func(s string) string { 
        return fmt.Sprintf("<%s>", s) 
    })
    fmt.Println("Formatted:", uppercased)
    
    // ä½¿ç”¨å¸¦çº¦æŸçš„å‡½æ•°
    fmt.Println("Sum ints:", Sum(ints))
    floats := []float64{1.1, 2.2, 3.3}
    fmt.Println("Sum floats:", Sum(floats))
}
```

### 3.2 ç±»å‹æ¨æ–­
Goç¼–è¯‘å™¨å¯ä»¥æ ¹æ®å‡½æ•°å‚æ•°æ¨æ–­ç±»å‹å‚æ•°ï¼Œåœ¨è®¸å¤šæƒ…å†µä¸‹ä¸éœ€è¦æ˜¾å¼æŒ‡å®šç±»å‹ï¼š

```go
package main

import "fmt"

func Identity[T any](value T) T {
    return value
}

func main() {
    // æ˜¾å¼æŒ‡å®šç±»å‹å‚æ•°
    i1 := Identity[int](42)
    s1 := Identity[string]("Hello")
    
    // ä½¿ç”¨ç±»å‹æ¨æ–­
    i2 := Identity(42)        // ç±»å‹è¢«æ¨æ–­ä¸ºint
    s2 := Identity("Hello")   // ç±»å‹è¢«æ¨æ–­ä¸ºstring
    
    fmt.Printf("i1: %v, i2: %v\n", i1, i2)
    fmt.Printf("s1: %v, s2: %v\n", s1, s2)
}
```

### 3.3 æ³›å‹æ–¹æ³•
æ³›å‹ç±»å‹å¯ä»¥æœ‰æ–¹æ³•ï¼Œä½†æ–¹æ³•ä¸èƒ½å®šä¹‰è‡ªå·±çš„ç±»å‹å‚æ•°ï¼š

```go
package main

import "fmt"

// æ³›å‹æ ˆ
type Stack[T any] struct {
    items []T
}

// æ³›å‹æ–¹æ³•
func (s *Stack[T]) Push(item T) {
    s.items = append(s.items, item)
}

func (s *Stack[T]) Pop() (T, bool) {
    if len(s.items) == 0 {
        var zero T
        return zero, false
    }
    
    item := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1]
    return item, true
}

func (s *Stack[T]) Size() int {
    return len(s.items)
}

func (s *Stack[T]) IsEmpty() bool {
    return len(s.items) == 0
}

// ç±»å‹çº¦æŸçš„æ³›å‹æ–¹æ³•
func (s *Stack[T]) Contains(item T) bool where T comparable {
    for _, v := range s.items {
        if v == item {
            return true
        }
    }
    return false
}

func main() {
    // åˆ›å»ºintç±»å‹çš„æ ˆ
    intStack := Stack[int]{}
    intStack.Push(1)
    intStack.Push(2)
    intStack.Push(3)
    
    fmt.Println("Size:", intStack.Size())
    fmt.Println("Contains 2:", intStack.Contains(2))
    
    for !intStack.IsEmpty() {
        item, _ := intStack.Pop()
        fmt.Println("Popped:", item)
    }
    
    // åˆ›å»ºstringç±»å‹çš„æ ˆ
    stringStack := Stack[string]{}
    stringStack.Push("Go")
    stringStack.Push("Java")
    stringStack.Push("Python")
    
    fmt.Println("Size:", stringStack.Size())
    fmt.Println("Contains 'Java':", stringStack.Contains("Java"))
    
    for !stringStack.IsEmpty() {
        item, _ := stringStack.Pop()
        fmt.Println("Popped:", item)
    }
}
```

### 3.4 æ³›å‹æ¥æ”¶è€…
æ³›å‹ç±»å‹çš„æ–¹æ³•æ¥æ”¶è€…è¯­æ³•ç‰¹æ®Šï¼Œæ–¹æ³•å®šä¹‰å¿…é¡»åŒ…å«æ‰€æœ‰çš„ç±»å‹å‚æ•°ï¼š

```go
package main

import "fmt"

// æ³›å‹é”®å€¼å¯¹
type Pair[K, V any] struct {
    Key   K
    Value V
}

// æ³›å‹æ¥æ”¶è€…æ–¹æ³•
func (p Pair[K, V]) String() string {
    return fmt.Sprintf("(%v: %v)", p.Key, p.Value)
}

// åˆ›å»ºæ–°çš„é”®å€¼å¯¹çš„å‡½æ•°
func NewPair[K, V any](key K, value V) Pair[K, V] {
    return Pair[K, V]{
        Key:   key,
        Value: value,
    }
}

func main() {
    // åˆ›å»ºå„ç§ç±»å‹çš„é”®å€¼å¯¹
    p1 := NewPair(1, "One")
    p2 := NewPair("name", "Alice")
    p3 := NewPair(3.14, true)
    
    fmt.Println(p1.String())
    fmt.Println(p2.String())
    fmt.Println(p3.String())
}
```

---

## 4. æ³›å‹æ•°æ®ç»“æ„

### 4.1 æ³›å‹åˆ‡ç‰‡å’Œæ˜ å°„

```go
package main

import "fmt"

// æ³›å‹å‡½æ•°: è¿‡æ»¤åˆ‡ç‰‡
func Filter[T any](slice []T, predicate func(T) bool) []T {
    var result []T
    for _, v := range slice {
        if predicate(v) {
            result = append(result, v)
        }
    }
    return result
}

// æ³›å‹å‡½æ•°: è½¬æ¢æ˜ å°„
func MapValues[K comparable, V, R any](m map[K]V, transform func(V) R) map[K]R {
    result := make(map[K]R, len(m))
    for k, v := range m {
        result[k] = transform(v)
    }
    return result
}

func main() {
    // è¿‡æ»¤åˆ‡ç‰‡
    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    evenNumbers := Filter(numbers, func(n int) bool {
        return n%2 == 0
    })
    fmt.Println("Even numbers:", evenNumbers)
    
    names := []string{"Alice", "Bob", "Charlie", "Dave", "Eve"}
    longNames := Filter(names, func(s string) bool {
        return len(s) > 3
    })
    fmt.Println("Long names:", longNames)
    
    // è½¬æ¢æ˜ å°„
    ages := map[string]int{
        "Alice":   25,
        "Bob":     30,
        "Charlie": 35,
    }
    
    ageDescriptions := MapValues(ages, func(age int) string {
        if age < 30 {
            return "young"
        }
        return "mature"
    })
    
    fmt.Println("Age descriptions:", ageDescriptions)
}
```

### 4.2 æ³›å‹é“¾è¡¨å®ç°

```go
package main

import "fmt"

// é“¾è¡¨èŠ‚ç‚¹
type Node[T any] struct {
    Value T
    Next  *Node[T]
}

// é“¾è¡¨
type LinkedList[T any] struct {
    head *Node[T]
    tail *Node[T]
    size int
}

// æ·»åŠ å…ƒç´ åˆ°é“¾è¡¨æœ«å°¾
func (l *LinkedList[T]) Append(value T) {
    node := &Node[T]{Value: value}
    
    if l.head == nil {
        l.head = node
        l.tail = node
    } else {
        l.tail.Next = node
        l.tail = node
    }
    
    l.size++
}

// åœ¨é“¾è¡¨å¤´éƒ¨æ·»åŠ å…ƒç´ 
func (l *LinkedList[T]) Prepend(value T) {
    node := &Node[T]{Value: value, Next: l.head}
    
    if l.head == nil {
        l.tail = node
    }
    
    l.head = node
    l.size++
}

// åˆ é™¤é“¾è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªåŒ¹é…å…ƒç´ 
func (l *LinkedList[T]) Remove(value T) bool where T comparable {
    if l.head == nil {
        return false
    }
    
    // ç‰¹æ®Šæƒ…å†µ: å¤´èŠ‚ç‚¹åŒ¹é…
    if l.head.Value == value {
        l.head = l.head.Next
        l.size--
        
        if l.head == nil {
            l.tail = nil
        }
        
        return true
    }
    
    // ä¸€èˆ¬æƒ…å†µ: åœ¨é“¾è¡¨ä¸­æŸ¥æ‰¾
    current := l.head
    for current.Next != nil {
        if current.Next.Value == value {
            // åˆ é™¤åŒ¹é…èŠ‚ç‚¹
            if current.Next == l.tail {
                l.tail = current
            }
            
            current.Next = current.Next.Next
            l.size--
            return true
        }
        current = current.Next
    }
    
    return false
}

// è·å–é“¾è¡¨å¤§å°
func (l *LinkedList[T]) Size() int {
    return l.size
}

// åˆ¤æ–­é“¾è¡¨æ˜¯å¦ä¸ºç©º
func (l *LinkedList[T]) IsEmpty() bool {
    return l.size == 0
}

// éå†é“¾è¡¨
func (l *LinkedList[T]) ForEach(f func(T)) {
    current := l.head
    for current != nil {
        f(current.Value)
        current = current.Next
    }
}

// è½¬æ¢ä¸ºåˆ‡ç‰‡
func (l *LinkedList[T]) ToSlice() []T {
    result := make([]T, 0, l.size)
    l.ForEach(func(value T) {
        result = append(result, value)
    })
    return result
}

func main() {
    // åˆ›å»ºæ•´æ•°é“¾è¡¨
    intList := LinkedList[int]{}
    intList.Append(1)
    intList.Append(2)
    intList.Append(3)
    intList.Prepend(0)
    
    fmt.Println("Int list size:", intList.Size())
    fmt.Println("Int list elements:", intList.ToSlice())
    
    intList.Remove(2)
    fmt.Println("After removing 2:", intList.ToSlice())
    
    // åˆ›å»ºå­—ç¬¦ä¸²é“¾è¡¨
    stringList := LinkedList[string]{}
    stringList.Append("Go")
    stringList.Append("Java")
    stringList.Append("Python")
    stringList.Prepend("Rust")
    
    fmt.Println("String list size:", stringList.Size())
    fmt.Println("String list elements:", stringList.ToSlice())
    
    stringList.Remove("Java")
    fmt.Println("After removing 'Java':", stringList.ToSlice())
}
```

### 4.3 æ³›å‹äºŒå‰æ ‘å®ç°

```go
package main

import "fmt"

// äºŒå‰æ ‘èŠ‚ç‚¹
type TreeNode[T any] struct {
    Value T
    Left  *TreeNode[T]
    Right *TreeNode[T]
}

// äºŒå‰æœç´¢æ ‘
type BinarySearchTree[T constraints.Ordered] struct {
    root *TreeNode[T]
    size int
}

// æ’å…¥å€¼åˆ°äºŒå‰æœç´¢æ ‘
func (t *BinarySearchTree[T]) Insert(value T) {
    t.root = t.insertNode(t.root, value)
    t.size++
}

// å†…éƒ¨é€’å½’æ’å…¥æ–¹æ³•
func (t *BinarySearchTree[T]) insertNode(node *TreeNode[T], value T) *TreeNode[T] {
    if node == nil {
        return &TreeNode[T]{Value: value}
    }
    
    if value < node.Value {
        node.Left = t.insertNode(node.Left, value)
    } else if value > node.Value {
        node.Right = t.insertNode(node.Right, value)
    }
    
    return node
}

// æœç´¢å€¼
func (t *BinarySearchTree[T]) Contains(value T) bool {
    return t.containsNode(t.root, value)
}

// å†…éƒ¨é€’å½’æœç´¢æ–¹æ³•
func (t *BinarySearchTree[T]) containsNode(node *TreeNode[T], value T) bool {
    if node == nil {
        return false
    }
    
    if value == node.Value {
        return true
    }
    
    if value < node.Value {
        return t.containsNode(node.Left, value)
    }
    
    return t.containsNode(node.Right, value)
}

// ä¸­åºéå†ï¼ˆç”Ÿæˆæœ‰åºåˆ‡ç‰‡ï¼‰
func (t *BinarySearchTree[T]) InOrderTraversal() []T {
    result := make([]T, 0, t.size)
    t.inOrder(t.root, &result)
    return result
}

// å†…éƒ¨é€’å½’ä¸­åºéå†æ–¹æ³•
func (t *BinarySearchTree[T]) inOrder(node *TreeNode[T], result *[]T) {
    if node != nil {
        t.inOrder(node.Left, result)
        *result = append(*result, node.Value)
        t.inOrder(node.Right, result)
    }
}

// è·å–æ ‘çš„å¤§å°
func (t *BinarySearchTree[T]) Size() int {
    return t.size
}

func main() {
    // åˆ›å»ºæ•´æ•°äºŒå‰æœç´¢æ ‘
    intTree := BinarySearchTree[int]{}
    intTree.Insert(5)
    intTree.Insert(3)
    intTree.Insert(7)
    intTree.Insert(2)
    intTree.Insert(4)
    
    fmt.Println("Size:", intTree.Size())
    fmt.Println("Contains 4:", intTree.Contains(4))
    fmt.Println("Contains 6:", intTree.Contains(6))
    fmt.Println("In-order traversal:", intTree.InOrderTraversal())
    
    // åˆ›å»ºå­—ç¬¦ä¸²äºŒå‰æœç´¢æ ‘
    stringTree := BinarySearchTree[string]{}
    stringTree.Insert("banana")
    stringTree.Insert("apple")
    stringTree.Insert("cherry")
    stringTree.Insert("date")
    
    fmt.Println("Size:", stringTree.Size())
    fmt.Println("Contains 'cherry':", stringTree.Contains("cherry"))
    fmt.Println("Contains 'grape':", stringTree.Contains("grape"))
    fmt.Println("In-order traversal:", stringTree.InOrderTraversal())
}
```

---

## 5. é«˜çº§æ³›å‹ç”¨æ³•

### 5.1 åµŒå¥—æ³›å‹

```go
package main

import "fmt"

// åµŒå¥—æ³›å‹ï¼šResultç±»å‹å¯ä»¥åŒ…å«ä»»ä½•ç±»å‹çš„å€¼å’Œä»»ä½•ç±»å‹çš„é”™è¯¯
type Result[T any, E any] struct {
    Value T
    Error E
}

// åˆ›å»ºæˆåŠŸç»“æœ
func Success[T any, E any](value T) Result[T, E] {
    var zero E
    return Result[T, E]{
        Value: value,
        Error: zero,
    }
}

// åˆ›å»ºé”™è¯¯ç»“æœ
func Failure[T any, E any](err E) Result[T, E] {
    var zero T
    return Result[T, E]{
        Value: zero,
        Error: err,
    }
}

// æ˜ å°„å‡½æ•°ï¼Œè½¬æ¢Resultä¸­çš„å€¼
func Map[T, U, E any](r Result[T, E], f func(T) U) Result[U, E] {
    if r.Error != *new(E) { // æ£€æŸ¥æ˜¯å¦æœ‰é”™è¯¯
        return Failure[U, E](r.Error)
    }
    return Success[U, E](f(r.Value))
}

// å…·ä½“é”™è¯¯ç±»å‹
type MyError struct {
    Code    int
    Message string
}

func (e MyError) Error() string {
    return fmt.Sprintf("Error %d: %s", e.Code, e.Message)
}

func main() {
    // åˆ›å»ºæˆåŠŸçš„ç»“æœ
    successResult := Success[int, MyError](42)
    fmt.Printf("Success: Value=%v, Error=%v\n", successResult.Value, successResult.Error)
    
    // åˆ›å»ºå¤±è´¥çš„ç»“æœ
    failureResult := Failure[int, MyError](MyError{Code: 404, Message: "Not Found"})
    fmt.Printf("Failure: Value=%v, Error=%v\n", failureResult.Value, failureResult.Error)
    
    // ä½¿ç”¨Mapè½¬æ¢ç»“æœ
    doubledSuccess := Map(successResult, func(v int) string {
        return fmt.Sprintf("Value: %d", v*2)
    })
    fmt.Printf("Mapped Success: Value=%v, Error=%v\n", doubledSuccess.Value, doubledSuccess.Error)
    
    doubledFailure := Map(failureResult, func(v int) string {
        return fmt.Sprintf("Value: %d", v*2)
    })
    fmt.Printf("Mapped Failure: Value=%v, Error=%v\n", doubledFailure.Value, doubledFailure.Error)
}
```

### 5.2 æ³›å‹é€’å½’

```go
package main

import "fmt"

// æ³›å‹é€’å½’å‡½æ•°ï¼šåˆå¹¶æ’åº
func MergeSort[T constraints.Ordered](slice []T) []T {
    if len(slice) <= 1 {
        return slice
    }
    
    // åˆ†å‰²
    middle := len(slice) / 2
    left := MergeSort(slice[:middle])
    right := MergeSort(slice[middle:])
    
    // åˆå¹¶
    return merge(left, right)
}

// åˆå¹¶ä¸¤ä¸ªå·²æ’åºçš„åˆ‡ç‰‡
func merge[T constraints.Ordered](left, right []T) []T {
    result := make([]T, 0, len(left)+len(right))
    leftIndex, rightIndex := 0, 0
    
    // æ¯”è¾ƒå¹¶åˆå¹¶
    for leftIndex < len(left) && rightIndex < len(right) {
        if left[leftIndex] <= right[rightIndex] {
            result = append(result, left[leftIndex])
            leftIndex++
        } else {
            result = append(result, right[rightIndex])
            rightIndex++
        }
    }
    
    // æ·»åŠ å‰©ä½™å…ƒç´ 
    result = append(result, left[leftIndex:]...)
    result = append(result, right[rightIndex:]...)
    
    return result
}

func main() {
    // æ•´æ•°æ’åº
    ints := []int{38, 27, 43, 3, 9, 82, 10}
    sortedInts := MergeSort(ints)
    fmt.Println("Sorted ints:", sortedInts)
    
    // å­—ç¬¦ä¸²æ’åº
    strings := []string{"banana", "apple", "pear", "orange", "kiwi"}
    sortedStrings := MergeSort(strings)
    fmt.Println("Sorted strings:", sortedStrings)
    
    // æµ®ç‚¹æ•°æ’åº
    floats := []float64{3.14, 1.41, 2.71, 1.73, 2.0}
    sortedFloats := MergeSort(floats)
    fmt.Println("Sorted floats:", sortedFloats)
}
```

### 5.3 æ³›å‹å¹¶å‘

```go
package main

import (
    "fmt"
    "sync"
)

// å¹¶å‘æ˜ å°„å‡½æ•°ï¼šå¹¶è¡Œå¤„ç†åˆ‡ç‰‡ä¸­çš„æ¯ä¸ªå…ƒç´ 
func ParallelMap[T, U any](slice []T, f func(T) U) []U {
    result := make([]U, len(slice))
    var wg sync.WaitGroup
    
    for i, v := range slice {
        wg.Add(1)
        go func(index int, value T) {
            defer wg.Done()
            result[index] = f(value)
        }(i, v)
    }
    
    wg.Wait()
    return result
}

// å¹¶å‘reduceå‡½æ•°ï¼šå¹¶è¡Œè®¡ç®—éƒ¨åˆ†ç»“æœï¼Œç„¶ååˆå¹¶
func ParallelReduce[T, U any](slice []T, initialValue U, f func(U, T) U, combiner func(U, U) U) U {
    if len(slice) == 0 {
        return initialValue
    }
    
    // ç¡®å®šå·¥ä½œçº¿ç¨‹æ•°é‡
    numWorkers := min(len(slice), 4)
    chunkSize := (len(slice) + numWorkers - 1) / numWorkers
    
    // ä¸ºæ¯ä¸ªå·¥ä½œçº¿ç¨‹åˆ›å»ºä¸€ä¸ªé€šé“
    resultChan := make(chan U, numWorkers)
    var wg sync.WaitGroup
    
    // å¯åŠ¨å·¥ä½œçº¿ç¨‹
    for i := 0; i < numWorkers; i++ {
        wg.Add(1)
        go func(workerID int) {
            defer wg.Done()
            
            // è®¡ç®—è¿™ä¸ªå·¥ä½œçº¿ç¨‹å¤„ç†çš„åˆ‡ç‰‡èŒƒå›´
            start := workerID * chunkSize
            end := min(start+chunkSize, len(slice))
            
            // å¦‚æœèŒƒå›´æ— æ•ˆï¼Œç›´æ¥è¿”å›
            if start >= len(slice) {
                resultChan <- initialValue
                return
            }
            
            // å¤„ç†è¿™ä¸ªèŒƒå›´çš„å…ƒç´ 
            localResult := initialValue
            for j := start; j < end; j++ {
                localResult = f(localResult, slice[j])
            }
            
            resultChan <- localResult
        }(i)
    }
    
    // ç­‰å¾…æ‰€æœ‰å·¥ä½œçº¿ç¨‹å®Œæˆ
    go func() {
        wg.Wait()
        close(resultChan)
    }()
    
    // åˆå¹¶æ‰€æœ‰å·¥ä½œçº¿ç¨‹çš„ç»“æœ
    result := initialValue
    for partialResult := range resultChan {
        result = combiner(result, partialResult)
    }
    
    return result
}

// è¾…åŠ©å‡½æ•°ï¼šmin
func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func main() {
    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    
    // å¹¶è¡Œè®¡ç®—æ¯ä¸ªæ•°å­—çš„å¹³æ–¹
    squares := ParallelMap(numbers, func(n int) int {
        return n * n
    })
    fmt.Println("Parallel squares:", squares)
    
    // å¹¶è¡Œè®¡ç®—æ•°å­—ä¹‹å’Œ
    sum := ParallelReduce(
        numbers,
        0,
        func(acc, n int) int { return acc + n },
        func(a, b int) int { return a + b },
    )
    fmt.Println("Parallel sum:", sum)
    
    // å¹¶è¡Œè®¡ç®—å­—ç¬¦ä¸²è¿æ¥
    words := []string{"Hello", "World", "Go", "Generics", "Are", "Awesome"}
    concatenated := ParallelReduce(
        words,
        "",
        func(acc, s string) string { return acc + s + " " },
        func(a, b string) string { return a + b },
    )
    fmt.Println("Parallel concatenation:", concatenated)
}
```

---

## 6. æ³›å‹æ€§èƒ½è€ƒé‡

### 6.1 æ³›å‹ä¸æ¥å£çš„æ€§èƒ½æ¯”è¾ƒ

æ³›å‹é€šå¸¸æ¯”ä½¿ç”¨æ¥å£å’Œç±»å‹æ–­è¨€æœ‰æ›´å¥½çš„æ€§èƒ½ï¼Œå› ä¸ºå®ƒé¿å…äº†è¿è¡Œæ—¶çš„ç±»å‹æ£€æŸ¥å’Œè£…ç®±/æ‹†ç®±æ“ä½œï¼š

```go
package main

import (
    "fmt"
    "time"
)

// ä½¿ç”¨æ¥å£çš„å‡½æ•°
func SumInterface(numbers []interface{}) interface{} {
    var sum interface{}
    
    switch numbers[0].(type) {
    case int:
        total := 0
        for _, n := range numbers {
            total += n.(int)
        }
        sum = total
    case float64:
        total := 0.0
        for _, n := range numbers {
            total += n.(float64)
        }
        sum = total
    }
    
    return sum
}

// ä½¿ç”¨æ³›å‹çš„å‡½æ•°
func SumGeneric[T int | float64](numbers []T) T {
    var sum T
    for _, n := range numbers {
        sum += n
    }
    return sum
}

func main() {
    // å‡†å¤‡æµ‹è¯•æ•°æ®
    ints := make([]int, 10000000)
    interfaceInts := make([]interface{}, 10000000)
    
    for i := range ints {
        ints[i] = i
        interfaceInts[i] = i
    }
    
    // æµ‹è¯•æ¥å£ç‰ˆæœ¬
    start := time.Now()
    resultInterface := SumInterface(interfaceInts)
    interfaceTime := time.Since(start)
    
    // æµ‹è¯•æ³›å‹ç‰ˆæœ¬
    start = time.Now()
    resultGeneric := SumGeneric(ints)
    genericTime := time.Since(start)
    
    fmt.Printf("Interface version: %v in %v\n", resultInterface, interfaceTime)
    fmt.Printf("Generic version: %v in %v\n", resultGeneric, genericTime)
    fmt.Printf("Generic is %.2f times faster\n", float64(interfaceTime)/float64(genericTime))
}
```

### 6.2 ç±»å‹å‚æ•°çš„ä»£ç è†¨èƒ€

æ¯ä¸ªä¸åŒçš„ç±»å‹å®ä¾‹åŒ–éƒ½ä¼šç”Ÿæˆä¸åŒçš„ä»£ç ï¼Œå¯èƒ½å¯¼è‡´äºŒè¿›åˆ¶å¤§å°å¢åŠ ï¼š

```go
package main

import (
    "fmt"
    "unsafe"
)

// æ³›å‹å‡½æ•°ï¼Œå¤„ç†ä¸åŒç±»å‹
func Process[T any](value T) T {
    fmt.Printf("Processing value of type %T at address %p\n", 
               value, unsafe.Pointer(&value))
    return value
}

func main() {
    // ä¸ºä¸åŒç±»å‹å®ä¾‹åŒ–å‡½æ•°
    Process(42)           // intå®ä¾‹
    Process(3.14)         // float64å®ä¾‹
    Process("hello")      // stringå®ä¾‹
    Process([]int{1, 2})  // []intå®ä¾‹
    Process(map[string]int{"a": 1}) // mapå®ä¾‹
    
    // æ˜¾ç¤ºå‡½æ•°åœ°å€
    fmt.Printf("Process[int] address: %p\n", 
               unsafe.Pointer(&Process[int]))
    fmt.Printf("Process[float64] address: %p\n", 
               unsafe.Pointer(&Process[float64]))
    fmt.Printf("Process[string] address: %p\n", 
               unsafe.Pointer(&Process[string]))
}
```

### 6.3 æ€§èƒ½ä¼˜åŒ–æŠ€å·§

1. **å‡å°‘ç±»å‹å‚æ•°**ï¼šåªåœ¨å¿…è¦æ—¶ä½¿ç”¨ç±»å‹å‚æ•°
2. **ä½¿ç”¨å…·ä½“çº¦æŸ**ï¼šæ¯”anyæ›´å…·ä½“çš„çº¦æŸå¯ä»¥ç”Ÿæˆæ›´é«˜æ•ˆçš„ä»£ç 
3. **å…±äº«å®ç°**ï¼šæŸäº›æƒ…å†µä¸‹å¯ä»¥å…±äº«åº•å±‚å®ç°æ¥å‡å°‘ä»£ç è†¨èƒ€
4. **åŸºå‡†æµ‹è¯•**ï¼šæ€»æ˜¯é€šè¿‡åŸºå‡†æµ‹è¯•æ¥éªŒè¯æ€§èƒ½ä¼˜åŒ–

```go
package main

import (
    "fmt"
    "testing"
)

// ä½æ•ˆï¼šå¯¹æ¯ç§ç±»å‹éƒ½æœ‰ä¸åŒçš„å®ç°
func LowPerformanceEquals[T comparable](a, b T) bool {
    return a == b
}

// é«˜æ•ˆï¼šé€šè¿‡ç±»å‹æ–­è¨€å…±äº«å®ç°
func HighPerformanceMax[T constraints.Ordered](a, b T) T {
    if a > b {
        return a
    }
    return b
}

func BenchmarkGeneric(b *testing.B) {
    for i := 0; i < b.N; i++ {
        HighPerformanceMax(10, 20)
    }
}

func main() {
    // ä»£ç ç¤ºä¾‹...
    fmt.Println("Run with go test -bench=.")
}
```

---

## 7. æœ€ä½³å®è·µå’Œæ¨¡å¼

### 7.1 æ³›å‹è®¾è®¡åŸåˆ™

1. **ç±»å‹å‚æ•°åº”è¯¥æœ‰ç›®çš„**ï¼šä¸è¦ä»…ä»…ä¸ºäº†é€šç”¨è€Œä½¿ç”¨æ³›å‹
2. **çº¦æŸåº”è¯¥å°½å¯èƒ½å…·ä½“**ï¼šä¸è¦è¿‡åº¦ä½¿ç”¨`any`
3. **ä¿æŒç®€å•**ï¼šæ³›å‹ä»£ç åº”è¯¥æ˜“äºç†è§£å’Œç»´æŠ¤
4. **éµå¾ªGoçš„æƒ¯ä¾‹**ï¼šæ³›å‹ä¸åº”è¯¥è¿èƒŒGoçš„è®¾è®¡å“²å­¦

### 7.2 å¸¸è§è®¾è®¡æ¨¡å¼

#### 7.2.1 Optionæ¨¡å¼
ä½¿ç”¨æ³›å‹å®ç°çµæ´»çš„é€‰é¡¹æ¨¡å¼ï¼š

```go
package main

import "fmt"

// æ³›å‹é…ç½®ç»“æ„ä½“
type Config[T any] struct {
    data T
}

// é€‰é¡¹å‡½æ•°ç±»å‹
type Option[T any] func(*Config[T])

// åˆ›å»ºæ–°é…ç½®
func NewConfig[T any](opts ...Option[T]) *Config[T] {
    c := &Config[T]{}
    for _, opt := range opts {
        opt(c)
    }
    return c
}

// å…·ä½“é…ç½®ç±»å‹
type ServerConfig struct {
    Host    string
    Port    int
    Timeout int
    Debug   bool
}

// é€‰é¡¹å‡½æ•°
func WithHost[T ServerConfig](host string) Option[T] {
    return func(c *Config[T]) {
        data := c.data
        data.Host = host
        c.data = data
    }
}

func WithPort[T ServerConfig](port int) Option[T] {
    return func(c *Config[T]) {
        data := c.data
        data.Port = port
        c.data = data
    }
}

func WithTimeout[T ServerConfig](timeout int) Option[T] {
    return func(c *Config[T]) {
        data := c.data
        data.Timeout = timeout
        c.data = data
    }
}

func WithDebug[T ServerConfig](debug bool) Option[T] {
    return func(c *Config[T]) {
        data := c.data
        data.Debug = debug
        c.data = data
    }
}

func main() {
    // ä½¿ç”¨é€‰é¡¹æ¨¡å¼åˆ›å»ºé…ç½®
    config := NewConfig[ServerConfig](
        WithHost[ServerConfig]("localhost"),
        WithPort[ServerConfig](8080),
        WithTimeout[ServerConfig](30),
        WithDebug[ServerConfig](true),
    )
    
    fmt.Printf("Server config: %+v\n", config.data)
}
```

#### 7.2.2 Repositoryæ¨¡å¼
ä½¿ç”¨æ³›å‹å®ç°æ•°æ®ä»“åº“æ¨¡å¼ï¼š

```go
package main

import (
    "errors"
    "fmt"
    "sync"
)

// å®ä½“æ¥å£
type Entity interface {
    GetID() string
}

// ç”¨æˆ·å®ä½“
type User struct {
    ID   string
    Name string
    Age  int
}

func (u User) GetID() string {
    return u.ID
}

// äº§å“å®ä½“
type Product struct {
    ID    string
    Name  string
    Price float64
}

func (p Product) GetID() string {
    return p.ID
}

// é€šç”¨ä»“åº“æ¥å£
type Repository[T Entity] interface {
    FindByID(id string) (T, error)
    FindAll() []T
    Save(entity T) error
    Delete(id string) error
}

// å†…å­˜ä»“åº“å®ç°
type InMemoryRepository[T Entity] struct {
    entities map[string]T
    mutex    sync.RWMutex
}

// åˆ›å»ºæ–°çš„å†…å­˜ä»“åº“
func NewInMemoryRepository[T Entity]() *InMemoryRepository[T] {
    return &InMemoryRepository[T]{
        entities: make(map[string]T),
    }
}

// æ ¹æ®IDæŸ¥æ‰¾å®ä½“
func (r *InMemoryRepository[T]) FindByID(id string) (T, error) {
    r.mutex.RLock()
    defer r.mutex.RUnlock()
    
    entity, exists := r.entities[id]
    if !exists {
        var zero T
        return zero, errors.New("entity not found")
    }
    
    return entity, nil
}

// æŸ¥æ‰¾æ‰€æœ‰å®ä½“
func (r *InMemoryRepository[T]) FindAll() []T {
    r.mutex.RLock()
    defer r.mutex.RUnlock()
    
    results := make([]T, 0, len(r.entities))
    for _, entity := range r.entities {
        results = append(results, entity)
    }
    
    return results
}

// ä¿å­˜å®ä½“
func (r *InMemoryRepository[T]) Save(entity T) error {
    r.mutex.Lock()
    defer r.mutex.Unlock()
    
    r.entities[entity.GetID()] = entity
    return nil
}

// åˆ é™¤å®ä½“
func (r *InMemoryRepository[T]) Delete(id string) error {
    r.mutex.Lock()
    defer r.mutex.Unlock()
    
    if _, exists := r.entities[id]; !exists {
        return errors.New("entity not found")
    }
    
    delete(r.entities, id)
    return nil
}

func main() {
    // åˆ›å»ºç”¨æˆ·ä»“åº“
    userRepo := NewInMemoryRepository[User]()
    
    // æ·»åŠ ç”¨æˆ·
    userRepo.Save(User{ID: "1", Name: "Alice", Age: 30})
    userRepo.Save(User{ID: "2", Name: "Bob", Age: 25})
    
    // æŸ¥æ‰¾ç”¨æˆ·
    user, err := userRepo.FindByID("1")
    if err != nil {
        fmt.Printf("Error: %v\n", err)
    } else {
        fmt.Printf("Found user: %+v\n", user)
    }
    
    // åˆ›å»ºäº§å“ä»“åº“
    productRepo := NewInMemoryRepository[Product]()
    
    // æ·»åŠ äº§å“
    productRepo.Save(Product{ID: "1", Name: "Laptop", Price: 999.99})
    productRepo.Save(Product{ID: "2", Name: "Phone", Price: 699.99})
    
    // æŸ¥æ‰¾æ‰€æœ‰äº§å“
    products := productRepo.FindAll()
    fmt.Println("All products:")
    for _, p := range products {
        fmt.Printf("  %+v\n", p)
    }
    
    // åˆ é™¤äº§å“
    err = productRepo.Delete("1")
    if err != nil {
        fmt.Printf("Error: %v\n", err)
    }
    
    products = productRepo.FindAll()
    fmt.Println("Products after deletion:")
    for _, p := range products {
        fmt.Printf("  %+v\n", p)
    }
}
```

---

## 8. å®é™…åº”ç”¨æ¡ˆä¾‹

### 8.1 é€šç”¨ç¼“å­˜å®ç°

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// ç¼“å­˜æ¡ç›®
type cacheEntry[T any] struct {
    value      T
    expiration time.Time
}

// é€šç”¨ç¼“å­˜
type Cache[K comparable, V any] struct {
    entries  map[K]cacheEntry[V]
    mutex    sync.RWMutex
    ttl      time.Duration
    onEvict  func(K, V)
}

// åˆ›å»ºæ–°ç¼“å­˜
func NewCache[K comparable, V any](ttl time.Duration, onEvict func(K, V)) *Cache[K, V] {
    cache := &Cache[K, V]{
        entries: make(map[K]cacheEntry[V]),
        ttl:     ttl,
        onEvict: onEvict,
    }
    
    // å¯åŠ¨æ¸…ç†goroutine
    go cache.startCleanup()
    
    return cache
}

// è·å–å€¼
func (c *Cache[K, V]) Get(key K) (V, bool) {
    c.mutex.RLock()
    defer c.mutex.RUnlock()
    
    entry, found := c.entries[key]
    if !found {
        var zero V
        return zero, false
    }
    
    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    if time.Now().After(entry.expiration) {
        var zero V
        return zero, false
    }
    
    return entry.value, true
}

// è®¾ç½®å€¼
func (c *Cache[K, V]) Set(key K, value V) {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    
    c.entries[key] = cacheEntry[V]{
        value:      value,
        expiration: time.Now().Add(c.ttl),
    }
}

// åˆ é™¤å€¼
func (c *Cache[K, V]) Delete(key K) {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    
    if entry, found := c.entries[key]; found && c.onEvict != nil {
        c.onEvict(key, entry.value)
    }
    
    delete(c.entries, key)
}

// æ¸…ç†è¿‡æœŸæ¡ç›®
func (c *Cache[K, V]) cleanup() {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    
    now := time.Now()
    for key, entry := range c.entries {
        if now.After(entry.expiration) {
            if c.onEvict != nil {
                c.onEvict(key, entry.value)
            }
            delete(c.entries, key)
        }
    }
}

// å¯åŠ¨å®šæœŸæ¸…ç†
func (c *Cache[K, V]) startCleanup() {
    ticker := time.NewTicker(c.ttl / 2)
    defer ticker.Stop()
    
    for range ticker.C {
        c.cleanup()
    }
}

func main() {
    // åˆ›å»ºå­—ç¬¦ä¸²->æ•´æ•°çš„ç¼“å­˜ï¼ŒTTLä¸º5ç§’
    cache := NewCache[string, int](5*time.Second, func(key string, value int) {
        fmt.Printf("Evicted: %s -> %d\n", key, value)
    })
    
    // è®¾ç½®ä¸€äº›å€¼
    cache.Set("one", 1)
    cache.Set("two", 2)
    cache.Set("three", 3)
    
    // è¯»å–å€¼
    if value, found := cache.Get("one"); found {
        fmt.Printf("Found: one -> %d\n", value)
    }
    
    if value, found := cache.Get("four"); !found {
        fmt.Println("Not found: four")
    }
    
    // æ‰‹åŠ¨åˆ é™¤
    cache.Delete("two")
    
    // éªŒè¯åˆ é™¤
    if _, found := cache.Get("two"); !found {
        fmt.Println("Not found after deletion: two")
    }
    
    // ç­‰å¾…è¿‡æœŸ
    fmt.Println("Waiting for expiration...")
    time.Sleep(6 * time.Second)
    
    // éªŒè¯è¿‡æœŸ
    if _, found := cache.Get("one"); !found {
        fmt.Println("Expired: one")
    }
    if _, found := cache.Get("three"); !found {
        fmt.Println("Expired: three")
    }
}
```

### 8.2 é€šç”¨JSONåºåˆ—åŒ–å™¨

```go
package main

import (
    "encoding/json"
    "fmt"
    "os"
    "sync"
)

// åºåˆ—åŒ–å™¨æ¥å£
type Serializer[T any] interface {
    Serialize(value T) ([]byte, error)
    Deserialize(data []byte) (T, error)
    SaveToFile(value T, filename string) error
    LoadFromFile(filename string) (T, error)
}

// JSONåºåˆ—åŒ–å™¨å®ç°
type JSONSerializer[T any] struct {
    mutex sync.Mutex
}

// åˆ›å»ºæ–°çš„JSONåºåˆ—åŒ–å™¨
func NewJSONSerializer[T any]() *JSONSerializer[T] {
    return &JSONSerializer[T]{}
}

// åºåˆ—åŒ–ä¸ºJSON
func (s *JSONSerializer[T]) Serialize(value T) ([]byte, error) {
    return json.Marshal(value)
}

// ä»JSONååºåˆ—åŒ–
func (s *JSONSerializer[T]) Deserialize(data []byte) (T, error) {
    var value T
    err := json.Unmarshal(data, &value)
    return value, err
}

// ä¿å­˜åˆ°æ–‡ä»¶
func (s *JSONSerializer[T]) SaveToFile(value T, filename string) error {
    s.mutex.Lock()
    defer s.mutex.Unlock()
    
    data, err := s.Serialize(value)
    if err != nil {
        return err
    }
    
    return os.WriteFile(filename, data, 0644)
}

// ä»æ–‡ä»¶åŠ è½½
func (s *JSONSerializer[T]) LoadFromFile(filename string) (T, error) {
    s.mutex.Lock()
    defer s.mutex.Unlock()
    
    var value T
    
    data, err := os.ReadFile(filename)
    if err != nil {
        return value, err
    }
    
    return s.Deserialize(data)
}

// ç¤ºä¾‹ç»“æ„ä½“
type Person struct {
    ID        string `json:"id"`
    Name      string `json:"name"`
    Age       int    `json:"age"`
    Addresses []struct {
        Street  string `json:"street"`
        City    string `json:"city"`
        Country string `json:"country"`
    } `json:"addresses"`
}

// å¦ä¸€ä¸ªç¤ºä¾‹ç»“æ„ä½“
type Configuration struct {
    ServerName string `json:"server_name"`
    Port       int    `json:"port"`
    Database   struct {
        Host     string `json:"host"`
        Username string `json:"username"`
        Password string `json:"password"`
    } `json:"database"`
    Features map[string]bool `json:"features"`
}

func main() {
    // åˆ›å»ºäººå‘˜åºåˆ—åŒ–å™¨
    personSerializer := NewJSONSerializer[Person]()
    
    // åˆ›å»ºäººå‘˜æ•°æ®
    person := Person{
        ID:   "1",
        Name: "John Doe",
        Age:  30,
        Addresses: []struct {
            Street  string `json:"street"`
            City    string `json:"city"`
            Country string `json:"country"`
        }{
            {
                Street:  "123 Main St",
                City:    "Anytown",
                Country: "USA",
            },
        },
    }
    
    // åºåˆ—åŒ–å¹¶ä¿å­˜åˆ°æ–‡ä»¶
    err := personSerializer.SaveToFile(person, "person.json")
    if err != nil {
        fmt.Printf("Error saving person: %v\n", err)
        return
    }
    
    // ä»æ–‡ä»¶åŠ è½½
    loadedPerson, err := personSerializer.LoadFromFile("person.json")
    if err != nil {
        fmt.Printf("Error loading person: %v\n", err)
        return
    }
    
    fmt.Printf("Loaded person: %+v\n", loadedPerson)
    
    // åˆ›å»ºé…ç½®åºåˆ—åŒ–å™¨
    configSerializer := NewJSONSerializer[Configuration]()
    
    // åˆ›å»ºé…ç½®æ•°æ®
    config := Configuration{
        ServerName: "api-server",
        Port:       8080,
        Database: struct {
            Host     string `json:"host"`
            Username string `json:"username"`
            Password string `json:"password"`
        }{
            Host:     "localhost",
            Username: "admin",
            Password: "password123",
        },
        Features: map[string]bool{
            "logging":      true,
            "auth":         true,
            "rate_limiter": false,
        },
    }
    
    // åºåˆ—åŒ–å¹¶ä¿å­˜åˆ°æ–‡ä»¶
    err = configSerializer.SaveToFile(config, "config.json")
    if err != nil {
        fmt.Printf("Error saving config: %v\n", err)
        return
    }
    
    // ä»æ–‡ä»¶åŠ è½½
    loadedConfig, err := configSerializer.LoadFromFile("config.json")
    if err != nil {
        fmt.Printf("Error loading config: %v\n", err)
        return
    }
    
    fmt.Printf("Loaded config: %+v\n", loadedConfig)
}
```

### 8.3 é€šç”¨äº‹ä»¶åˆ†å‘å™¨

```go
package main

import (
    "fmt"
    "sync"
)

// äº‹ä»¶æ¥å£
type Event interface {
    EventType() string
}

// äº‹ä»¶å¤„ç†å™¨å‡½æ•°ç±»å‹
type EventHandler[E Event] func(event E)

// äº‹ä»¶åˆ†å‘å™¨
type EventDispatcher[E Event] struct {
    handlers map[string][]EventHandler[E]
    mutex    sync.RWMutex
}

// åˆ›å»ºæ–°çš„äº‹ä»¶åˆ†å‘å™¨
func NewEventDispatcher[E Event]() *EventDispatcher[E] {
    return &EventDispatcher[E]{
        handlers: make(map[string][]EventHandler[E]),
    }
}

// æ³¨å†Œäº‹ä»¶å¤„ç†å™¨
func (d *EventDispatcher[E]) Register(eventType string, handler EventHandler[E]) {
    d.mutex.Lock()
    defer d.mutex.Unlock()
    
    d.handlers[eventType] = append(d.handlers[eventType], handler)
}

// åˆ†å‘äº‹ä»¶
func (d *EventDispatcher[E]) Dispatch(event E) {
    d.mutex.RLock()
    defer d.mutex.RUnlock()
    
    eventType := event.EventType()
    handlers, exists := d.handlers[eventType]
    if !exists {
        return
    }
    
    for _, handler := range handlers {
        handler(event)
    }
}

// ç¤ºä¾‹äº‹ä»¶ç±»å‹
type UserEvent struct {
    UserID string
    Action string
    Data   map[string]interface{}
}

func (e UserEvent) EventType() string {
    return e.Action
}

// ç³»ç»Ÿäº‹ä»¶ç±»å‹
type SystemEvent struct {
    Component string
    Action    string
    Severity  string
    Message   string
}

func (e SystemEvent) EventType() string {
    return e.Action
}

func main() {
    // åˆ›å»ºç”¨æˆ·äº‹ä»¶åˆ†å‘å™¨
    userDispatcher := NewEventDispatcher[UserEvent]()
    
    // æ³¨å†Œå¤„ç†å™¨
    userDispatcher.Register("login", func(event UserEvent) {
        fmt.Printf("User %s logged in from %s\n", 
            event.UserID, event.Data["ip"])
    })
    
    userDispatcher.Register("logout", func(event UserEvent) {
        fmt.Printf("User %s logged out\n", event.UserID)
    })
    
    userDispatcher.Register("profile-update", func(event UserEvent) {
        fmt.Printf("User %s updated profile: %v\n", 
            event.UserID, event.Data["changes"])
    })
    
    // åˆ†å‘ç”¨æˆ·äº‹ä»¶
    userDispatcher.Dispatch(UserEvent{
        UserID: "user123",
        Action: "login",
        Data: map[string]interface{}{
            "ip":        "192.168.1.1",
            "timestamp": "2023-04-01T12:00:00Z",
        },
    })
    
    userDispatcher.Dispatch(UserEvent{
        UserID: "user123",
        Action: "profile-update",
        Data: map[string]interface{}{
            "changes": map[string]string{
                "name":  "John Smith",
                "email": "john@example.com",
            },
        },
    })
    
    userDispatcher.Dispatch(UserEvent{
        UserID: "user123",
        Action: "logout",
        Data: map[string]interface{}{
            "timestamp": "2023-04-01T13:30:00Z",
        },
    })
    
    // åˆ›å»ºç³»ç»Ÿäº‹ä»¶åˆ†å‘å™¨
    systemDispatcher := NewEventDispatcher[SystemEvent]()
    
    // æ³¨å†Œå¤„ç†å™¨
    systemDispatcher.Register("startup", func(event SystemEvent) {
        fmt.Printf("System component %s started: %s\n", 
            event.Component, event.Message)
    })
    
    systemDispatcher.Register("shutdown", func(event SystemEvent) {
        fmt.Printf("System component %s shutdown: %s\n", 
            event.Component, event.Message)
    })
    
    systemDispatcher.Register("error", func(event SystemEvent) {
        fmt.Printf("ERROR [%s] in component %s: %s\n", 
            event.Severity, event.Component, event.Message)
    })
    
    // åˆ†å‘ç³»ç»Ÿäº‹ä»¶
    systemDispatcher.Dispatch(SystemEvent{
        Component: "database",
        Action:    "startup",
        Severity:  "info",
        Message:   "Database connection pool initialized",
    })
    
    systemDispatcher.Dispatch(SystemEvent{
        Component: "auth-service",
        Action:    "error",
        Severity:  "critical",
        Message:   "Failed to connect to authentication server",
    })
    
    systemDispatcher.Dispatch(SystemEvent{
        Component: "web-server",
        Action:    "shutdown",
        Severity:  "info",
        Message:   "Web server gracefully shutdown",
    })
}
```

---

## 9. å­¦ä¹ æ£€æŸ¥ç‚¹

- [ ] ç†è§£æ³›å‹çš„åŸºæœ¬æ¦‚å¿µå’Œä½¿ç”¨æ–¹å¼
- [ ] æŒæ¡ç±»å‹å‚æ•°å’Œçº¦æŸçš„å®šä¹‰
- [ ] èƒ½ä½¿ç”¨æ³›å‹è®¾è®¡çµæ´»çš„å‡½æ•°å’Œæ•°æ®ç»“æ„
- [ ] äº†è§£æ³›å‹æ€§èƒ½ç‰¹æ€§å’Œä»£ç è†¨èƒ€é—®é¢˜
- [ ] æŒæ¡æ³›å‹è®¾è®¡æ¨¡å¼å’Œæœ€ä½³å®è·µ
- [ ] èƒ½åœ¨å®é™…é¡¹ç›®ä¸­åº”ç”¨æ³›å‹è§£å†³å¤æ‚é—®é¢˜

---

Goè¯­è¨€çš„æ³›å‹ç‰¹æ€§ä¸ºç¼–å†™é€šç”¨ã€ç±»å‹å®‰å…¨å’Œå¯é‡ç”¨çš„ä»£ç æä¾›äº†å¼ºå¤§å·¥å…·ã€‚é€šè¿‡åˆç†ä½¿ç”¨æ³›å‹ï¼Œå¯ä»¥æ˜¾è‘—å‡å°‘ä»£ç é‡å¤ï¼ŒåŒæ—¶ä¿æŒGoè¯­è¨€çš„æ€§èƒ½å’Œç®€æ´æ€§ã€‚éšç€è¶Šæ¥è¶Šå¤šçš„åº“å’Œæ¡†æ¶é‡‡ç”¨æ³›å‹ï¼ŒæŒæ¡è¿™ä¸€ç‰¹æ€§å°†æˆä¸ºGoå¼€å‘è€…çš„å¿…å¤‡æŠ€èƒ½ã€‚
