# Python正则表达式

正则表达式(Regular Expression)是一种强大的文本模式匹配和处理工具，Python通过`re`模块提供对正则表达式的完整支持。本文详细介绍Python中正则表达式的使用方法和技巧。

## 正则表达式基础

正则表达式是由普通字符（例如字母）以及特殊字符（称为元字符）组成的文本模式，用于匹配、搜索和替换文本。

### 导入re模块

在Python中使用正则表达式需要先导入`re`模块：

```python
import re
```

### 基本匹配模式

```python
# 简单的模式匹配
text = "Hello, Python!"
pattern = "Python"
match = re.search(pattern, text)
if match:
    print("找到匹配!")  # 输出: 找到匹配!
    print(f"匹配内容: {match.group()}")  # 输出: 匹配内容: Python
    print(f"开始位置: {match.start()}")  # 输出: 开始位置: 7
    print(f"结束位置: {match.end()}")    # 输出: 结束位置: 13
    print(f"位置元组: {match.span()}")   # 输出: 位置元组: (7, 13)
```

## 元字符和特殊序列

正则表达式的强大来源于其丰富的元字符和特殊序列。

### 常用元字符

| 元字符 | 描述 |
|-------|------|
| `.` | 匹配除换行符外的任意字符 |
| `^` | 匹配字符串的开头 |
| `$` | 匹配字符串的结尾 |
| `*` | 匹配前一个字符0次或多次 |
| `+` | 匹配前一个字符1次或多次 |
| `?` | 匹配前一个字符0次或1次 |
| `{m}` | 匹配前一个字符恰好m次 |
| `{m,n}` | 匹配前一个字符m到n次 |
| `[]` | 字符集，匹配集合中的任一字符 |
| `\|` | 或运算符，匹配`\|`前或后的表达式 |
| `()` | 分组，可以提取匹配的子字符串 |
| `\` | 转义字符，用于匹配元字符本身 |

```python
# 元字符示例
text = "Python 3.9.0 was released in 2020-10-05"

# . 匹配任意字符
print(re.findall("Py...n", text))  # ['Python']

# ^ 匹配开头
print(re.findall("^Python", text))  # ['Python']

# $ 匹配结尾
print(re.findall("05$", text))  # ['05']

# * 匹配0次或多次
print(re.findall("Py.*n", text))  # ['Python 3.9.0 was released in']

# + 匹配1次或多次
print(re.findall("\d+", text))  # ['3', '9', '0', '2020', '10', '05']

# ? 匹配0次或1次
print(re.findall("releases?", text))  # ['release']

# {m} 匹配恰好m次
print(re.findall("\d{4}", text))  # ['2020']

# {m,n} 匹配m到n次
print(re.findall("\d{1,2}", text))  # ['3', '9', '0', '20', '20', '10', '05']

# [] 字符集
print(re.findall("[Pp]ython", "Python python"))  # ['Python', 'python']

# | 或运算符
print(re.findall("Python|Java", "Python and Java"))  # ['Python', 'Java']

# () 分组
match = re.search("(\d{4})-(\d{2})-(\d{2})", text)
if match:
    print(f"年份: {match.group(1)}")  # 年份: 2020
    print(f"月份: {match.group(2)}")  # 月份: 10
    print(f"日期: {match.group(3)}")  # 日期: 05
```

### 常用特殊序列

| 特殊序列 | 描述 |
|---------|------|
| `\d` | 匹配任意数字字符，等价于`[0-9]` |
| `\D` | 匹配任意非数字字符，等价于`[^0-9]` |
| `\w` | 匹配任意字母数字字符，等价于`[a-zA-Z0-9_]` |
| `\W` | 匹配任意非字母数字字符，等价于`[^a-zA-Z0-9_]` |
| `\s` | 匹配任意空白字符，等价于`[ \t\n\r\f\v]` |
| `\S` | 匹配任意非空白字符，等价于`[^ \t\n\r\f\v]` |
| `\b` | 匹配单词边界 |
| `\B` | 匹配非单词边界 |
| `\A` | 匹配字符串开始 |
| `\Z` | 匹配字符串结束 |

```python
text = "Python 3.9.0, released in 2020"

# \d 匹配数字
print(re.findall(r"\d", text))  # ['3', '9', '0', '2', '0', '2', '0']

# \D 匹配非数字
print(re.findall(r"\D+", text))  # ['Python ', '.', '.', ', released in ']

# \w 匹配字母数字
print(re.findall(r"\w+", text))  # ['Python', '3', '9', '0', 'released', 'in', '2020']

# \W 匹配非字母数字
print(re.findall(r"\W+", text))  # [' ', '.', '.', ', ', ' ', ' ']

# \s 匹配空白
print(re.findall(r"\s+", text))  # [' ', ' ', ' ']

# \S 匹配非空白
print(re.findall(r"\S+", text))  # ['Python', '3.9.0,', 'released', 'in', '2020']

# \b 匹配单词边界
print(re.findall(r"\bPy\w+\b", text))  # ['Python']

# \B 匹配非单词边界
print(re.findall(r"\Bon\b", text))  # ['on']
```

## re模块的主要函数

Python的`re`模块提供了多种函数用于正则表达式操作。

### 基本搜索函数

```python
text = "Python is powerful, Python is flexible."

# re.search() - 查找第一个匹配项
match = re.search("Python", text)
if match:
    print(f"搜索结果: {match.group()}")  # 搜索结果: Python

# re.match() - 从字符串开头匹配
match = re.match("Python", text)
if match:
    print(f"匹配开头: {match.group()}")  # 匹配开头: Python

# re.fullmatch() - 完整字符串匹配
match = re.fullmatch("Python is powerful, Python is flexible.", text)
if match:
    print("完整匹配成功")  # 完整匹配成功

# re.findall() - 查找所有匹配项，返回列表
all_matches = re.findall("Python", text)
print(f"所有匹配: {all_matches}")  # 所有匹配: ['Python', 'Python']

# re.finditer() - 查找所有匹配项，返回迭代器
for match in re.finditer("Python", text):
    print(f"位置 {match.span()}: {match.group()}")
    # 位置 (0, 6): Python
    # 位置 (19, 25): Python
```

### 替换和分割函数

```python
text = "Python is powerful, Python is flexible."

# re.sub() - 替换匹配项
new_text = re.sub("Python", "Ruby", text)
print(f"替换后: {new_text}")  # 替换后: Ruby is powerful, Ruby is flexible.

# re.sub() - 限制替换次数
new_text = re.sub("Python", "Ruby", text, count=1)
print(f"替换一次: {new_text}")  # 替换一次: Ruby is powerful, Python is flexible.

# re.subn() - 替换并返回替换次数
new_text, count = re.subn("Python", "Ruby", text)
print(f"替换后: {new_text}, 替换次数: {count}")  # 替换后: Ruby is powerful, Ruby is flexible., 替换次数: 2

# re.split() - 按匹配项分割字符串
parts = re.split(",", text)
print(f"分割结果: {parts}")  # 分割结果: ['Python is powerful', ' Python is flexible.']

# re.split() - 使用更复杂的模式分割
parts = re.split(r"\s+", text)
print(f"按空白分割: {parts}")  # 按空白分割: ['Python', 'is', 'powerful,', 'Python', 'is', 'flexible.']
```

## 正则表达式对象

在Python中，可以将正则表达式编译成对象，以提高匹配效率，特别是当同一模式要重复使用时。

```python
# 编译正则表达式
pattern = re.compile(r"\bPython\b")

text1 = "Python is a programming language."
text2 = "I love Python programming."

# 使用编译好的模式
match1 = pattern.search(text1)
match2 = pattern.search(text2)

print(f"匹配1: {match1.group() if match1 else '无匹配'}")  # 匹配1: Python
print(f"匹配2: {match2.group() if match2 else '无匹配'}")  # 匹配2: Python

# 正则表达式对象的方法
print(pattern.findall(text1))  # ['Python']
print(pattern.sub("Java", text1))  # Java is a programming language.
```

## 匹配标志(Flags)

Python正则表达式提供了一些标志，用于控制匹配的行为。

```python
text = """Python is powerful.
PYTHON is flexible.
python is easy to learn."""

# re.IGNORECASE 或 re.I - 忽略大小写
pattern = re.compile(r"python", re.IGNORECASE)
print(pattern.findall(text))  # ['Python', 'PYTHON', 'python']

# re.MULTILINE 或 re.M - 多行模式
pattern = re.compile(r"^python", re.MULTILINE | re.IGNORECASE)
print(pattern.findall(text))  # ['Python', 'python']

# re.DOTALL 或 re.S - 点号匹配包括换行符在内的所有字符
pattern = re.compile(r"powerful.*flexible", re.DOTALL)
print(pattern.findall(text))  # ['powerful.\nPYTHON is flexible']

# re.VERBOSE 或 re.X - 详细模式，允许注释和空白
pattern = re.compile(r"""
    \b          # 单词边界
    [Pp]ython   # Python (不区分大小写)
    \b          # 单词边界
    """, re.VERBOSE)
print(pattern.findall(text))  # ['Python', 'python']
```

### 常用标志列表

| 标志 | 简写 | 描述 |
|------|------|------|
| `re.IGNORECASE` | `re.I` | 忽略大小写 |
| `re.MULTILINE` | `re.M` | 多行模式，影响^和$的行为 |
| `re.DOTALL` | `re.S` | 让.匹配包括换行符的所有字符 |
| `re.VERBOSE` | `re.X` | 详细模式，允许注释和忽略空白 |
| `re.ASCII` | `re.A` | 使\w, \W, \b, \B, \d, \D, \s和\S只匹配ASCII字符 |
| `re.UNICODE` | `re.U` | 使模式中的\w, \W, \b, \B和字符类匹配基于Unicode字符属性 |
| `re.LOCALE` | `re.L` | 使\w, \W, \b, \B依赖于当前区域设置 |

## 贪婪与非贪婪匹配

默认情况下，正则表达式使用贪婪匹配，即尽可能匹配更多的字符。

```python
text = "<div>内容1</div><div>内容2</div>"

# 贪婪匹配 - 尽可能多地匹配
greedy_pattern = re.compile(r"<div>.*</div>")
print(greedy_pattern.findall(text))  # ['<div>内容1</div><div>内容2</div>']

# 非贪婪匹配 - 尽可能少地匹配，使用?修饰量词
non_greedy_pattern = re.compile(r"<div>.*?</div>")
print(non_greedy_pattern.findall(text))  # ['<div>内容1</div>', '<div>内容2</div>']
```

## 分组和捕获

正则表达式中的括号`()`用于创建捕获组，可以提取匹配的子字符串。

```python
text = "张三的电话是123-4567-8901，李四的电话是189-1234-5678"

# 基本分组匹配
pattern = re.compile(r"(\w+)的电话是(\d{3}-\d{4}-\d{4})")
for match in pattern.finditer(text):
    print(f"姓名: {match.group(1)}, 电话: {match.group(2)}")
    # 姓名: 张三, 电话: 123-4567-8901
    # 姓名: 李四, 电话: 189-1234-5678

# 命名分组
pattern = re.compile(r"(?P<name>\w+)的电话是(?P<phone>\d{3}-\d{4}-\d{4})")
for match in pattern.finditer(text):
    print(f"姓名: {match.group('name')}, 电话: {match.group('phone')}")
    # 姓名: 张三, 电话: 123-4567-8901
    # 姓名: 李四, 电话: 189-1234-5678

# 非捕获分组 (?:...)
pattern = re.compile(r"(?:\w+)的电话是(\d{3}-\d{4}-\d{4})")
for match in pattern.finditer(text):
    print(f"电话: {match.group(1)}")
    # 电话: 123-4567-8901
    # 电话: 189-1234-5678
```

### 反向引用

可以在正则表达式中使用反向引用来引用之前捕获的组。

```python
# 匹配重复的单词
text = "我喜欢Python Python编程"
pattern = re.compile(r"(\b\w+\b) \1")
print(pattern.findall(text))  # ['Python']

# 检查HTML标签是否匹配
html = "<div><span>内容</span></div><p>更多内容</p>"
pattern = re.compile(r"<(\w+)>.*?</\1>")
print(pattern.findall(html))  # ['div', 'span', 'p']

# 使用命名组的反向引用
text = "把这个字符串中的Python替换为PYTHON，但保留python"
pattern = re.compile(r"(?P<lang>Python).*?(?P=lang)")
print(pattern.findall(text))  # ['Python']
```

## 先行断言和后行断言

断言用于指定匹配位置的前后环境，但不包含在匹配结果中。

```python
text = "我喜欢Python编程，Python很有趣，我不喜欢Java编程"

# 正向先行断言 (?=...) - 匹配后面跟着指定模式的位置
pattern = re.compile(r"Python(?=编程)")
print(pattern.findall(text))  # ['Python']

# 负向先行断言 (?!...) - 匹配后面不跟着指定模式的位置
pattern = re.compile(r"Python(?!编程)")
print(pattern.findall(text))  # ['Python']

# 正向后行断言 (?<=...) - 匹配前面有指定模式的位置
pattern = re.compile(r"(?<=喜欢)Python")
print(pattern.findall(text))  # ['Python']

# 负向后行断言 (?<!...) - 匹配前面没有指定模式的位置
pattern = re.compile(r"(?<!喜欢)Python")
print(pattern.findall(text))  # ['Python']
```

## 实用正则表达式示例

### 验证电子邮件地址

```python
def is_valid_email(email):
    pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
    return bool(pattern.match(email))

print(is_valid_email("user@example.com"))  # True
print(is_valid_email("invalid-email"))     # False
print(is_valid_email("user@.com"))         # False
```

### 提取URL

```python
def extract_urls(text):
    pattern = re.compile(r'https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(?:/[^/\s]*)*')
    return pattern.findall(text)

text = "访问我的网站 http://example.com 和 https://github.com/user/repo"
print(extract_urls(text))  # ['http://example.com', 'https://github.com/user/repo']
```

### 解析日期格式

```python
def parse_date(text):
    pattern = re.compile(r'(\d{4})-(\d{2})-(\d{2})')
    match = pattern.search(text)
    if match:
        year, month, day = match.groups()
        return {"year": int(year), "month": int(month), "day": int(day)}
    return None

print(parse_date("今天是2023-05-15"))  # {'year': 2023, 'month': 5, 'day': 15}
```

### 验证密码强度

```python
def check_password_strength(password):
    # 至少8个字符，包含大小写字母、数字和特殊字符
    pattern = re.compile(r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+])[A-Za-z\d!@#$%^&*()_+]{8,}$')
    return bool(pattern.match(password))

print(check_password_strength("Weak123"))           # False
print(check_password_strength("Strong123!"))        # True
print(check_password_strength("NoUppercase123!"))   # False
```

### 清理文本

```python
def clean_text(text):
    # 删除HTML标签
    text = re.sub(r'<[^>]+>', '', text)
    # 替换多个空白为单个空格
    text = re.sub(r'\s+', ' ', text)
    # 删除URLs
    text = re.sub(r'https?://\S+', '', text)
    return text.strip()

dirty_text = """<div>这是一些<b>HTML</b>文本</div>
包含   多余的空白
和 http://example.com 链接"""

print(clean_text(dirty_text))  # 这是一些HTML文本 包含 多余的空白 和 链接
```

## 性能考虑和最佳实践

### 编译正则表达式

对于重复使用的模式，应该预先编译以提高性能：

```python
# 编译一次，多次使用
pattern = re.compile(r'\d+')

# 处理多个字符串
texts = ["数字123", "数字456", "数字789"]
for text in texts:
    print(pattern.findall(text))
```

### 优化正则表达式

1. **避免不必要的贪婪匹配**：过度使用`.*`可能导致性能问题
2. **使用更具体的模式**：使用`\d`替代`.`来匹配数字
3. **避免过度回溯**：复杂的正则表达式可能导致灾难性回溯
4. **使用非捕获组**：如果不需要提取内容，使用`(?:...)`代替`(...)`

```python
# 低效的正则表达式
inefficient = re.compile(r'.*(\d{4}-\d{2}-\d{2}).*')

# 优化后的正则表达式
efficient = re.compile(r'.*?(\d{4}-\d{2}-\d{2})')

# 进一步优化 - 使用非捕获组和更具体的模式
more_efficient = re.compile(r'(?:.*?)(\d{4}-\d{2}-\d{2})')
```

### 常见错误

1. **忘记转义特殊字符**：如`.`, `*`, `+`, `?`, `^`, `$`, `\`, `|`, `{`, `}`, `[`, `]`, `(`, `)`
2. **混淆`re.match()`和`re.search()`**：`match()`只从字符串开始匹配，`search()`在整个字符串中查找
3. **忽略原始字符串标记**：使用`r`前缀避免转义序列问题，如`r'\d'`而不是`'\\d'`
4. **过度使用正则表达式**：简单的字符串操作应使用内置方法，如`str.startswith()`、`str.endswith()`

```python
# 正确转义特殊字符
pattern = re.compile(r'1\+1=2')  # 匹配 "1+1=2"

# 使用原始字符串
pattern = re.compile(r'\b\w+\b')  # 匹配单词边界，不需要双重转义

# 简单情况不用正则
if text.startswith("Python"):  # 比 re.match("^Python", text) 更清晰高效
    print("以Python开头")
```

## 第三方正则表达式库

### regex

`regex`是`re`模块的增强替代品，提供了更多功能：

```python
# 安装: pip install regex
import regex

# 使用Unicode属性
pattern = regex.compile(r'\p{Han}+')  # 匹配中文汉字
print(pattern.findall("Python是一种编程语言"))  # ['是一种编程语言']

# 支持递归模式
pattern = regex.compile(r'(\w+(?:\s+\1)+)')  # 匹配重复的单词序列
print(pattern.findall("the the quick quick brown fox"))  # ['the the', 'quick quick']

# 支持分组命名的反向引用
pattern = regex.compile(r'(?<word>\w+)\s+\k<word>')
print(pattern.findall("Python Python is great"))  # ['Python']
```

## 总结

Python的正则表达式提供了强大的文本处理能力：

1. **基础元素**：字符匹配、元字符、特殊序列构成正则表达式的基本语法
2. **核心功能**：`re`模块提供搜索、替换、分割等基本功能
3. **高级特性**：分组、断言、贪婪/非贪婪匹配等提供精确控制
4. **实用技巧**：编译表达式、使用合适的标志、优化模式可提高效率

掌握正则表达式能显著提升文本处理效率，适用于数据验证、信息提取、文本清洗等多种场景。虽然学习曲线较陡，但作为Python开发者的核心技能，值得投入时间掌握。
