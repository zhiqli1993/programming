# Python数据结构

Python标准库提供了丰富的内置数据结构，以及collections模块中的高级数据结构。熟练掌握这些数据结构可以帮助我们高效地组织和操作数据，优化程序性能。

## 内置数据结构

### 列表 (List)

列表是Python中最常用的序列类型，它是可变的、有序的元素集合。

```python
# 创建列表
empty_list = []
numbers = [1, 2, 3, 4, 5]
mixed = [1, "Hello", 3.14, True]

# 访问元素
first = numbers[0]  # 1
last = numbers[-1]  # 5

# 切片
subset = numbers[1:4]  # [2, 3, 4]
reversed_list = numbers[::-1]  # [5, 4, 3, 2, 1]

# 修改列表
numbers[0] = 10  # [10, 2, 3, 4, 5]
numbers.append(6)  # [10, 2, 3, 4, 5, 6]
numbers.insert(1, 15)  # [10, 15, 2, 3, 4, 5, 6]
numbers.extend([7, 8, 9])  # [10, 15, 2, 3, 4, 5, 6, 7, 8, 9]

# 删除元素
removed = numbers.pop()  # 返回9，numbers变为[10, 15, 2, 3, 4, 5, 6, 7, 8]
numbers.pop(1)  # 删除索引为1的元素，numbers变为[10, 2, 3, 4, 5, 6, 7, 8]
numbers.remove(5)  # 删除值为5的元素，numbers变为[10, 2, 3, 4, 6, 7, 8]
del numbers[0]  # 删除索引为0的元素，numbers变为[2, 3, 4, 6, 7, 8]

# 其他常用操作
length = len(numbers)  # 6
maximum = max(numbers)  # 8
minimum = min(numbers)  # 2
total_sum = sum(numbers)  # 30

# 排序
numbers.sort()  # 原地排序，numbers变为[2, 3, 4, 6, 7, 8]
numbers.sort(reverse=True)  # 降序排序，numbers变为[8, 7, 6, 4, 3, 2]
sorted_copy = sorted(numbers)  # 返回排序后的新列表，不修改原列表

# 列表推导式
squares = [x**2 for x in range(10)]  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
even_squares = [x**2 for x in range(10) if x % 2 == 0]  # [0, 4, 16, 36, 64]
```

### 元组 (Tuple)

元组是不可变的序列类型，一旦创建就不能修改。

```python
# 创建元组
empty_tuple = ()
singleton = (1,)  # 注意：单元素元组需要逗号
numbers = (1, 2, 3, 4, 5)
mixed = (1, "Hello", 3.14, True)

# 也可以省略括号
another_tuple = 1, 2, 3, 4, 5

# 访问元素（与列表相同）
first = numbers[0]  # 1
last = numbers[-1]  # 5
subset = numbers[1:4]  # (2, 3, 4)

# 元组解包
a, b, c = (1, 2, 3)
x, *y, z = (1, 2, 3, 4, 5)  # x=1, y=[2, 3, 4], z=5

# 元组是不可变的，但可以连接生成新元组
combined = numbers + (6, 7, 8)  # (1, 2, 3, 4, 5, 6, 7, 8)

# 嵌套元组
nested = ((1, 2), (3, 4), (5, 6))
first_pair = nested[0]  # (1, 2)
first_from_pair = nested[0][0]  # 1

# 其他常用操作（与列表类似）
length = len(numbers)  # 5
maximum = max(numbers)  # 5
minimum = min(numbers)  # 1
```

### 字典 (Dictionary)

字典是键值对的无序集合，提供了高效的查找、插入和删除操作。

```python
# 创建字典
empty_dict = {}
person = {"name": "Alice", "age": 30, "city": "New York"}
another_dict = dict(name="Bob", age=25, city="Boston")

# 访问值
name = person["name"]  # Alice
age = person.get("age")  # 30
# 使用get可以提供默认值，避免KeyError
country = person.get("country", "Unknown")  # "Unknown"

# 修改字典
person["age"] = 31  # 更新值
person["country"] = "USA"  # 添加新项
person.update({"email": "alice@example.com", "phone": "555-1234"})  # 批量更新

# 删除项
removed = person.pop("phone")  # 返回并删除指定键对应的值
del person["email"]  # 直接删除指定键及其值
last_item = person.popitem()  # 返回并删除最后添加的键值对

# 检查键是否存在
has_name = "name" in person  # True
has_phone = "phone" in person  # False

# 字典视图
keys = person.keys()  # dict_keys(['name', 'age', 'city'])
values = person.values()  # dict_values(['Alice', 31, 'New York'])
items = person.items()  # dict_items([('name', 'Alice'), ('age', 31), ('city', 'New York')])

# 字典推导式
squares = {x: x**2 for x in range(6)}  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

# 合并字典（Python 3.5+）
dict1 = {"a": 1, "b": 2}
dict2 = {"b": 3, "c": 4}
merged = {**dict1, **dict2}  # {'a': 1, 'b': 3, 'c': 4}

# Python 3.9+也可以使用|运算符
# merged = dict1 | dict2
```

### 集合 (Set)

集合是唯一元素的无序集合，支持数学集合操作。

```python
# 创建集合
empty_set = set()  # 注意：{}创建的是空字典，不是空集合
numbers = {1, 2, 3, 4, 5}
mixed = {1, "Hello", 3.14, True}

# 从其他可迭代对象创建
fruits = set(["apple", "banana", "orange", "apple"])  # {'orange', 'apple', 'banana'}

# 基本操作
numbers.add(6)  # 添加元素
numbers.remove(3)  # 删除元素（如果不存在会引发KeyError）
numbers.discard(10)  # 删除元素（如果不存在不会引发错误）
popped = numbers.pop()  # 随机移除并返回一个元素
numbers.clear()  # 清空集合

# 集合操作
set1 = {1, 2, 3, 4, 5}
set2 = {4, 5, 6, 7, 8}

union = set1 | set2  # 并集: {1, 2, 3, 4, 5, 6, 7, 8}
intersection = set1 & set2  # 交集: {4, 5}
difference = set1 - set2  # 差集: {1, 2, 3}
symmetric_diff = set1 ^ set2  # 对称差集: {1, 2, 3, 6, 7, 8}

# 检查子集和超集
is_subset = set1 <= set2  # False
is_superset = set1 >= {1, 2}  # True

# 检查元素是否存在
has_element = 3 in set1  # True

# 集合推导式
even_numbers = {x for x in range(10) if x % 2 == 0}  # {0, 2, 4, 6, 8}
```

### 不可变集合 (Frozenset)

不可变集合是不可修改的集合，可以用作字典的键或其他集合的元素。

```python
# 创建不可变集合
immutable = frozenset([1, 2, 3, 4, 5])

# 可以进行集合操作，但返回新的不可变集合
union = immutable | {6, 7, 8}  # frozenset({1, 2, 3, 4, 5, 6, 7, 8})

# 不支持添加和删除操作
# immutable.add(6)  # 这会引发AttributeError
```

## Collections模块

Python的collections模块提供了额外的数据结构，扩展了内置类型的功能。

### namedtuple

namedtuple创建带有命名字段的元组子类，使代码更易读。

```python
from collections import namedtuple

# 定义一个命名元组类型
Point = namedtuple('Point', ['x', 'y'])
p = Point(11, y=22)  # 创建实例

# 访问字段
print(p.x, p.y)  # 11 22
print(p[0], p[1])  # 11 22

# 解包
x, y = p
print(x, y)  # 11 22

# 转换为字典
p_dict = p._asdict()  # {'x': 11, 'y': 22}

# 创建修改后的新实例
p2 = p._replace(x=33)  # Point(x=33, y=22)

# 创建带有默认值的命名元组
Person = namedtuple('Person', ['name', 'age', 'city'], defaults=['Unknown', 0, 'Unknown'])
default_person = Person()  # Person(name='Unknown', age=0, city='Unknown')
```

### deque

deque（双端队列）是一个线程安全、支持两端快速添加和删除的列表。

```python
from collections import deque

# 创建双端队列
d = deque([1, 2, 3])

# 添加元素
d.append(4)  # 添加到右端: deque([1, 2, 3, 4])
d.appendleft(0)  # 添加到左端: deque([0, 1, 2, 3, 4])
d.extend([5, 6])  # 扩展右端: deque([0, 1, 2, 3, 4, 5, 6])
d.extendleft([-2, -1])  # 扩展左端: deque([-1, -2, 0, 1, 2, 3, 4, 5, 6])

# 删除元素
right = d.pop()  # 从右端删除: 6
left = d.popleft()  # 从左端删除: -1

# 旋转
d.rotate(2)  # 向右旋转2步: deque([3, 4, 5, -2, 0, 1, 2])
d.rotate(-2)  # 向左旋转2步: deque([-2, 0, 1, 2, 3, 4, 5])

# 限制大小的deque
limited = deque(maxlen=3)
for i in range(5):
    limited.append(i)  # 添加时会自动删除另一端的元素
print(limited)  # deque([2, 3, 4], maxlen=3)
```

### Counter

Counter是一个字典子类，用于计数可哈希对象。

```python
from collections import Counter

# 创建计数器
c = Counter('abracadabra')  # Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1})
word_counts = Counter(['apple', 'orange', 'banana', 'apple', 'orange', 'apple'])

# 访问计数
print(c['a'])  # 5
print(c.get('z', 0))  # 0

# 更新计数
c.update('aaa')  # 增加计数: Counter({'a': 8, 'b': 2, 'r': 2, 'c': 1, 'd': 1})
c['b'] += 3  # 直接修改: Counter({'a': 8, 'b': 5, 'r': 2, 'c': 1, 'd': 1})

# 最常见的元素
most_common = c.most_common(2)  # [('a', 8), ('b', 5)]

# 计数器算术
c1 = Counter(a=3, b=1)
c2 = Counter(a=1, b=2)
print(c1 + c2)  # Counter({'a': 4, 'b': 3}) - 相加
print(c1 - c2)  # Counter({'a': 2}) - 相减（只保留正值）
print(c1 & c2)  # Counter({'a': 1, 'b': 1}) - 交集（取最小值）
print(c1 | c2)  # Counter({'a': 3, 'b': 2}) - 并集（取最大值）
```

### defaultdict

defaultdict是一个字典子类，为缺失的键提供默认值。

```python
from collections import defaultdict

# 创建默认为int类型的字典
int_dict = defaultdict(int)
for word in ['apple', 'banana', 'apple', 'orange', 'banana', 'apple']:
    int_dict[word] += 1
print(int_dict)  # defaultdict(<class 'int'>, {'apple': 3, 'banana': 2, 'orange': 1})

# 创建默认为list类型的字典
list_dict = defaultdict(list)
for key, value in [('a', 1), ('b', 2), ('a', 3), ('b', 4), ('c', 5)]:
    list_dict[key].append(value)
print(list_dict)  # defaultdict(<class 'list'>, {'a': [1, 3], 'b': [2, 4], 'c': [5]})

# 创建默认为自定义类型的字典
def default_factory():
    return {"count": 0, "sum": 0}

stats = defaultdict(default_factory)
for key, value in [('a', 10), ('b', 5), ('a', 5), ('c', 15)]:
    stats[key]["count"] += 1
    stats[key]["sum"] += value
print(stats)  # defaultdict(<function default_factory at ...>, {'a': {'count': 2, 'sum': 15}, 'b': {'count': 1, 'sum': 5}, 'c': {'count': 1, 'sum': 15}})
```

### OrderedDict

OrderedDict是一个字典子类，记住了项的添加顺序。在Python 3.7+中，普通字典也保留了插入顺序，但OrderedDict还有一些额外的功能。

```python
from collections import OrderedDict

# 创建有序字典
od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])

# 移动项到末尾
od.move_to_end('a')  # OrderedDict([('b', 2), ('c', 3), ('a', 1)])

# 移动项到开头
od.move_to_end('a', last=False)  # OrderedDict([('a', 1), ('b', 2), ('c', 3)])

# 逆序迭代
for key in reversed(od):
    print(key, od[key])  # 按相反顺序输出: c 3, b 2, a 1

# 删除并返回最后一项
last_item = od.popitem()  # ('c', 3)

# 删除并返回第一项
first_item = od.popitem(last=False)  # ('a', 1)
```

### ChainMap

ChainMap将多个映射组合成单一视图。

```python
from collections import ChainMap

# 创建多个字典
dict1 = {'a': 1, 'b': 2}
dict2 = {'b': 3, 'c': 4}
dict3 = {'c': 5, 'd': 6}

# 组合多个字典
combined = ChainMap(dict1, dict2, dict3)
print(combined['a'])  # 1 - 从dict1
print(combined['b'])  # 2 - 从dict1（而不是dict2，因为dict1在前面）
print(combined['c'])  # 4 - 从dict2
print(combined['d'])  # 6 - 从dict3

# 修改第一个映射
combined['a'] = 10  # 修改dict1
print(dict1)  # {'a': 10, 'b': 2}

# 创建新的ChainMap，添加新映射
new_dict = {'e': 7}
new_chain = combined.new_child(new_dict)
print(new_chain['e'])  # 7

# 访问所有键和值
keys = list(combined.keys())  # ['a', 'b', 'c', 'd']
values = list(combined.values())  # [10, 2, 4, 6]
```

### UserDict, UserList, and UserString

这些类可以作为内置类型的包装器，更容易定制行为。

```python
from collections import UserDict, UserList, UserString

# 自定义字典
class MyDict(UserDict):
    def __getitem__(self, key):
        print(f"Accessing {key}")
        return super().__getitem__(key)

d = MyDict({'a': 1, 'b': 2})
print(d['a'])  # 输出: Accessing a, 1

# 自定义列表
class MyList(UserList):
    def append(self, item):
        print(f"Appending {item}")
        super().append(item)

l = MyList([1, 2, 3])
l.append(4)  # 输出: Appending 4

# 自定义字符串
class MyString(UserString):
    def upper(self):
        print("Converting to uppercase")
        return super().upper()

s = MyString("Hello")
print(s.upper())  # 输出: Converting to uppercase, HELLO
```

## 内置数据结构的性能特性

了解各种数据结构的性能特性有助于选择适合特定任务的数据结构。

| 操作 | 列表(List) | 元组(Tuple) | 字典(Dict) | 集合(Set) |
|------|-----------|------------|-----------|----------|
| 索引访问 | O(1) | O(1) | O(1) | N/A |
| 插入/删除(开头) | O(n) | N/A | O(1) | O(1) |
| 插入/删除(结尾) | O(1) | N/A | O(1) | O(1) |
| 插入/删除(中间) | O(n) | N/A | O(1) | O(1) |
| 包含检查 | O(n) | O(n) | O(1) | O(1) |
| 长度获取 | O(1) | O(1) | O(1) | O(1) |

## 数据结构的选择指南

根据不同的使用场景选择合适的数据结构：

1. **列表(List)**
   - 当需要有序、可变的集合时
   - 当需要经常在末尾添加或删除元素时
   - 当需要保存重复元素时

2. **元组(Tuple)**
   - 当需要不可变的有序集合时
   - 作为字典的键或集合的元素时
   - 用于函数返回多个值时

3. **字典(Dict)**
   - 当需要键值对映射时
   - 当需要快速查找、插入和删除时
   - 当需要通过键访问数据时

4. **集合(Set)**
   - 当需要确保元素唯一性时
   - 当需要进行集合运算（并集、交集等）时
   - 当需要快速成员检查时

5. **deque**
   - 当需要在两端高效地添加和删除元素时
   - 实现队列或栈时

6. **Counter**
   - 计数唯一项的出现次数时
   - 找出最常见的元素时

7. **defaultdict**
   - 当访问不存在的键时需要默认值时
   - 分组处理数据时

8. **OrderedDict**
   - 当需要记住项的插入顺序并进行特殊操作时（Python 3.7+中普通字典也保留了顺序）

## 实际应用示例

### 使用计数器进行词频统计

```python
from collections import Counter
import re

def word_frequency(text):
    # 将文本转换为小写并分割成单词
    words = re.findall(r'\w+', text.lower())
    # 计算词频
    return Counter(words)

text = "To be or not to be, that is the question."
freq = word_frequency(text)
print(freq.most_common(3))  # [('to', 2), ('be', 2), ('or', 1)]
```

### 使用defaultdict进行分组

```python
from collections import defaultdict

def group_by_category(items):
    # 按类别分组
    grouped = defaultdict(list)
    for item in items:
        grouped[item['category']].append(item)
    return grouped

products = [
    {'id': 1, 'name': 'Apple', 'category': 'Fruit'},
    {'id': 2, 'name': 'Carrot', 'category': 'Vegetable'},
    {'id': 3, 'name': 'Banana', 'category': 'Fruit'},
    {'id': 4, 'name': 'Cucumber', 'category': 'Vegetable'}
]

grouped_products = group_by_category(products)
print(grouped_products['Fruit'])  # [{'id': 1, 'name': 'Apple', 'category': 'Fruit'}, {'id': 3, 'name': 'Banana', 'category': 'Fruit'}]
```

### 使用namedtuple提高代码可读性

```python
from collections import namedtuple

# 定义点和矩形
Point = namedtuple('Point', ['x', 'y'])
Rectangle = namedtuple('Rectangle', ['top_left', 'bottom_right'])

# 创建一个矩形
rect = Rectangle(Point(0, 0), Point(10, 10))

# 计算面积
def area(rect):
    width = rect.bottom_right.x - rect.top_left.x
    height = rect.bottom_right.y - rect.top_left.y
    return width * height

print(area(rect))  # 100
```

### 使用ChainMap实现多层配置

```python
from collections import ChainMap

# 默认配置
defaults = {'theme': 'dark', 'language': 'en', 'font_size': 12}

# 用户配置
user_settings = {'language': 'fr', 'font_size': 14}

# 命令行参数
cli_args = {'theme': 'light'}

# 组合配置，优先级：命令行 > 用户设置 > 默认值
config = ChainMap(cli_args, user_settings, defaults)
print(config['theme'])  # light (from cli_args)
print(config['language'])  # fr (from user_settings)
print(config['font_size'])  # 14 (from user_settings)
```

Python的数据结构非常丰富，能够满足各种复杂的数据组织和处理需求。通过熟练掌握这些数据结构及其特性，可以写出更加高效、简洁和优雅的代码。
