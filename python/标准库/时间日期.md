# Python时间和日期处理

Python提供了多种处理时间和日期的模块，包括`time`、`datetime`和`calendar`。这些模块提供了丰富的功能，用于时间测量、日期计算、格式化和解析等操作。

## time模块

`time`模块提供了各种与时间相关的函数，主要基于POSIX C标准库。

### 获取当前时间

```python
import time

# 获取当前时间戳（从1970年1月1日00:00:00 UTC开始的秒数）
current_time = time.time()
print(f"当前时间戳: {current_time}")  # 例如: 1625472603.1234567

# 获取当前时间的结构化时间（本地时间）
local_time = time.localtime()
print(f"当前本地时间: {local_time}")
# 输出类似: time.struct_time(tm_year=2023, tm_mon=7, tm_mday=5, tm_hour=14, tm_min=10, tm_sec=3, tm_wday=2, tm_yday=186, tm_isdst=0)

# 获取当前UTC时间的结构化时间
utc_time = time.gmtime()
print(f"当前UTC时间: {utc_time}")
```

### 时间戳与结构化时间转换

```python
# 将时间戳转换为结构化时间
timestamp = 1625472603
struct_time = time.localtime(timestamp)
print(struct_time)

# 将结构化时间转换为时间戳
timestamp = time.mktime(struct_time)
print(timestamp)
```

### 时间格式化

```python
# 将结构化时间转换为字符串
formatted_time = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
print(f"格式化时间: {formatted_time}")  # 例如: 2023-07-05 14:10:03

# 将字符串解析为结构化时间
time_string = "2023-07-05 14:10:03"
parsed_time = time.strptime(time_string, "%Y-%m-%d %H:%M:%S")
print(parsed_time)
```

常用的格式化指令：

| 指令 | 含义 | 示例 |
|------|------|------|
| `%Y` | 四位数的年份 | 2023 |
| `%m` | 月份（01-12） | 07 |
| `%d` | 日期（01-31） | 05 |
| `%H` | 24小时制的小时（00-23） | 14 |
| `%I` | 12小时制的小时（01-12） | 02 |
| `%M` | 分钟（00-59） | 10 |
| `%S` | 秒（00-59） | 03 |
| `%a` | 简写的星期几名称 | Wed |
| `%A` | 完整的星期几名称 | Wednesday |
| `%b` | 简写的月份名称 | Jul |
| `%B` | 完整的月份名称 | July |
| `%c` | 完整的日期时间表示 | Wed Jul 5 14:10:03 2023 |
| `%p` | AM或PM | PM |
| `%Z` | 时区名称 | CST |

### 时间测量

```python
# 测量代码执行时间
start_time = time.time()
# 执行一些操作
time.sleep(1)  # 暂停1秒
end_time = time.time()
elapsed_time = end_time - start_time
print(f"执行时间: {elapsed_time:.6f}秒")

# 处理器时间
cpu_start = time.process_time()
# 执行一些操作
time.sleep(1)  # 这不会影响process_time的计数，因为进程处于睡眠状态
cpu_end = time.process_time()
cpu_time = cpu_end - cpu_start
print(f"CPU时间: {cpu_time:.6f}秒")  # 接近于0，因为sleep不消耗CPU时间

# 执行一个CPU密集型操作
cpu_start = time.process_time()
for i in range(10000000):
    pass
cpu_end = time.process_time()
cpu_time = cpu_end - cpu_start
print(f"CPU密集型操作时间: {cpu_time:.6f}秒")
```

### 其他常用函数

```python
# 暂停执行
print("开始")
time.sleep(2)  # 暂停2秒
print("2秒后")

# 获取格式化的当前时间
current_time_string = time.asctime()
print(f"当前时间: {current_time_string}")  # 例如: Wed Jul 5 14:10:03 2023

# 将时间戳转换为格式化字符串
timestamp = 1625472603
time_string = time.ctime(timestamp)
print(f"格式化时间戳: {time_string}")  # 例如: Mon Jul 5 14:10:03 2021
```

## datetime模块

`datetime`模块提供了处理日期和时间的类，比`time`模块更高级、更面向对象。

### 基本类型

`datetime`模块定义了以下主要类型：

- `datetime.date`：处理年、月、日
- `datetime.time`：处理时、分、秒、微秒
- `datetime.datetime`：处理日期和时间
- `datetime.timedelta`：表示时间间隔
- `datetime.tzinfo`：时区信息的抽象基类
- `datetime.timezone`：具体的时区实现

### 创建日期和时间对象

```python
from datetime import date, time, datetime, timedelta

# 创建日期对象
today = date.today()
print(f"今天: {today}")  # 例如: 2023-07-05

specific_date = date(2023, 7, 5)
print(f"指定日期: {specific_date}")  # 2023-07-05

# 创建时间对象
current_time = time(14, 30, 0)
print(f"当前时间: {current_time}")  # 14:30:00

# 创建日期时间对象
now = datetime.now()
print(f"现在: {now}")  # 例如: 2023-07-05 14:30:00.123456

specific_datetime = datetime(2023, 7, 5, 14, 30, 0)
print(f"指定日期时间: {specific_datetime}")  # 2023-07-05 14:30:00
```

### 获取日期和时间的属性

```python
# 日期属性
today = date.today()
print(f"年: {today.year}")
print(f"月: {today.month}")
print(f"日: {today.day}")
print(f"星期几（0=周一，6=周日）: {today.weekday()}")
print(f"星期几（1=周一，7=周日）: {today.isoweekday()}")

# 时间属性
now = datetime.now()
print(f"时: {now.hour}")
print(f"分: {now.minute}")
print(f"秒: {now.second}")
print(f"微秒: {now.microsecond}")
```

### 日期时间计算

```python
from datetime import datetime, timedelta

# 获取当前日期时间
now = datetime.now()

# 创建一个时间间隔
one_day = timedelta(days=1)
one_week = timedelta(weeks=1)
one_hour = timedelta(hours=1)
complex_delta = timedelta(days=2, hours=3, minutes=30, seconds=15)

# 日期时间加减
tomorrow = now + one_day
print(f"明天: {tomorrow}")

last_week = now - one_week
print(f"上周: {last_week}")

future_time = now + complex_delta
print(f"未来时间: {future_time}")

# 计算两个日期之间的差异
date1 = datetime(2023, 7, 5)
date2 = datetime(2023, 8, 10)
diff = date2 - date1
print(f"相差的天数: {diff.days}")  # 36
print(f"相差的总秒数: {diff.total_seconds()}")  # 3110400.0
```

### 日期时间格式化

```python
from datetime import datetime

now = datetime.now()

# 将日期时间格式化为字符串
formatted = now.strftime("%Y-%m-%d %H:%M:%S")
print(f"格式化日期时间: {formatted}")  # 例如: 2023-07-05 14:30:00

# 使用ISO格式
iso_format = now.isoformat()
print(f"ISO格式: {iso_format}")  # 例如: 2023-07-05T14:30:00.123456

# 解析字符串为日期时间
date_string = "2023-07-05 14:30:00"
parsed_date = datetime.strptime(date_string, "%Y-%m-%d %H:%M:%S")
print(f"解析的日期时间: {parsed_date}")  # 2023-07-05 14:30:00
```

### 时区处理

```python
from datetime import datetime, timedelta, timezone

# 创建带有UTC时区的日期时间
utc_now = datetime.now(timezone.utc)
print(f"UTC时间: {utc_now}")

# 创建带有指定时区偏移的日期时间
offset = timedelta(hours=8)  # UTC+8
beijing_tz = timezone(offset)
beijing_now = datetime.now(beijing_tz)
print(f"北京时间: {beijing_now}")

# 时区转换
utc_time = datetime.now(timezone.utc)
beijing_time = utc_time.astimezone(beijing_tz)
print(f"转换为北京时间: {beijing_time}")

# 获取不带时区的日期时间
naive_datetime = datetime.now()
print(f"不带时区的日期时间: {naive_datetime}")

# 将不带时区的日期时间转换为带时区的
aware_datetime = naive_datetime.replace(tzinfo=timezone.utc)
print(f"带UTC时区的日期时间: {aware_datetime}")
```

### 与时间戳的转换

```python
from datetime import datetime
import time

# 获取当前时间戳
timestamp = time.time()
print(f"当前时间戳: {timestamp}")

# 将时间戳转换为datetime对象
dt_from_timestamp = datetime.fromtimestamp(timestamp)
print(f"从时间戳转换: {dt_from_timestamp}")

# 将datetime对象转换为时间戳
dt = datetime.now()
timestamp_from_dt = dt.timestamp()
print(f"转换为时间戳: {timestamp_from_dt}")
```

## calendar模块

`calendar`模块提供了与日历相关的功能，如打印日历、判断闰年等。

### 基本使用

```python
import calendar

# 打印月份日历
print(calendar.month(2023, 7))

# 打印整年日历
# print(calendar.calendar(2023))  # 输出较长，可能需要滚动查看

# 检查是否为闰年
is_leap = calendar.isleap(2024)
print(f"2024是闰年吗? {is_leap}")  # True

# 获取指定年份的闰年数量
leap_count = calendar.leapdays(2000, 2050)
print(f"2000年到2050年之间的闰年数量: {leap_count}")

# 获取指定月份的第一天是星期几（0=星期一，6=星期日）
first_weekday, num_days = calendar.monthrange(2023, 7)
print(f"2023年7月第一天是星期{first_weekday + 1}，该月有{num_days}天")

# 设置每周的第一天（0=星期一，6=星期日）
calendar.setfirstweekday(calendar.SUNDAY)  # 设置为星期日
print(calendar.month(2023, 7))  # 现在星期日是每周的第一天
```

### 迭代月份的日期

```python
import calendar
from datetime import date

# 获取指定月份的所有日期
def get_month_days(year, month):
    _, num_days = calendar.monthrange(year, month)
    return [date(year, month, day) for day in range(1, num_days + 1)]

july_2023 = get_month_days(2023, 7)
for day in july_2023[:7]:  # 只显示前7天
    print(day)
```

### TextCalendar和HTMLCalendar

```python
import calendar

# 创建文本日历
text_cal = calendar.TextCalendar(calendar.SUNDAY)  # 星期日作为每周第一天
text_cal_str = text_cal.formatmonth(2023, 7)
print(text_cal_str)

# 创建HTML日历
html_cal = calendar.HTMLCalendar(calendar.SUNDAY)
html_cal_str = html_cal.formatmonth(2023, 7)
# print(html_cal_str)  # 会输出HTML标记，可以保存到文件中或在浏览器中查看

# 保存HTML日历到文件
with open('calendar_2023_07.html', 'w') as f:
    f.write(html_cal_str)
```

## 实际应用场景

### 日期范围生成

```python
from datetime import datetime, timedelta

def date_range(start_date, end_date, step=timedelta(days=1)):
    """生成指定日期范围内的所有日期"""
    current_date = start_date
    while current_date <= end_date:
        yield current_date
        current_date += step

# 生成一个月的所有日期
start = datetime(2023, 7, 1)
end = datetime(2023, 7, 31)

for date in date_range(start, end):
    print(date.strftime("%Y-%m-%d"))
```

### 年龄计算

```python
from datetime import date

def calculate_age(birth_date):
    """计算年龄"""
    today = date.today()
    age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))
    return age

# 计算一个人的年龄
birth_date = date(1990, 5, 15)
age = calculate_age(birth_date)
print(f"年龄: {age}岁")
```

### 倒计时计算

```python
from datetime import datetime, timedelta

def countdown(target_date):
    """计算到目标日期的剩余时间"""
    now = datetime.now()
    time_left = target_date - now
    
    # 如果目标日期已经过去
    if time_left.total_seconds() <= 0:
        return "目标日期已过"
    
    days = time_left.days
    hours, remainder = divmod(time_left.seconds, 3600)
    minutes, seconds = divmod(remainder, 60)
    
    return f"剩余: {days}天 {hours}小时 {minutes}分钟 {seconds}秒"

# 计算到新年的倒计时
new_year = datetime(datetime.now().year + 1, 1, 1)
print(countdown(new_year))
```

### 计算工作日

```python
from datetime import datetime, timedelta
import calendar

def is_workday(date):
    """判断是否为工作日（假设周一到周五为工作日）"""
    return date.weekday() < 5  # 0-4 表示周一到周五

def count_workdays(start_date, end_date):
    """计算两个日期之间的工作日数量"""
    workdays = 0
    current_date = start_date
    
    while current_date <= end_date:
        if is_workday(current_date):
            workdays += 1
        current_date += timedelta(days=1)
    
    return workdays

# 计算一个月内的工作日数量
start = datetime(2023, 7, 1)
end = datetime(2023, 7, 31)
workdays = count_workdays(start, end)
print(f"2023年7月的工作日数量: {workdays}天")
```

### 日期时间解析和格式化

```python
from datetime import datetime
import locale

# 设置本地化（显示中文月份名称等）
try:
    locale.setlocale(locale.LC_TIME, 'zh_CN.UTF-8')  # 可能需要系统支持
except locale.Error:
    pass  # 忽略错误，使用默认区域设置

# 格式化日期时间为不同格式
now = datetime.now()

formats = [
    "%Y-%m-%d %H:%M:%S",  # 标准格式: 2023-07-05 14:30:00
    "%d/%m/%Y",           # 日/月/年: 05/07/2023
    "%B %d, %Y",          # 月份名 日, 年: July 05, 2023
    "%Y年%m月%d日",       # 中文格式: 2023年07月05日
    "%a, %d %b %Y",       # 缩写星期, 日 缩写月份 年: Wed, 05 Jul 2023
    "%I:%M %p",           # 12小时制: 02:30 PM
]

for fmt in formats:
    print(f"格式 '{fmt}': {now.strftime(fmt)}")

# 解析不同格式的日期时间
date_strings = [
    "2023-07-05 14:30:00",
    "05/07/2023",
    "July 05, 2023",
    "Wed, 05 Jul 2023 14:30:00",
]

formats = [
    "%Y-%m-%d %H:%M:%S",
    "%d/%m/%Y",
    "%B %d, %Y",
    "%a, %d %b %Y %H:%M:%S",
]

for date_str, fmt in zip(date_strings, formats):
    try:
        parsed_date = datetime.strptime(date_str, fmt)
        print(f"'{date_str}' 解析为: {parsed_date}")
    except ValueError as e:
        print(f"无法解析 '{date_str}': {e}")
```

## 处理重复事件

```python
from datetime import datetime, timedelta

def generate_recurring_events(start_date, end_date, interval_days):
    """生成定期事件"""
    events = []
    current_date = start_date
    
    while current_date <= end_date:
        events.append(current_date)
        current_date += timedelta(days=interval_days)
    
    return events

# 生成每周一次的会议（从现在开始的5次）
now = datetime.now().replace(hour=10, minute=0, second=0, microsecond=0)  # 今天上午10点
events = generate_recurring_events(now, now + timedelta(days=35), 7)

print("未来5次每周会议:")
for i, event in enumerate(events[:5], 1):
    print(f"会议 {i}: {event.strftime('%Y-%m-%d %H:%M')}")
```

## 时区处理高级案例

```python
from datetime import datetime
import pytz  # 需要安装: pip install pytz

# 创建带有指定时区的日期时间
utc_now = datetime.now(pytz.UTC)
print(f"UTC时间: {utc_now}")

# 获取特定时区的当前时间
timezone_names = ['Asia/Shanghai', 'America/New_York', 'Europe/London', 'Australia/Sydney']

for tz_name in timezone_names:
    tz = pytz.timezone(tz_name)
    local_time = datetime.now(tz)
    print(f"{tz_name}: {local_time}")

# 时区转换
utc_time = datetime.now(pytz.UTC)
print(f"UTC时间: {utc_time}")

beijing_time = utc_time.astimezone(pytz.timezone('Asia/Shanghai'))
print(f"北京时间: {beijing_time}")

ny_time = utc_time.astimezone(pytz.timezone('America/New_York'))
print(f"纽约时间: {ny_time}")

# 比较不同时区的时间
meeting_time_ny = datetime(2023, 7, 5, 9, 0, 0, tzinfo=pytz.timezone('America/New_York'))
print(f"纽约会议时间: {meeting_time_ny}")

meeting_time_beijing = meeting_time_ny.astimezone(pytz.timezone('Asia/Shanghai'))
print(f"对应的北京时间: {meeting_time_beijing}")
```

## 性能考虑

在处理大量日期时间操作时，需要注意性能问题：

```python
import time
from datetime import datetime, timedelta

# 比较不同方法的性能
def benchmark(func, n=100000):
    start = time.time()
    for _ in range(n):
        func()
    end = time.time()
    return end - start

# 使用time.time()
def use_time_time():
    return time.time()

# 使用datetime.now()
def use_datetime_now():
    return datetime.now()

# 使用时间戳计算时间差
def calc_with_timestamp():
    start = time.time()
    end = time.time()
    return end - start

# 使用timedelta计算时间差
def calc_with_timedelta():
    start = datetime.now()
    end = datetime.now()
    return (end - start).total_seconds()

print(f"time.time() (100000次): {benchmark(use_time_time):.6f}秒")
print(f"datetime.now() (100000次): {benchmark(use_datetime_now):.6f}秒")
print(f"使用时间戳计算差值 (100000次): {benchmark(calc_with_timestamp):.6f}秒")
print(f"使用timedelta计算差值 (100000次): {benchmark(calc_with_timedelta):.6f}秒")
```

## 常见错误和最佳实践

### 常见错误

1. **忽略时区**：处理跨时区数据时忽略时区信息可能导致严重错误。
2. **混用带时区和不带时区的日期时间**：这可能导致比较或计算时出现意外结果。
3. **不考虑DST（夏令时）**：在有夏令时的地区，一年中某些日期可能不存在或出现两次。
4. **硬编码日期格式**：不同地区和语言的日期格式差异很大。

### 最佳实践

1. **始终使用明确的时区**：处理跨时区数据时，最好使用UTC时间，并在显示时转换为本地时区。
2. **使用ISO 8601格式**：对于数据交换和存储，使用标准化的格式如`YYYY-MM-DDTHH:MM:SS+00:00`。
3. **使用datetime代替time模块**：`datetime`模块提供了更多功能和更好的面向对象接口。
4. **使用第三方库**：对于复杂的时间日期处理，考虑使用`pytz`、`dateutil`等第三方库。
5. **避免使用字符串**：尽量在内部使用`datetime`对象，仅在输入和输出时进行格式转换。
6. **使用timedelta进行日期计算**：使用`timedelta`进行日期加减，而不是手动计算。
7. **注意闰年和月份长度**：月份有不同的天数，闰年的二月有29天。
8. **考虑国际化**：根据用户的区域设置，使用适当的日期格式和语言。

Python的时间和日期处理库提供了丰富的功能，可以满足各种应用场景的需求。通过合理选择和组合这些功能，可以轻松实现各种时间和日期相关的任务。
