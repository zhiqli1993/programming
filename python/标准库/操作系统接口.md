# Python操作系统接口

Python提供了多个模块用于与操作系统交互，其中最核心的是`os`模块。此外，还有`pathlib`、`shutil`等模块提供了更高级的功能。本文详细介绍Python中操作系统接口的使用方法。

## os模块

`os`模块提供了许多与操作系统交互的功能，包括文件操作、进程管理、环境变量访问等。

### 基本导入

```python
import os
```

### 路径操作

```python
# 获取当前工作目录
current_dir = os.getcwd()
print(current_dir)  # 例如: /home/user/projects

# 修改当前工作目录
os.chdir('/tmp')
print(os.getcwd())  # /tmp

# 路径拼接(推荐使用os.path.join而非直接字符串拼接)
data_path = os.path.join('data', 'processed', 'results.csv')
print(data_path)  # data/processed/results.csv (Unix) 或 data\processed\results.csv (Windows)

# 获取绝对路径
abs_path = os.path.abspath('data.txt')
print(abs_path)  # /tmp/data.txt

# 规范化路径(解析..和.)
norm_path = os.path.normpath('/home/user/../tmp/./data.txt')
print(norm_path)  # /home/tmp/data.txt

# 获取目录和文件名
dirname = os.path.dirname('/home/user/file.txt')
print(dirname)  # /home/user

filename = os.path.basename('/home/user/file.txt')
print(filename)  # file.txt

# 分割路径
dir_part, file_part = os.path.split('/home/user/file.txt')
print(dir_part, file_part)  # /home/user file.txt

# 分割文件名和扩展名
name, ext = os.path.splitext('file.txt')
print(name, ext)  # file .txt
```

### 文件和目录操作

```python
# 检查路径是否存在
exists = os.path.exists('/path/to/file')
print(exists)  # True 或 False

# 检查是文件还是目录
is_file = os.path.isfile('/path/to/file')
is_dir = os.path.isdir('/path/to/dir')

# 检查访问权限
can_read = os.access('/path/to/file', os.R_OK)
can_write = os.access('/path/to/file', os.W_OK)
can_execute = os.access('/path/to/file', os.X_OK)

# 获取文件/目录信息
file_size = os.path.getsize('/path/to/file')  # 文件大小(字节)
mod_time = os.path.getmtime('/path/to/file')  # 修改时间(Unix时间戳)
create_time = os.path.getctime('/path/to/file')  # 创建时间

# 创建目录
os.mkdir('new_directory')  # 创建单个目录
os.makedirs('nested/directories/path', exist_ok=True)  # 递归创建目录，exist_ok=True表示已存在时不报错

# 删除文件和目录
os.remove('file.txt')  # 删除文件
os.rmdir('empty_directory')  # 删除空目录
```

### 列出目录内容

```python
# 列出目录中的文件和子目录
entries = os.listdir('.')
print(entries)  # ['file1.txt', 'file2.txt', 'subdir', ...]

# 使用os.scandir()获取更多信息(Python 3.5+)
with os.scandir('.') as entries:
    for entry in entries:
        print(entry.name, entry.is_file(), entry.is_dir(), entry.stat().st_size)

# 使用glob模式匹配文件
import glob
python_files = glob.glob('*.py')
print(python_files)  # ['script1.py', 'script2.py', ...]
```

### 执行外部命令

```python
# 使用os.system()执行命令(不推荐，返回退出状态码)
status = os.system('ls -l')

# 使用subprocess模块(推荐)
import subprocess

# 简单命令执行，返回完整输出
result = subprocess.run(['ls', '-l'], capture_output=True, text=True)
print(result.stdout)
print(f"Exit code: {result.returncode}")

# 使用shell特性(管道、重定向等)
result = subprocess.run('ls -l | grep ".py"', shell=True, capture_output=True, text=True)
print(result.stdout)

# 更复杂的交互
process = subprocess.Popen(['python', '-c', 'print("Hello from subprocess")'],
                          stdout=subprocess.PIPE,
                          stderr=subprocess.PIPE,
                          text=True)
stdout, stderr = process.communicate()
print(f"Output: {stdout}")
print(f"Error: {stderr}")
print(f"Exit code: {process.returncode}")
```

### 环境变量

```python
# 获取所有环境变量
all_env = os.environ
print(all_env)  # 类似字典的对象，包含所有环境变量

# 获取特定环境变量
home = os.environ.get('HOME', '')  # 第二个参数是默认值
print(f"Home directory: {home}")

path = os.environ.get('PATH', '')
path_list = path.split(os.pathsep)  # 使用os.pathsep分割路径(Unix是:，Windows是;)
print(f"PATH entries: {path_list}")

# 设置环境变量
os.environ['MY_VARIABLE'] = 'my_value'
print(os.environ.get('MY_VARIABLE'))  # my_value

# 删除环境变量
if 'MY_VARIABLE' in os.environ:
    del os.environ['MY_VARIABLE']
```

### 进程管理

```python
# 获取当前进程ID
pid = os.getpid()
print(f"Current process ID: {pid}")

# 获取父进程ID
ppid = os.getppid()
print(f"Parent process ID: {ppid}")

# 创建子进程(Unix特有，Windows下不可用)
try:
    child_pid = os.fork()
    if child_pid == 0:
        # 子进程代码
        print(f"Child process, PID: {os.getpid()}")
        os._exit(0)
    else:
        # 父进程代码
        print(f"Parent process, Child PID: {child_pid}")
        os.waitpid(child_pid, 0)  # 等待子进程结束
except AttributeError:
    print("fork() not available on this platform")

# 使用subprocess创建进程(跨平台)
process = subprocess.Popen(['python', '-c', 'import os; print(os.getpid())'])
process.wait()  # 等待进程结束

# 退出程序
# os._exit(0)  # 立即退出，不清理资源
# sys.exit(0)  # 抛出SystemExit异常，允许清理资源
```

### 文件描述符操作

```python
# 打开文件并获取文件描述符
fd = os.open('file.txt', os.O_RDWR | os.O_CREAT)

# 读取数据
data = os.read(fd, 100)  # 读取最多100字节
print(data)

# 写入数据
bytes_written = os.write(fd, b'Hello, world!')
print(f"Wrote {bytes_written} bytes")

# 移动文件指针
os.lseek(fd, 0, os.SEEK_SET)  # 回到文件开头

# 关闭文件描述符
os.close(fd)
```

### 文件权限和所有权

```python
# 修改文件权限
os.chmod('file.txt', 0o755)  # rwxr-xr-x

# 修改文件所有者(Unix系统，需要权限)
try:
    os.chown('file.txt', 1000, 1000)  # uid, gid
except PermissionError:
    print("Permission denied when changing ownership")
except AttributeError:
    print("chown() not available on this platform")
```

## pathlib模块

`pathlib`模块(Python 3.4+)提供了面向对象的文件系统路径接口，比传统的字符串路径和`os.path`函数更现代化和方便。

```python
from pathlib import Path

# 创建路径对象
p = Path('.')
home = Path.home()
root = Path('/')

# 路径拼接
data_file = home / 'data' / 'file.txt'
print(data_file)  # /home/user/data/file.txt

# 获取路径的各个部分
print(data_file.name)          # file.txt
print(data_file.stem)          # file
print(data_file.suffix)        # .txt
print(data_file.parent)        # /home/user/data
print(data_file.parents[0])    # /home/user/data
print(data_file.parents[1])    # /home/user

# 解析路径
resolved = data_file.resolve()  # 解析为绝对路径，处理符号链接
print(resolved)

# 检查路径状态
print(data_file.exists())      # 检查是否存在
print(data_file.is_file())     # 检查是否为文件
print(data_file.is_dir())      # 检查是否为目录
print(data_file.is_symlink())  # 检查是否为符号链接

# 获取路径信息
if data_file.exists():
    stats = data_file.stat()
    print(f"Size: {stats.st_size} bytes")
    print(f"Mode: {stats.st_mode}")
    print(f"Modified: {stats.st_mtime}")

# 列出目录内容
desktop = Path.home() / 'Desktop'
if desktop.exists():
    for item in desktop.iterdir():
        print(item)
    
    # 使用glob模式匹配
    for py_file in desktop.glob('*.py'):
        print(f"Python file: {py_file}")
    
    # 递归搜索
    for py_file in desktop.rglob('*.py'):
        print(f"Python file (recursive): {py_file}")

# 创建目录
new_dir = Path('new_directory')
new_dir.mkdir(exist_ok=True)

nested_dir = Path('nested/path/to/dir')
nested_dir.mkdir(parents=True, exist_ok=True)  # 创建所有必要的父目录

# 读写文本文件
hello_file = Path('hello.txt')
hello_file.write_text('Hello, pathlib!')  # 一次性写入文本
content = hello_file.read_text()          # 一次性读取文本
print(content)

# 读写二进制文件
binary_file = Path('data.bin')
binary_file.write_bytes(b'\x00\x01\x02\x03')
binary_data = binary_file.read_bytes()
print(binary_data)

# 删除文件或目录
if hello_file.exists():
    hello_file.unlink()  # 删除文件

if new_dir.exists() and new_dir.is_dir():
    try:
        new_dir.rmdir()  # 只能删除空目录
    except OSError as e:
        print(f"Could not remove directory: {e}")

# 重命名或移动文件/目录
source = Path('source.txt')
source.write_text('test content')
target = Path('target.txt')
source.rename(target)
```

## shutil模块

`shutil`模块提供了高级文件操作，如复制、移动、删除文件和目录。

```python
import shutil

# 复制文件
shutil.copy('source.txt', 'dest.txt')            # 复制文件内容
shutil.copy2('source.txt', 'dest.txt')           # 复制文件内容和元数据(如修改时间)

# 复制目录
shutil.copytree('src_dir', 'dst_dir')            # 递归复制整个目录

# 移动文件或目录
shutil.move('source.txt', 'new_location.txt')    # 移动文件或目录

# 删除目录及其内容
shutil.rmtree('dir_to_remove')                   # 删除目录和其中所有内容(谨慎使用!)

# 获取磁盘使用情况
total, used, free = shutil.disk_usage('/')
print(f"Total: {total / (2**30):.2f} GB")
print(f"Used: {used / (2**30):.2f} GB")
print(f"Free: {free / (2**30):.2f} GB")

# 归档操作
shutil.make_archive('archive', 'zip', 'directory_to_compress')  # 创建zip归档
shutil.unpack_archive('archive.zip', 'extract_dir')             # 解压归档

# 查找可执行文件路径
python_path = shutil.which('python')
print(f"Python executable: {python_path}")
```

## tempfile模块

`tempfile`模块用于创建临时文件和目录。

```python
import tempfile
import os

# 创建临时文件
with tempfile.NamedTemporaryFile(suffix='.txt', prefix='temp_', delete=True) as temp:
    temp.write(b'Hello, temporary file!')
    temp.flush()  # 确保数据写入磁盘
    
    print(f"Temporary file name: {temp.name}")
    
    # 临时文件在with块结束时自动删除(如果delete=True)

# 创建临时目录
with tempfile.TemporaryDirectory() as temp_dir:
    print(f"Temporary directory: {temp_dir}")
    
    # 在临时目录中创建文件
    temp_file_path = os.path.join(temp_dir, 'temp_file.txt')
    with open(temp_file_path, 'w') as f:
        f.write('Content in temporary directory')
    
    # 临时目录及其内容在with块结束时自动删除

# 不使用上下文管理器
temp_fd, temp_path = tempfile.mkstemp(text=True)
try:
    # 使用文件描述符
    os.write(temp_fd, b'Using file descriptor\n')
    
    # 或者使用文件路径
    with open(temp_path, 'a') as f:
        f.write('Appending to temp file\n')
    
    print(f"Temp file created: {temp_path}")
finally:
    os.close(temp_fd)     # 关闭文件描述符
    os.unlink(temp_path)  # 删除临时文件
```

## 文件系统监控

### watchdog

`watchdog`是一个第三方库，用于监控文件系统事件。

```python
# 安装: pip install watchdog
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import time

class MyHandler(FileSystemEventHandler):
    def on_created(self, event):
        print(f"Created: {event.src_path}")
    
    def on_deleted(self, event):
        print(f"Deleted: {event.src_path}")
    
    def on_modified(self, event):
        print(f"Modified: {event.src_path}")
    
    def on_moved(self, event):
        print(f"Moved: from {event.src_path} to {event.dest_path}")

def watch_directory(path):
    event_handler = MyHandler()
    observer = Observer()
    observer.schedule(event_handler, path, recursive=True)
    observer.start()
    
    try:
        print(f"Monitoring directory: {path}")
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    
    observer.join()

# 使用示例
if __name__ == "__main__":
    watch_directory(".")
```

## 跨平台考虑

Python的操作系统接口在设计时考虑了跨平台兼容性，但不同操作系统之间仍有差异。

### 路径分隔符

```python
import os

# 路径分隔符
print(f"路径分隔符: {os.sep}")  # Unix为'/'，Windows为'\'

# 环境变量路径分隔符
print(f"环境变量路径分隔符: {os.pathsep}")  # Unix为':'，Windows为';'

# 行尾符
print(f"行尾符: {os.linesep}")  # Unix为'\n'，Windows为'\r\n'
```

### 平台判断

```python
import sys
import platform

# 检查操作系统类型
if sys.platform.startswith('win'):
    print("Running on Windows")
elif sys.platform.startswith('linux'):
    print("Running on Linux")
elif sys.platform.startswith('darwin'):
    print("Running on macOS")
else:
    print(f"Running on {sys.platform}")

# 更详细的平台信息
print(f"平台: {platform.platform()}")
print(f"系统: {platform.system()}")
print(f"版本: {platform.version()}")
print(f"架构: {platform.architecture()}")
print(f"处理器: {platform.processor()}")
```

### 跨平台最佳实践

1. **使用os.path.join()或pathlib进行路径拼接**
   
   ```python
   # 不好的做法
   path = dir_name + '/' + file_name  # 在Windows上可能不工作
   
   # 好的做法
   path = os.path.join(dir_name, file_name)
   
   # 更现代的做法
   from pathlib import Path
   path = Path(dir_name) / file_name
   ```

2. **避免硬编码路径分隔符**
   
   ```python
   # 不好的做法
   files = [f for f in os.listdir('.') if f.endswith('.py')]
   
   # 好的做法
   files = [f for f in os.listdir('.') if os.path.splitext(f)[1] == '.py']
   
   # 更现代的做法
   files = list(Path('.').glob('*.py'))
   ```

3. **使用os.path或pathlib检查路径存在性**
   
   ```python
   # 使用os.path
   if os.path.exists(path) and os.path.isfile(path):
       # 处理文件
       pass
   
   # 使用pathlib
   p = Path(path)
   if p.exists() and p.is_file():
       # 处理文件
       pass
   ```

4. **使用subprocess而非os.system执行命令**
   
   ```python
   # 不好的做法
   os.system('mkdir new_dir')
   
   # 好的做法
   subprocess.run(['mkdir', 'new_dir'], check=True)
   ```

## 常见操作系统任务示例

### 批量重命名文件

```python
import os
from pathlib import Path

def batch_rename(directory, old_ext, new_ext):
    """批量修改文件扩展名"""
    directory = Path(directory)
    count = 0
    
    for item in directory.iterdir():
        if item.is_file() and item.suffix == old_ext:
            new_name = item.with_suffix(new_ext)
            item.rename(new_name)
            count += 1
    
    return count

# 使用示例
renamed = batch_rename('/path/to/files', '.txt', '.md')
print(f"Renamed {renamed} files")
```

### 查找大文件

```python
import os
from pathlib import Path

def find_large_files(directory, min_size_mb=100):
    """查找大于指定大小的文件"""
    min_size_bytes = min_size_mb * 1024 * 1024
    large_files = []
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            path = os.path.join(root, file)
            try:
                size = os.path.getsize(path)
                if size >= min_size_bytes:
                    large_files.append((path, size))
            except (OSError, FileNotFoundError):
                continue
    
    # 按文件大小排序
    return sorted(large_files, key=lambda x: x[1], reverse=True)

# 使用示例
large_files = find_large_files('/path/to/search')
for path, size in large_files:
    print(f"{path}: {size / (1024 * 1024):.2f} MB")
```

### 监控目录变化并备份

```python
import os
import time
import shutil
from pathlib import Path
from datetime import datetime

def backup_on_change(source_dir, backup_dir, interval=60):
    """监控目录，当有变化时创建备份"""
    source_dir = Path(source_dir)
    backup_dir = Path(backup_dir)
    
    if not backup_dir.exists():
        backup_dir.mkdir(parents=True)
    
    last_mtime = {}
    
    # 初始扫描
    for path in source_dir.rglob('*'):
        if path.is_file():
            last_mtime[path] = path.stat().st_mtime
    
    while True:
        changes = False
        
        # 检查文件变化
        for path in source_dir.rglob('*'):
            if not path.is_file():
                continue
                
            current_mtime = path.stat().st_mtime
            
            if path not in last_mtime:
                # 新文件
                print(f"New file detected: {path}")
                changes = True
                last_mtime[path] = current_mtime
            elif current_mtime != last_mtime[path]:
                # 修改的文件
                print(f"File changed: {path}")
                changes = True
                last_mtime[path] = current_mtime
        
        # 检查删除的文件
        existing_files = set(p for p in source_dir.rglob('*') if p.is_file())
        for path in list(last_mtime.keys()):
            if path not in existing_files:
                print(f"File deleted: {path}")
                changes = True
                del last_mtime[path]
        
        # 如果有变化，创建备份
        if changes:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            backup_path = backup_dir / f"backup_{timestamp}"
            print(f"Creating backup at {backup_path}")
            
            shutil.copytree(source_dir, backup_path)
        
        # 等待下一个检查周期
        time.sleep(interval)

# 使用示例
# backup_on_change('/path/to/monitor', '/path/to/backups')
```

## 总结

Python提供了丰富的操作系统接口，使开发者能够方便地与操作系统交互：

1. **os模块**：提供基本的操作系统功能，如文件操作、进程管理、环境变量访问等
2. **pathlib模块**：提供面向对象的路径操作，是处理文件系统路径的现代方式
3. **shutil模块**：提供高级文件操作，如复制、移动、删除文件和目录
4. **tempfile模块**：用于创建临时文件和目录
5. **subprocess模块**：用于创建和管理子进程

在编写跨平台代码时，应当避免直接使用特定于操作系统的路径分隔符和命令，而是使用Python提供的跨平台抽象。

掌握这些模块和技术，可以帮助开发者编写高效、可靠的系统级Python应用程序，以及自动化各种系统管理任务。
