# Python命令行参数处理

命令行参数处理是编写实用Python脚本和应用程序的重要组成部分。通过命令行参数，用户可以在不修改代码的情况下控制程序的行为。本文详细介绍Python中处理命令行参数的多种方法和最佳实践。

## 基本命令行参数访问

Python提供了几种方式来访问命令行参数，从最基本的`sys.argv`到更高级的解析库。

### 使用sys.argv

最简单的方法是使用`sys.argv`列表，它包含了所有传递给Python脚本的命令行参数：

```python
import sys

def main():
    # sys.argv[0]是脚本名称
    script_name = sys.argv[0]
    
    # 获取其他参数
    arguments = sys.argv[1:]
    
    print(f"脚本名称: {script_name}")
    print(f"参数数量: {len(arguments)}")
    print("参数列表:")
    
    for i, arg in enumerate(arguments):
        print(f"  参数 {i+1}: {arg}")

if __name__ == "__main__":
    main()
```

使用示例：

```bash
$ python script.py arg1 arg2 --option value
脚本名称: script.py
参数数量: 4
参数列表:
  参数 1: arg1
  参数 2: arg2
  参数 3: --option
  参数 4: value
```

虽然`sys.argv`简单直接，但对于复杂的命令行界面，手动解析参数可能会变得繁琐且容易出错。

## 使用argparse模块

`argparse`是Python标准库中推荐的命令行解析模块，它提供了丰富的功能来定义参数、生成帮助信息以及处理错误。

### 基本使用

```python
import argparse

def main():
    # 创建解析器
    parser = argparse.ArgumentParser(description='一个示例命令行程序')
    
    # 添加位置参数
    parser.add_argument('filename', help='要处理的文件名')
    
    # 添加可选参数
    parser.add_argument('-o', '--output', help='输出文件名')
    parser.add_argument('-v', '--verbose', action='store_true', help='启用详细输出')
    
    # 解析参数
    args = parser.parse_args()
    
    # 使用参数
    print(f"处理文件: {args.filename}")
    
    if args.output:
        print(f"输出到: {args.output}")
    else:
        print("没有指定输出文件，使用标准输出")
    
    if args.verbose:
        print("详细模式已启用")

if __name__ == "__main__":
    main()
```

使用示例：

```bash
$ python script.py --help
usage: script.py [-h] [-o OUTPUT] [-v] filename

一个示例命令行程序

positional arguments:
  filename              要处理的文件名

optional arguments:
  -h, --help            show this help message and exit
  -o OUTPUT, --output OUTPUT
                        输出文件名
  -v, --verbose         启用详细输出

$ python script.py input.txt -o output.txt -v
处理文件: input.txt
输出到: output.txt
详细模式已启用
```

### 参数类型

`argparse`可以自动将参数转换为指定的类型：

```python
import argparse

def main():
    parser = argparse.ArgumentParser(description='类型转换示例')
    
    # 字符串类型（默认）
    parser.add_argument('--name', type=str, help='名称')
    
    # 整数类型
    parser.add_argument('--count', type=int, help='计数')
    
    # 浮点数类型
    parser.add_argument('--rate', type=float, help='比率')
    
    # 文件类型
    parser.add_argument('--input-file', type=argparse.FileType('r'), help='输入文件')
    parser.add_argument('--output-file', type=argparse.FileType('w'), help='输出文件')
    
    # 布尔标志
    parser.add_argument('--verbose', action='store_true', help='详细输出')
    
    args = parser.parse_args()
    
    # 使用转换后的参数
    if args.name:
        print(f"名称: {args.name} (类型: {type(args.name).__name__})")
    
    if args.count is not None:
        print(f"计数: {args.count} (类型: {type(args.count).__name__})")
    
    if args.rate is not None:
        print(f"比率: {args.rate} (类型: {type(args.rate).__name__})")
    
    if args.input_file:
        first_line = args.input_file.readline().strip()
        print(f"输入文件第一行: {first_line}")
        args.input_file.close()
    
    if args.output_file:
        args.output_file.write("这是输出内容\n")
        args.output_file.close()
        print("已写入输出文件")
    
    if args.verbose:
        print("详细模式已启用")

if __name__ == "__main__":
    main()
```

### 子命令

对于具有多个功能的复杂应用程序，可以使用子命令（类似于`git commit`、`git push`等）：

```python
import argparse

def commit_func(args):
    print(f"执行提交操作，消息: {args.message}")

def push_func(args):
    print(f"执行推送操作到远程: {args.remote}")
    if args.force:
        print("强制推送已启用")

def main():
    # 创建主解析器
    parser = argparse.ArgumentParser(description='版本控制系统示例')
    subparsers = parser.add_subparsers(dest='command', help='可用命令')
    
    # 创建提交命令解析器
    commit_parser = subparsers.add_parser('commit', help='提交更改')
    commit_parser.add_argument('-m', '--message', required=True, help='提交消息')
    commit_parser.set_defaults(func=commit_func)
    
    # 创建推送命令解析器
    push_parser = subparsers.add_parser('push', help='推送更改')
    push_parser.add_argument('remote', help='远程名称')
    push_parser.add_argument('-f', '--force', action='store_true', help='强制推送')
    push_parser.set_defaults(func=push_func)
    
    # 解析参数
    args = parser.parse_args()
    
    # 调用相应的函数
    if hasattr(args, 'func'):
        args.func(args)
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
```

使用示例：

```bash
$ python vcs.py commit -m "添加新功能"
执行提交操作，消息: 添加新功能

$ python vcs.py push origin -f
执行推送操作到远程: origin
强制推送已启用
```

### 参数组和互斥组

`argparse`支持参数分组和互斥参数：

```python
import argparse

def main():
    parser = argparse.ArgumentParser(description='参数组示例')
    
    # 创建参数组
    input_group = parser.add_argument_group('输入选项')
    input_group.add_argument('--input-file', help='输入文件路径')
    input_group.add_argument('--input-dir', help='输入目录路径')
    
    output_group = parser.add_argument_group('输出选项')
    output_group.add_argument('--output-file', help='输出文件路径')
    output_group.add_argument('--output-format', choices=['txt', 'csv', 'json'], help='输出格式')
    
    # 创建互斥组
    mode_group = parser.add_mutually_exclusive_group(required=True)
    mode_group.add_argument('--analyze', action='store_true', help='分析模式')
    mode_group.add_argument('--process', action='store_true', help='处理模式')
    mode_group.add_argument('--visualize', action='store_true', help='可视化模式')
    
    args = parser.parse_args()
    
    # 处理模式
    if args.analyze:
        print("启动分析模式")
    elif args.process:
        print("启动处理模式")
    elif args.visualize:
        print("启动可视化模式")
    
    # 处理输入
    if args.input_file:
        print(f"使用输入文件: {args.input_file}")
    if args.input_dir:
        print(f"使用输入目录: {args.input_dir}")
    
    # 处理输出
    if args.output_file:
        print(f"输出到文件: {args.output_file}")
    if args.output_format:
        print(f"输出格式: {args.output_format}")

if __name__ == "__main__":
    main()
```

### 自定义参数类型和验证

可以创建自定义类型和验证函数：

```python
import argparse
import os
import re
from datetime import datetime

# 自定义类型函数
def valid_date(date_string):
    try:
        return datetime.strptime(date_string, "%Y-%m-%d")
    except ValueError:
        msg = f"无效的日期格式: '{date_string}'，应为YYYY-MM-DD"
        raise argparse.ArgumentTypeError(msg)

def existing_file(path):
    if not os.path.isfile(path):
        raise argparse.ArgumentTypeError(f"文件不存在: {path}")
    return path

def valid_email(email):
    pattern = r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$"
    if not re.match(pattern, email):
        raise argparse.ArgumentTypeError(f"无效的邮箱地址: {email}")
    return email

def positive_int(value):
    ivalue = int(value)
    if ivalue <= 0:
        raise argparse.ArgumentTypeError(f"需要正整数，得到: {value}")
    return ivalue

def main():
    parser = argparse.ArgumentParser(description='自定义类型和验证示例')
    
    parser.add_argument('--date', type=valid_date, help='日期 (YYYY-MM-DD)')
    parser.add_argument('--file', type=existing_file, help='现有文件路径')
    parser.add_argument('--email', type=valid_email, help='电子邮件地址')
    parser.add_argument('--count', type=positive_int, help='计数 (正整数)')
    
    args = parser.parse_args()
    
    if args.date:
        print(f"日期: {args.date.strftime('%Y-%m-%d')} (星期{args.date.strftime('%w')})")
    
    if args.file:
        print(f"文件: {args.file} (大小: {os.path.getsize(args.file)} 字节)")
    
    if args.email:
        user, domain = args.email.split('@')
        print(f"邮箱: 用户={user}, 域名={domain}")
    
    if args.count:
        print(f"计数: {args.count}")

if __name__ == "__main__":
    main()
```

## 使用click库

`click`是一个第三方库，它提供了比`argparse`更简洁的API，尤其适合创建复杂的命令行接口。

```bash
pip install click
```

### 基本使用

```python
import click

@click.command()
@click.argument('filename')
@click.option('--output', '-o', help='输出文件名')
@click.option('--verbose', '-v', is_flag=True, help='启用详细输出')
def process_file(filename, output, verbose):
    """处理指定的文件。"""
    click.echo(f"处理文件: {filename}")
    
    if output:
        click.echo(f"输出到: {output}")
    else:
        click.echo("没有指定输出文件，使用标准输出")
    
    if verbose:
        click.echo("详细模式已启用")

if __name__ == '__main__':
    process_file()
```

### 参数类型和验证

```python
import click
import os
from datetime import datetime

def validate_file(ctx, param, value):
    if value and not os.path.isfile(value):
        raise click.BadParameter(f"文件不存在: {value}")
    return value

@click.command()
@click.option('--count', type=click.IntRange(1, 10), help='计数 (1-10)')
@click.option('--name', prompt='请输入您的名字', help='用户名')
@click.option('--password', prompt=True, hide_input=True, confirmation_prompt=True, help='密码')
@click.option('--date', type=click.DateTime(formats=["%Y-%m-%d"]), help='日期 (YYYY-MM-DD)')
@click.option('--file', callback=validate_file, help='文件路径')
@click.option('--verbose', is_flag=True, help='启用详细输出')
def process(count, name, password, date, file, verbose):
    """示例命令行应用程序。"""
    click.echo(f"计数: {count}")
    click.echo(f"用户名: {name}")
    
    # 不显示密码
    click.echo("密码已设置" if password else "密码未设置")
    
    if date:
        click.echo(f"日期: {date.strftime('%Y-%m-%d')}")
    
    if file:
        click.echo(f"文件: {file} (大小: {os.path.getsize(file)} 字节)")
    
    if verbose:
        click.echo("详细模式已启用")

if __name__ == '__main__':
    process()
```

### 命令组和子命令

```python
import click

@click.group()
def cli():
    """版本控制系统示例。"""
    pass

@cli.command()
@click.option('--message', '-m', required=True, help='提交消息')
def commit(message):
    """提交更改。"""
    click.echo(f"执行提交操作，消息: {message}")

@cli.command()
@click.argument('remote')
@click.option('--force', '-f', is_flag=True, help='强制推送')
def push(remote, force):
    """推送更改到指定的远程。"""
    click.echo(f"执行推送操作到远程: {remote}")
    if force:
        click.echo("强制推送已启用")

@cli.command()
@click.argument('remote', required=False)
def pull(remote):
    """从远程拉取更改。"""
    if remote:
        click.echo(f"从远程 {remote} 拉取更改")
    else:
        click.echo("从默认远程拉取更改")

if __name__ == '__main__':
    cli()
```

### 进度条和彩色输出

```python
import click
import time

@click.command()
@click.option('--count', default=10, help='处理项数')
def process_with_progress(count):
    """演示进度条和彩色输出。"""
    # 彩色输出
    click.secho("开始处理...", fg="green")
    click.secho("警告：这只是一个演示", fg="yellow")
    click.secho("错误会显示为红色", fg="red")
    
    # 进度条
    with click.progressbar(range(count), label='处理进度') as bar:
        for i in bar:
            # 模拟处理
            time.sleep(0.2)
    
    # 确认提示
    if click.confirm('处理完成。是否显示报告?'):
        click.echo("这是报告内容...")
    
    # 选择提示
    language = click.prompt(
        '选择编程语言',
        type=click.Choice(['Python', 'JavaScript', 'Java', 'C++']),
        default='Python'
    )
    click.echo(f"您选择了: {language}")

if __name__ == '__main__':
    process_with_progress()
```

## 使用fire库

Google的`fire`库提供了一种不同的方法，它可以自动为Python对象（函数、类等）生成命令行接口，几乎不需要额外的配置。

```bash
pip install fire
```

### 将函数转换为命令行工具

```python
import fire

def hello(name="World"):
    return f"Hello {name}!"

def calculate(x, y, operation="add"):
    """执行数学运算。
    
    Args:
        x: 第一个数值
        y: 第二个数值
        operation: 运算类型 (add, subtract, multiply, divide)
    
    Returns:
        运算结果
    """
    if operation == "add":
        return x + y
    elif operation == "subtract":
        return x - y
    elif operation == "multiply":
        return x * y
    elif operation == "divide":
        return x / y
    else:
        return f"未知操作: {operation}"

if __name__ == '__main__':
    fire.Fire()
```

使用示例：

```bash
$ python script.py hello
Hello World!

$ python script.py hello --name=Alice
Hello Alice!

$ python script.py calculate 10 5
15

$ python script.py calculate 10 5 --operation=multiply
50

$ python script.py calculate --help
NAME
    script.py calculate - 执行数学运算。

SYNOPSIS
    script.py calculate X Y <flags>

DESCRIPTION
    执行数学运算。
    
    Args:
        x: 第一个数值
        y: 第二个数值
        operation: 运算类型 (add, subtract, multiply, divide)
    
    Returns:
        运算结果

FLAGS
    --operation=OPERATION
        Default: 'add'
```

### 将类转换为命令行工具

```python
import fire

class Calculator:
    """简单计算器。"""
    
    def add(self, x, y):
        """将两个数相加。"""
        return x + y
    
    def subtract(self, x, y):
        """从第一个数中减去第二个数。"""
        return x - y
    
    def multiply(self, x, y):
        """将两个数相乘。"""
        return x * y
    
    def divide(self, x, y):
        """将第一个数除以第二个数。"""
        return x / y

class GitTool:
    """简单的Git工具。"""
    
    def commit(self, message):
        """提交更改。"""
        return f"提交: {message}"
    
    def push(self, remote="origin", branch="master", force=False):
        """推送到远程。"""
        force_str = " (强制)" if force else ""
        return f"推送到 {remote}/{branch}{force_str}"

class CLI:
    """命令行工具集合。"""
    
    def __init__(self):
        self.calc = Calculator()
        self.git = GitTool()
    
    def echo(self, text):
        """回显文本。"""
        return text

if __name__ == '__main__':
    fire.Fire(CLI)
```

使用示例：

```bash
$ python script.py calc add 10 20
30

$ python script.py git commit "添加新功能"
提交: 添加新功能

$ python script.py git push --branch=develop --force=True
推送到 origin/develop (强制)

$ python script.py echo "Hello World"
Hello World
```

## 使用docopt库

`docopt`库使用帮助文档作为命令行界面的定义，这是一种更加声明式的方法。

```bash
pip install docopt
```

```python
"""Naval Fate.

Usage:
  naval_fate.py ship new <name>...
  naval_fate.py ship <name> move <x> <y> [--speed=<kn>]
  naval_fate.py ship shoot <x> <y>
  naval_fate.py mine (set|remove) <x> <y> [--moored | --drifting]
  naval_fate.py (-h | --help)
  naval_fate.py --version

Options:
  -h --help     显示此帮助信息
  --version     显示版本
  --speed=<kn>  速度，单位为节 [default: 10]
  --moored      锚定水雷
  --drifting    漂流水雷

"""

from docopt import docopt

if __name__ == '__main__':
    arguments = docopt(__doc__, version='Naval Fate 2.0')
    print(arguments)
    
    # 处理命令
    if arguments['ship'] and arguments['new']:
        names = arguments['<name>']
        print(f"创建新船: {', '.join(names)}")
    
    elif arguments['ship'] and arguments['move']:
        ship_name = arguments['<name>']
        x, y = arguments['<x>'], arguments['<y>']
        speed = arguments['--speed']
        print(f"移动船 {ship_name} 到位置 ({x}, {y})，速度 {speed} 节")
    
    elif arguments['ship'] and arguments['shoot']:
        x, y = arguments['<x>'], arguments['<y>']
        print(f"船射击位置 ({x}, {y})")
    
    elif arguments['mine']:
        action = 'set' if arguments['set'] else 'remove'
        x, y = arguments['<x>'], arguments['<y>']
        mine_type = '锚定' if arguments['--moored'] else '漂流' if arguments['--drifting'] else '普通'
        print(f"{action} {mine_type}水雷在位置 ({x}, {y})")
```

## 命令行参数最佳实践

### 遵循POSIX命令行约定

1. 短选项用单破折号和单个字母（如`-v`）
2. 长选项用双破折号和完整名称（如`--verbose`）
3. 选项可以分组（如`-xvf`等同于`-x -v -f`）
4. 使用`--`分隔选项和位置参数

### 命名和结构化建议

1. **命令和选项的一致性**：在整个程序中保持一致的命名风格
2. **使用常见约定**：如`-v/--verbose`用于详细输出，`-h/--help`用于帮助信息
3. **为每个命令提供帮助**：包括简短描述、用法和示例
4. **为复杂程序使用子命令**：类似于`git`、`docker`等工具
5. **合理分组参数**：相关功能的参数应该在帮助中一起显示

### 示例：综合应用最佳实践

```python
import argparse
import sys
import os

def create_parser():
    """创建一个遵循最佳实践的命令行解析器。"""
    # 主解析器
    parser = argparse.ArgumentParser(
        description='文件处理工具',
        epilog='示例: fileutil.py convert document.docx --to pdf --output document.pdf'
    )
    
    # 版本信息
    parser.add_argument('--version', action='version', version='%(prog)s 1.0.0')
    
    # 创建子命令
    subparsers = parser.add_subparsers(dest='command', help='可用命令')
    
    # "convert" 命令
    convert_parser = subparsers.add_parser(
        'convert', 
        help='转换文件格式',
        description='将文件从一种格式转换为另一种格式'
    )
    convert_parser.add_argument('source', help='源文件路径')
    convert_parser.add_argument('--to', required=True, help='目标格式')
    convert_parser.add_argument('--output', '-o', help='输出文件路径')
    convert_parser.add_argument('--quality', type=int, choices=range(1, 11), 
                                default=8, help='输出质量 (1-10)')
    
    # "analyze" 命令
    analyze_parser = subparsers.add_parser(
        'analyze', 
        help='分析文件',
        description='分析文件并生成报告'
    )
    analyze_parser.add_argument('path', help='文件或目录路径')
    analyze_parser.add_argument('--recursive', '-r', action='store_true', 
                                help='递归处理目录')
    analyze_parser.add_argument('--format', choices=['text', 'json', 'html'], 
                                default='text', help='报告格式')
    analyze_parser.add_argument('--output', '-o', help='报告输出路径')
    
    # 通用选项
    for subparser in [convert_parser, analyze_parser]:
        subparser.add_argument('--verbose', '-v', action='count', default=0, 
                               help='增加输出详细程度 (可多次使用)')
        subparser.add_argument('--quiet', '-q', action='store_true', 
                               help='抑制所有非错误输出')
    
    return parser

def validate_args(args):
    """验证解析后的参数。"""
    if not args.command:
        return "需要指定命令。使用 --help 查看可用命令。"
    
    if args.command == 'convert':
        if not os.path.isfile(args.source):
            return f"源文件不存在: {args.source}"
        
        if not args.output:
            args.output = f"{os.path.splitext(args.source)[0]}.{args.to.lower()}"
    
    elif args.command == 'analyze':
        if not os.path.exists(args.path):
            return f"指定的路径不存在: {args.path}"
        
        if args.recursive and not os.path.isdir(args.path):
            return "只能对目录使用 --recursive 选项"
    
    # 检查 verbose 和 quiet 的冲突
    if args.verbose > 0 and args.quiet:
        return "不能同时使用 --verbose 和 --quiet 选项"
    
    return None  # 没有错误

def set_verbosity(level, quiet):
    """设置输出详细程度。"""
    if quiet:
        return 0  # 静默模式
    
    return level + 1  # 详细级别（1-正常, 2-详细, 3-调试）

def convert_file(args, verbosity):
    """实现文件转换命令。"""
    if verbosity >= 1:
        print(f"转换文件: {args.source} 到 {args.to} 格式")
    if verbosity >= 2:
        print(f"输出文件: {args.output}")
        print(f"质量设置: {args.quality}")
    
    # 这里是实际的转换逻辑
    # ...
    
    if verbosity >= 1:
        print(f"转换完成。输出保存到: {args.output}")

def analyze_path(args, verbosity):
    """实现文件分析命令。"""
    if verbosity >= 1:
        print(f"分析路径: {args.path}")
        if args.recursive:
            print("使用递归模式")
    if verbosity >= 2:
        print(f"报告格式: {args.format}")
        if args.output:
            print(f"输出报告到: {args.output}")
    
    # 这里是实际的分析逻辑
    # ...
    
    if verbosity >= 1:
        print(f"分析完成")

def main():
    parser = create_parser()
    args = parser.parse_args()
    
    # 验证参数
    error = validate_args(args)
    if error:
        print(f"错误: {error}", file=sys.stderr)
        return 1
    
    # 设置详细程度
    verbosity = set_verbosity(args.verbose, args.quiet)
    
    # 执行相应的命令
    try:
        if args.command == 'convert':
            convert_file(args, verbosity)
        elif args.command == 'analyze':
            analyze_path(args, verbosity)
    except Exception as e:
        print(f"错误: {e}", file=sys.stderr)
        if verbosity >= 3:  # 调试模式
            import traceback
            traceback.print_exc()
        return 1
    
    return 0

if __name__ == "__main__":
    sys.exit(main())
```

## 总结

Python提供了多种处理命令行参数的方法，从基本的`sys.argv`到功能丰富的库：

1. **sys.argv**：最简单但功能有限
2. **argparse**：标准库，功能全面，适合大多数需求
3. **click**：第三方库，易用且功能强大，支持嵌套命令和丰富的输出格式
4. **fire**：自动为Python对象生成命令行界面，几乎不需要配置
5. **docopt**：使用帮助文档定义命令行界面，更加声明式

选择哪种方法取决于项目的复杂性和个人偏好：

- 对于简单脚本，`sys.argv`可能足够
- 对于中等复杂度的工具，`argparse`是一个很好的标准选择
- 对于需要更现代、更用户友好界面的应用，`click`是很好的选择
- 对于快速原型开发或内部工具，`fire`非常方便
- 对于喜欢声明式接口的开发者，`docopt`提供了一种独特的方法

无论选择哪种方法，遵循命令行界面的最佳实践都能使您的工具更加用户友好和专业。
