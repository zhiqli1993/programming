# Python数据库操作

数据库操作是编程中的重要组成部分，Python提供了多种方式来与各类数据库进行交互。本文详细介绍Python中数据库操作的方法、模块和最佳实践。

## Python数据库操作概述

Python可以连接几乎所有主流的数据库系统，包括：

1. **关系型数据库**：MySQL、PostgreSQL、SQLite、Oracle、SQL Server等
2. **NoSQL数据库**：MongoDB、Redis、Cassandra等
3. **内存数据库**：SQLite(内存模式)、Redis等

Python的数据库访问层次结构：

1. **低级API**：直接使用数据库驱动程序（如`sqlite3`、`pymysql`、`psycopg2`等）
2. **中间层API**：数据库抽象层（如`DB-API`规范）
3. **高级ORM**：对象关系映射（如`SQLAlchemy`、`Django ORM`、`Peewee`等）

## 使用SQLite

SQLite是一个嵌入式关系型数据库，Python标准库内置了对它的支持。

### 基本连接和操作

```python
import sqlite3

# 连接到数据库（如果不存在则创建）
conn = sqlite3.connect('example.db')

# 创建游标对象
cursor = conn.cursor()

# 创建表
cursor.execute('''
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    email TEXT UNIQUE,
    age INTEGER
)
''')

# 插入数据
cursor.execute("INSERT INTO users (name, email, age) VALUES (?, ?, ?)", 
               ("张三", "zhangsan@example.com", 25))

# 批量插入
users = [
    ("李四", "lisi@example.com", 30),
    ("王五", "wangwu@example.com", 28),
    ("赵六", "zhaoliu@example.com", 35)
]
cursor.executemany("INSERT INTO users (name, email, age) VALUES (?, ?, ?)", users)

# 提交事务
conn.commit()

# 查询数据
cursor.execute("SELECT * FROM users")
results = cursor.fetchall()
print("所有用户：")
for row in results:
    print(row)

# 条件查询
cursor.execute("SELECT * FROM users WHERE age > ?", (25,))
results = cursor.fetchall()
print("年龄大于25的用户：")
for row in results:
    print(row)

# 更新数据
cursor.execute("UPDATE users SET age = ? WHERE name = ?", (26, "张三"))
conn.commit()

# 删除数据
cursor.execute("DELETE FROM users WHERE name = ?", ("赵六",))
conn.commit()

# 关闭连接
cursor.close()
conn.close()
```

### 使用上下文管理器

```python
import sqlite3

with sqlite3.connect('example.db') as conn:
    cursor = conn.cursor()
    
    # 查询数据
    cursor.execute("SELECT * FROM users")
    
    # 使用列名访问
    column_names = [description[0] for description in cursor.description]
    
    for row in cursor.fetchall():
        # 将行转换为字典
        user = dict(zip(column_names, row))
        print(f"用户: {user['name']}, 邮箱: {user['email']}, 年龄: {user['age']}")
```

### SQLite事务管理

```python
import sqlite3

def transfer_money(conn, from_account, to_account, amount):
    """转账函数，演示事务操作"""
    try:
        cursor = conn.cursor()
        
        # 开始事务（SQLite默认自动开始事务）
        
        # 检查余额
        cursor.execute("SELECT balance FROM accounts WHERE id = ?", (from_account,))
        from_balance = cursor.fetchone()[0]
        
        if from_balance < amount:
            raise ValueError("余额不足")
        
        # 扣除转出账户金额
        cursor.execute(
            "UPDATE accounts SET balance = balance - ? WHERE id = ?", 
            (amount, from_account)
        )
        
        # 增加转入账户金额
        cursor.execute(
            "UPDATE accounts SET balance = balance + ? WHERE id = ?", 
            (amount, to_account)
        )
        
        # 记录交易
        cursor.execute(
            "INSERT INTO transactions (from_account, to_account, amount) VALUES (?, ?, ?)",
            (from_account, to_account, amount)
        )
        
        # 提交事务
        conn.commit()
        print(f"成功转账 {amount} 元")
        
    except Exception as e:
        # 回滚事务
        conn.rollback()
        print(f"转账失败: {e}")
        raise
```

### 使用自定义函数和聚合

```python
import sqlite3
import re

def regexp(pattern, text):
    """为SQLite提供正则表达式支持"""
    if text is None:
        return False
    return re.search(pattern, text) is not None

with sqlite3.connect('example.db') as conn:
    # 注册自定义函数
    conn.create_function("REGEXP", 2, regexp)
    
    cursor = conn.cursor()
    
    # 使用自定义函数
    cursor.execute("SELECT * FROM users WHERE name REGEXP ?", ('^张.*',))
    results = cursor.fetchall()
    print("姓张的用户：")
    for row in results:
        print(row)
```

## 使用MySQL

要连接MySQL数据库，需要安装第三方驱动，如`pymysql`或`mysql-connector-python`。

### 使用PyMySQL

```python
# 安装: pip install pymysql
import pymysql

# 连接到MySQL服务器
conn = pymysql.connect(
    host='localhost',
    user='username',
    password='password',
    database='testdb',
    charset='utf8mb4',
    cursorclass=pymysql.cursors.DictCursor  # 返回字典格式的结果
)

try:
    with conn.cursor() as cursor:
        # 创建表
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS employees (
            id INT AUTO_INCREMENT PRIMARY KEY,
            name VARCHAR(100) NOT NULL,
            department VARCHAR(100),
            salary DECIMAL(10, 2)
        )
        ''')
        
        # 插入数据
        cursor.execute(
            "INSERT INTO employees (name, department, salary) VALUES (%s, %s, %s)",
            ("张三", "研发部", 10000.00)
        )
        
        # 批量插入
        employees = [
            ("李四", "市场部", 8000.00),
            ("王五", "财务部", 9000.00),
            ("赵六", "研发部", 11000.00)
        ]
        cursor.executemany(
            "INSERT INTO employees (name, department, salary) VALUES (%s, %s, %s)",
            employees
        )
        
        # 提交事务
        conn.commit()
        
        # 查询数据
        cursor.execute("SELECT * FROM employees WHERE department = %s", ("研发部",))
        results = cursor.fetchall()
        
        print("研发部员工：")
        for employee in results:
            print(f"ID: {employee['id']}, 姓名: {employee['name']}, 薪资: {employee['salary']}")
            
except Exception as e:
    # 出错时回滚
    conn.rollback()
    print(f"操作失败: {e}")
finally:
    # 关闭连接
    conn.close()
```

### 使用MySQL Connector/Python

```python
# 安装: pip install mysql-connector-python
import mysql.connector

# 连接到MySQL服务器
conn = mysql.connector.connect(
    host='localhost',
    user='username',
    password='password',
    database='testdb'
)

try:
    cursor = conn.cursor(dictionary=True)
    
    # 查询数据
    cursor.execute("SELECT * FROM employees ORDER BY salary DESC")
    results = cursor.fetchall()
    
    print("员工薪资排名：")
    for i, employee in enumerate(results, 1):
        print(f"{i}. {employee['name']} - {employee['salary']}")
        
except Exception as e:
    print(f"操作失败: {e}")
finally:
    if conn.is_connected():
        cursor.close()
        conn.close()
```

### MySQL连接池

对于高并发应用，使用连接池可以提高性能：

```python
# 安装: pip install mysql-connector-python
import mysql.connector
from mysql.connector import pooling

# 创建连接池
pool = mysql.connector.pooling.MySQLConnectionPool(
    pool_name="mypool",
    pool_size=5,
    host='localhost',
    user='username',
    password='password',
    database='testdb'
)

# 从连接池获取连接
conn = pool.get_connection()

try:
    cursor = conn.cursor(dictionary=True)
    cursor.execute("SELECT COUNT(*) as count FROM employees")
    result = cursor.fetchone()
    print(f"员工总数: {result['count']}")
finally:
    cursor.close()
    conn.close()  # 将连接返回池中，而不是关闭
```

## 使用PostgreSQL

PostgreSQL是一个功能强大的开源关系型数据库。

```python
# 安装: pip install psycopg2-binary
import psycopg2
import psycopg2.extras

# 连接到PostgreSQL服务器
conn = psycopg2.connect(
    host="localhost",
    database="testdb",
    user="postgres",
    password="password"
)

try:
    # 创建一个支持字典结果的游标
    with conn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
        # 创建表
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS products (
            id SERIAL PRIMARY KEY,
            name VARCHAR(100) NOT NULL,
            category VARCHAR(50),
            price DECIMAL(10, 2),
            in_stock BOOLEAN DEFAULT TRUE
        )
        ''')
        
        # 插入数据
        cursor.execute(
            "INSERT INTO products (name, category, price) VALUES (%s, %s, %s) RETURNING id",
            ("笔记本电脑", "电子产品", 6999.99)
        )
        
        # 获取插入的ID
        product_id = cursor.fetchone()[0]
        print(f"插入的产品ID: {product_id}")
        
        # 批量插入
        products = [
            ("智能手机", "电子产品", 2999.99),
            ("无线耳机", "配件", 699.99),
            ("机械键盘", "配件", 499.99)
        ]
        psycopg2.extras.execute_batch(
            cursor,
            "INSERT INTO products (name, category, price) VALUES (%s, %s, %s)",
            products
        )
        
        # 提交事务
        conn.commit()
        
        # 使用JOIN查询
        cursor.execute('''
        SELECT p.name, p.price, c.name as category_name
        FROM products p
        LEFT JOIN categories c ON p.category = c.id
        WHERE p.price > %s
        ORDER BY p.price DESC
        ''', (1000,))
        
        results = cursor.fetchall()
        for product in results:
            print(f"产品: {product['name']}, 价格: {product['price']}, 类别: {product['category_name']}")
            
except Exception as e:
    conn.rollback()
    print(f"操作失败: {e}")
finally:
    conn.close()
```

### PostgreSQL高级特性

PostgreSQL支持JSON和数组等高级数据类型：

```python
import psycopg2
import psycopg2.extras
import json

conn = psycopg2.connect(
    host="localhost",
    database="testdb",
    user="postgres",
    password="password"
)

try:
    with conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cursor:
        # 创建包含JSON字段和数组的表
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS user_profiles (
            id SERIAL PRIMARY KEY,
            username VARCHAR(50) UNIQUE,
            profile JSONB,
            tags TEXT[]
        )
        ''')
        
        # 插入JSON数据和数组
        profile = {
            "first_name": "张",
            "last_name": "三",
            "age": 28,
            "contact": {
                "email": "zhangsan@example.com",
                "phone": "13800138000"
            },
            "preferences": {
                "theme": "dark",
                "notifications": True
            }
        }
        
        tags = ["程序员", "Python爱好者", "数据库专家"]
        
        cursor.execute(
            "INSERT INTO user_profiles (username, profile, tags) VALUES (%s, %s, %s)",
            ("zhangsan", json.dumps(profile), tags)
        )
        
        # 提交事务
        conn.commit()
        
        # 查询JSON字段
        cursor.execute('''
        SELECT * FROM user_profiles
        WHERE profile->>'age' = '28' AND 'Python爱好者' = ANY(tags)
        ''')
        
        results = cursor.fetchall()
        for user in results:
            print(f"用户: {user['username']}")
            print(f"个人信息: {user['profile']}")
            print(f"标签: {user['tags']}")
            
        # 使用JSON操作符更新数据
        cursor.execute('''
        UPDATE user_profiles
        SET profile = profile || '{"preferences": {"language": "zh-CN"}}'::jsonb
        WHERE username = 'zhangsan'
        ''')
        
        conn.commit()
        
except Exception as e:
    conn.rollback()
    print(f"操作失败: {e}")
finally:
    conn.close()
```

## 使用Oracle数据库

连接Oracle数据库需要使用`cx_Oracle`库：

```python
# 安装: pip install cx_Oracle
import cx_Oracle

# 设置Oracle客户端库的位置（如果需要）
# cx_Oracle.init_oracle_client(lib_dir="path/to/oracle/client/lib")

# 连接到Oracle数据库
conn = cx_Oracle.connect(
    user="username",
    password="password",
    dsn="localhost:1521/XE"  # 格式: host:port/service_name
)

try:
    cursor = conn.cursor()
    
    # 创建表
    cursor.execute('''
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE orders PURGE';
        EXCEPTION WHEN OTHERS THEN NULL;
    END;
    ''')
    
    cursor.execute('''
    CREATE TABLE orders (
        order_id NUMBER PRIMARY KEY,
        customer_id NUMBER NOT NULL,
        order_date DATE,
        total_amount NUMBER(10,2)
    )
    ''')
    
    # 插入数据
    cursor.execute('''
    INSERT INTO orders (order_id, customer_id, order_date, total_amount)
    VALUES (:1, :2, :3, :4)
    ''', (1001, 5001, cx_Oracle.Timestamp(2023, 6, 15), 1299.99))
    
    # 批量插入
    orders = [
        (1002, 5002, cx_Oracle.Timestamp(2023, 6, 16), 899.50),
        (1003, 5001, cx_Oracle.Timestamp(2023, 6, 17), 2499.99),
        (1004, 5003, cx_Oracle.Timestamp(2023, 6, 18), 599.99)
    ]
    
    cursor.executemany('''
    INSERT INTO orders (order_id, customer_id, order_date, total_amount)
    VALUES (:1, :2, :3, :4)
    ''', orders)
    
    # 提交事务
    conn.commit()
    
    # 查询数据
    cursor.execute('''
    SELECT customer_id, SUM(total_amount) as total_spent
    FROM orders
    GROUP BY customer_id
    ORDER BY total_spent DESC
    ''')
    
    results = cursor.fetchall()
    print("客户消费总额：")
    for customer_id, total_spent in results:
        print(f"客户ID: {customer_id}, 总消费: {total_spent}")
    
    # 使用存储过程
    # 假设我们有一个名为 GET_CUSTOMER_ORDERS 的存储过程
    cursor.callproc("GET_CUSTOMER_ORDERS", [5001])
    
    # 使用绑定变量调用函数
    cursor.execute("BEGIN :result := CALCULATE_DISCOUNT(:amount); END;", 
                  {'result': cursor.var(cx_Oracle.NUMBER), 'amount': 1000})
    discount = cursor.getvalue('result')
    print(f"折扣: {discount}")
    
except Exception as e:
    conn.rollback()
    print(f"操作失败: {e}")
finally:
    cursor.close()
    conn.close()
```

## 使用MongoDB

MongoDB是一个流行的NoSQL文档数据库，使用`pymongo`库进行操作：

```python
# 安装: pip install pymongo
import pymongo
from pymongo import MongoClient
from datetime import datetime

# 连接到MongoDB服务器
client = MongoClient('mongodb://localhost:27017/')

# 获取或创建数据库
db = client['test_database']

# 获取或创建集合
users = db['users']
posts = db['posts']

# 插入文档
user_data = {
    "username": "zhangsan",
    "email": "zhangsan@example.com",
    "profile": {
        "name": "张三",
        "age": 28,
        "interests": ["编程", "阅读", "旅行"]
    },
    "created_at": datetime.now()
}

user_id = users.insert_one(user_data).inserted_id
print(f"插入的用户ID: {user_id}")

# 批量插入
new_posts = [
    {
        "title": "MongoDB入门",
        "content": "这是关于MongoDB的入门教程...",
        "author_id": user_id,
        "tags": ["数据库", "NoSQL", "教程"],
        "comments": [],
        "created_at": datetime.now()
    },
    {
        "title": "Python和MongoDB",
        "content": "如何在Python中使用MongoDB...",
        "author_id": user_id,
        "tags": ["Python", "数据库", "编程"],
        "comments": [
            {
                "user": "lisi",
                "text": "非常有用的教程！",
                "created_at": datetime.now()
            }
        ],
        "created_at": datetime.now()
    }
]

result = posts.insert_many(new_posts)
print(f"插入的文档ID: {result.inserted_ids}")

# 查询文档
user = users.find_one({"username": "zhangsan"})
print(f"用户信息: {user}")

# 复杂查询
query = {
    "tags": "Python",
    "created_at": {"$gt": datetime(2023, 1, 1)}
}

# 使用排序和投影
cursor = posts.find(
    query, 
    {"title": 1, "tags": 1, "_id": 0}  # 只返回title和tags字段，不返回_id
).sort("created_at", pymongo.DESCENDING)

print("Python相关文章：")
for post in cursor:
    print(post)

# 更新文档
result = posts.update_one(
    {"title": "MongoDB入门"},
    {"$push": {"comments": {
        "user": "wangwu",
        "text": "我学到了很多！",
        "created_at": datetime.now()
    }}}
)
print(f"更新匹配数: {result.matched_count}, 更新数: {result.modified_count}")

# 聚合操作
pipeline = [
    {"$unwind": "$tags"},
    {"$group": {"_id": "$tags", "count": {"$sum": 1}}},
    {"$sort": {"count": -1}}
]

results = posts.aggregate(pipeline)
print("标签统计：")
for result in results:
    print(f"标签: {result['_id']}, 文章数: {result['count']}")

# 创建索引
users.create_index([("username", pymongo.ASCENDING)], unique=True)
posts.create_index([("tags", pymongo.ASCENDING), ("created_at", pymongo.DESCENDING)])

# 关闭连接
client.close()
```

## 使用Redis

Redis是一个内存数据结构存储，可用作数据库、缓存和消息代理：

```python
# 安装: pip install redis
import redis
import json
from datetime import timedelta

# 连接到Redis服务器
r = redis.Redis(
    host='localhost',
    port=6379,
    db=0,
    decode_responses=True  # 自动将字节解码为字符串
)

# 设置和获取字符串
r.set('user:1:name', '张三')
r.set('user:1:email', 'zhangsan@example.com')
r.set('counter', 1)

username = r.get('user:1:name')
print(f"用户名: {username}")

# 原子增加
r.incr('counter')
r.incrby('counter', 5)
new_value = r.get('counter')
print(f"计数器新值: {new_value}")

# 设置过期时间
r.setex('session:123', timedelta(minutes=30), 'active')

# 使用哈希存储对象
user_data = {
    'name': '李四',
    'email': 'lisi@example.com',
    'age': 30,
    'is_active': True
}

r.hset('user:2', mapping=user_data)
# 或者逐个字段设置
# for key, value in user_data.items():
#     r.hset('user:2', key, value)

# 获取哈希中的单个字段
email = r.hgetall('user:2')['email']
print(f"李四的邮箱: {email}")

# 获取整个哈希
user2 = r.hgetall('user:2')
print(f"用户2数据: {user2}")

# 列表操作
r.lpush('recent_users', 'user:1', 'user:2')
r.lpush('recent_users', 'user:3')

# 获取列表范围
recent_users = r.lrange('recent_users', 0, -1)
print(f"最近的用户: {recent_users}")

# 集合操作
r.sadd('user:1:roles', 'admin', 'editor')
r.sadd('user:2:roles', 'editor')
r.sadd('user:3:roles', 'user')

# 获取集合成员
roles = r.smembers('user:1:roles')
print(f"用户1的角色: {roles}")

# 检查集合成员
is_admin = r.sismember('user:1:roles', 'admin')
print(f"用户1是否是管理员: {is_admin}")

# 集合交集
editors = r.sinter('user:1:roles', 'user:2:roles')
print(f"既是用户1又是用户2的角色: {editors}")

# 有序集合
r.zadd('leaderboard', {'player1': 100, 'player2': 150, 'player3': 120})

# 增加分数
r.zincrby('leaderboard', 10, 'player1')

# 获取排名
rank = r.zrevrank('leaderboard', 'player1')
print(f"player1的排名: {rank + 1}")  # +1是因为排名从0开始

# 获取前N名
top_players = r.zrevrange('leaderboard', 0, 2, withscores=True)
print("排行榜前3名:")
for player, score in top_players:
    print(f"{player}: {score}分")

# 使用管道减少网络往返
pipe = r.pipeline()
pipe.set('batch:1', 'value1')
pipe.set('batch:2', 'value2')
pipe.set('batch:3', 'value3')
pipe.execute()

# 发布/订阅模式
# 在另一个线程或进程中运行订阅者
# def subscriber():
#     sub = redis.Redis(host='localhost', port=6379, db=0, decode_responses=True)
#     pubsub = sub.pubsub()
#     pubsub.subscribe('notifications')
#     for message in pubsub.listen():
#         if message['type'] == 'message':
#             print(f"收到消息: {message['data']}")

# 发布消息
r.publish('notifications', json.dumps({
    'type': 'alert',
    'message': '系统将在5分钟后维护'
}))

# 事务
pipe = r.pipeline(transaction=True)
pipe.set('trans:1', 'value1')
pipe.incr('trans:2')
pipe.execute()

# 关闭连接
r.close()
```

## 使用SQLAlchemy ORM

SQLAlchemy是Python中最流行的ORM（对象关系映射）库，可以与多种数据库后端一起使用。

```python
# 安装: pip install sqlalchemy
from sqlalchemy import create_engine, Column, Integer, String, Float, ForeignKey, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, relationship
import datetime

# 创建数据库引擎
engine = create_engine('sqlite:///orm_example.db', echo=True)

# 声明基类
Base = declarative_base()

# 定义模型类
class User(Base):
    __tablename__ = 'users'
    
    id = Column(Integer, primary_key=True)
    username = Column(String(50), nullable=False, unique=True)
    email = Column(String(100), nullable=False, unique=True)
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    
    # 关系
    orders = relationship("Order", back_populates="user")
    
    def __repr__(self):
        return f"<User(username='{self.username}', email='{self.email}')>"

class Product(Base):
    __tablename__ = 'products'
    
    id = Column(Integer, primary_key=True)
    name = Column(String(100), nullable=False)
    description = Column(String(500))
    price = Column(Float, nullable=False)
    
    # 关系
    order_items = relationship("OrderItem", back_populates="product")
    
    def __repr__(self):
        return f"<Product(name='{self.name}', price={self.price})>"

class Order(Base):
    __tablename__ = 'orders'
    
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)
    order_date = Column(DateTime, default=datetime.datetime.utcnow)
    
    # 关系
    user = relationship("User", back_populates="orders")
    items = relationship("OrderItem", back_populates="order")
    
    def __repr__(self):
        return f"<Order(id={self.id}, user_id={self.user_id})>"

class OrderItem(Base):
    __tablename__ = 'order_items'
    
    id = Column(Integer, primary_key=True)
    order_id = Column(Integer, ForeignKey('orders.id'), nullable=False)
    product_id = Column(Integer, ForeignKey('products.id'), nullable=False)
    quantity = Column(Integer, nullable=False, default=1)
    
    # 关系
    order = relationship("Order", back_populates="items")
    product = relationship("Product", back_populates="order_items")
    
    def __repr__(self):
        return f"<OrderItem(order_id={self.order_id}, product_id={self.product_id}, quantity={self.quantity})>"

# 创建表
Base.metadata.create_all(engine)

# 创建会话类
Session = sessionmaker(bind=engine)

# 开始会话
session = Session()

try:
    # 添加用户
    user1 = User(username='zhangsan', email='zhangsan@example.com')
    user2 = User(username='lisi', email='lisi@example.com')
    session.add_all([user1, user2])
    
    # 提交以获取用户ID
    session.flush()
    
    # 添加产品
    product1 = Product(name='笔记本电脑', description='高性能笔记本', price=6999.99)
    product2 = Product(name='智能手机', description='最新款智能手机', price=2999.99)
    product3 = Product(name='无线耳机', description='高音质无线耳机', price=699.99)
    session.add_all([product1, product2, product3])
    
    # 提交以获取产品ID
    session.flush()
    
    # 创建订单
    order1 = Order(user_id=user1.id)
    session.add(order1)
    session.flush()
    
    # 添加订单项
    item1 = OrderItem(order_id=order1.id, product_id=product1.id, quantity=1)
    item2 = OrderItem(order_id=order1.id, product_id=product3.id, quantity=2)
    session.add_all([item1, item2])
    
    # 创建另一个订单
    order2 = Order(user_id=user2.id)
    session.add(order2)
    session.flush()
    
    item3 = OrderItem(order_id=order2.id, product_id=product2.id, quantity=1)
    session.add(item3)
    
    # 提交事务
    session.commit()
    
    # 查询数据
    print("\n用户列表:")
    users = session.query(User).all()
    for user in users:
        print(user)
    
    print("\n产品列表:")
    products = session.query(Product).all()
    for product in products:
        print(product)
    
    print("\n订单列表:")
    orders = session.query(Order).all()
    for order in orders:
        print(order)
    
    # 复杂查询
    print("\n张三的订单:")
    zhang_orders = session.query(Order).join(User).filter(User.username == 'zhangsan').all()
    for order in zhang_orders:
        print(f"订单ID: {order.id}")
        for item in order.items:
            product = item.product
            print(f"  - {product.name}: {item.quantity}个, 单价: {product.price}")
    
    # 聚合查询
    print("\n每个用户的订单总额:")
    from sqlalchemy import func
    
    results = session.query(
        User.username,
        func.sum(Product.price * OrderItem.quantity).label('total')
    ).join(Order, User.id == Order.user_id) \
     .join(OrderItem, Order.id == OrderItem.order_id) \
     .join(Product, OrderItem.product_id == Product.id) \
     .group_by(User.username) \
     .all()
    
    for username, total in results:
        print(f"{username}: {total}元")
    
    # 更新数据
    product = session.query(Product).filter(Product.name == '无线耳机').first()
    product.price = 599.99
    session.commit()
    
    # 删除数据
    item_to_delete = session.query(OrderItem).filter(
        OrderItem.order_id == order2.id,
        OrderItem.product_id == product2.id
    ).first()
    
    session.delete(item_to_delete)
    session.commit()
    
except Exception as e:
    session.rollback()
    print(f"操作失败: {e}")
finally:
    session.close()
```

## 使用Django ORM

Django ORM是Django Web框架的一部分，但也可以独立使用：

```python
# 在Django项目中，模型定义如下:
# models.py
from django.db import models

class Category(models.Model):
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True)
    
    def __str__(self):
        return self.name
    
    class Meta:
        verbose_name_plural = "Categories"

class Product(models.Model):
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True)
    price = models.DecimalField(max_digits=10, decimal_places=2)
    category = models.ForeignKey(Category, on_delete=models.CASCADE, related_name='products')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    in_stock = models.BooleanField(default=True)
    
    def __str__(self):
        return self.name

# 在Django视图或其他地方使用ORM:
# views.py
from django.shortcuts import render
from .models import Category, Product
from django.db.models import Sum, Count, Avg, F, Q

def product_list(request):
    # 基本查询
    all_products = Product.objects.all()
    
    # 过滤
    in_stock_products = Product.objects.filter(in_stock=True)
    expensive_products = Product.objects.filter(price__gt=1000)
    
    # 组合条件
    query = Q(price__lt=500) | Q(category__name="配件")
    budget_or_accessories = Product.objects.filter(query)
    
    # 排除
    non_accessories = Product.objects.exclude(category__name="配件")
    
    # 排序
    products_by_price = Product.objects.order_by('price')
    products_by_price_desc = Product.objects.order_by('-price')
    
    # 限制结果数量
    top_5_products = Product.objects.order_by('-price')[:5]
    
    # 选择特定字段
    product_names = Product.objects.values_list('name', flat=True)
    
    # 聚合
    avg_price = Product.objects.aggregate(Avg('price'))
    
    # 分组聚合
    categories = Category.objects.annotate(
        product_count=Count('products'),
        avg_price=Avg('products__price')
    )
    
    # F表达式(引用字段值)
    Product.objects.filter(price__gt=F('category__products__price__avg'))
    
    # 更新
    Product.objects.filter(price__lt=500).update(price=F('price') * 1.1)
    
    # 创建
    new_category = Category.objects.create(name="新类别", description="新类别描述")
    
    # 批量创建
    Product.objects.bulk_create([
        Product(name="产品1", price=99.99, category=new_category),
        Product(name="产品2", price=199.99, category=new_category)
    ])
    
    # 关联查询
    category = Category.objects.get(name="电子产品")
    category_products = category.products.all()  # 使用related_name
    
    # 获取或创建
    category, created = Category.objects.get_or_create(
        name="书籍",
        defaults={"description": "各类图书"}
    )
    
    # 事务
    from django.db import transaction
    
    with transaction.atomic():
        product = Product.objects.select_for_update().get(id=1)
        product.price += 100
        product.save()
    
    context = {
        'products': all_products,
        'categories': categories,
        'avg_price': avg_price
    }
    
    return render(request, 'products/list.html', context)
```

## 数据库最佳实践

### 连接池和资源管理

```python
import sqlite3
import contextlib

class DatabasePool:
    def __init__(self, database, max_connections=5):
        self.database = database
        self.max_connections = max_connections
        self.connections = []
        self.in_use = set()
    
    def get_connection(self):
        if len(self.connections) < self.max_connections:
            connection = sqlite3.connect(self.database)
            self.connections.append(connection)
        else:
            # 等待可用连接
            while len(self.in_use) >= self.max_connections:
                pass
            connection = next(c for c in self.connections if c not in self.in_use)
        
        self.in_use.add(connection)
        return connection
    
    def release_connection(self, connection):
        self.in_use.remove(connection)
    
    def close_all(self):
        for connection in self.connections:
            connection.close()
        self.connections.clear()
        self.in_use.clear()

@contextlib.contextmanager
def get_db_connection(pool):
    connection = pool.get_connection()
    try:
        yield connection
    finally:
        pool.release_connection(connection)

# 使用连接池
pool = DatabasePool('example.db')

with get_db_connection(pool) as conn:
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users")
    results = cursor.fetchall()
    print(results)

# 关闭所有连接
pool.close_all()
```

### 参数化查询防止SQL注入

```python
# 不安全的查询（容易受到SQL注入攻击）
def unsafe_search(username):
    query = f"SELECT * FROM users WHERE username = '{username}'"
    # 如果username是 "' OR '1'='1", 会返回所有用户
    
    conn = sqlite3.connect('example.db')
    cursor = conn.cursor()
    cursor.execute(query)
    return cursor.fetchall()

# 安全的参数化查询
def safe_search(username):
    query = "SELECT * FROM users WHERE username = ?"
    
    conn = sqlite3.connect('example.db')
    cursor = conn.cursor()
    cursor.execute(query, (username,))
    return cursor.fetchall()
```

### 批量操作提高性能

```python
import sqlite3
import time

# 连接到数据库
conn = sqlite3.connect('performance.db')
cursor = conn.cursor()

# 创建测试表
cursor.execute('CREATE TABLE IF NOT EXISTS test (id INTEGER PRIMARY KEY, value TEXT)')

# 单个插入
def insert_one_by_one(n):
    start_time = time.time()
    
    for i in range(n):
        cursor.execute('INSERT INTO test (value) VALUES (?)', (f'value-{i}',))
        conn.commit()  # 每次插入后提交
    
    end_time = time.time()
    return end_time - start_time

# 批量插入
def insert_batch(n):
    start_time = time.time()
    
    values = [(f'value-{i}',) for i in range(n)]
    cursor.executemany('INSERT INTO test (value) VALUES (?)', values)
    conn.commit()  # 只提交一次
    
    end_time = time.time()
    return end_time - start_time

# 测试两种方法的性能差异
n = 10000
cursor.execute('DELETE FROM test')  # 清空表

print(f"逐个插入 {n} 条记录用时: {insert_one_by_one(n):.2f}秒")

cursor.execute('DELETE FROM test')  # 清空表

print(f"批量插入 {n} 条记录用时: {insert_batch(n):.2f}秒")

# 关闭连接
cursor.close()
conn.close()
```

### 事务管理

```python
import sqlite3

def transfer_money(from_account, to_account, amount):
    conn = sqlite3.connect('bank.db')
    
    try:
        # 开始事务
        conn.execute('BEGIN TRANSACTION')
        
        # 检查余额
        cursor = conn.execute(
            'SELECT balance FROM accounts WHERE id = ?', 
            (from_account,)
        )
        from_balance = cursor.fetchone()[0]
        
        if from_balance < amount:
            raise ValueError("余额不足")
        
        # 扣除转出账户金额
        conn.execute(
            'UPDATE accounts SET balance = balance - ? WHERE id = ?', 
            (amount, from_account)
        )
        
        # 模拟可能的错误
        # if random.random() < 0.3:
        #     raise Exception("随机错误，测试事务回滚")
        
        # 增加转入账户金额
        conn.execute(
            'UPDATE accounts SET balance = balance + ? WHERE id = ?', 
            (amount, to_account)
        )
        
        # 提交事务
        conn.commit()
        print(f"成功从账户 {from_account} 转账 {amount} 元到账户 {to_account}")
        
    except Exception as e:
        # 回滚事务
        conn.rollback()
        print(f"转账失败: {e}")
        raise
    finally:
        conn.close()
```

### 数据库迁移

在实际项目中，经常需要对数据库结构进行更改。使用迁移工具可以安全地管理这些更改：

```python
# 使用Alembic(SQLAlchemy的迁移工具)进行数据库迁移
# 安装: pip install alembic

# 初始化Alembic
# alembic init migrations

# 创建迁移脚本
# alembic revision --autogenerate -m "Add new column"

# 在migrations/versions/xxxx_add_new_column.py中修改:
"""
def upgrade():
    op.add_column('users', sa.Column('phone', sa.String(20)))

def downgrade():
    op.drop_column('users', 'phone')
"""

# 应用迁移
# alembic upgrade head

# 回滚迁移
# alembic downgrade -1
```

### 连接重试和错误处理

```python
import sqlite3
import time
import random

def execute_with_retry(query, params=None, max_retries=3, retry_delay=1):
    """带重试机制的数据库操作执行函数"""
    retries = 0
    last_error = None
    
    while retries < max_retries:
        try:
            conn = sqlite3.connect('example.db')
            cursor = conn.cursor()
            
            if params:
                cursor.execute(query, params)
            else:
                cursor.execute(query)
            
            result = cursor.fetchall()
            conn.commit()
            conn.close()
            return result
        
        except sqlite3.OperationalError as e:
            last_error = e
            retries += 1
            if retries < max_retries:
                # 指数退避策略
                sleep_time = retry_delay * (2 ** (retries - 1)) * (0.5 + random.random())
                print(f"数据库操作失败，{sleep_time:.2f}秒后重试 ({retries}/{max_retries}): {e}")
                time.sleep(sleep_time)
            else:
                print(f"达到最大重试次数，操作失败: {e}")
        except Exception as e:
            conn.close()
            raise e
    
    # 如果达到最大重试次数，抛出最后的错误
    raise last_error
```

## 总结

Python提供了丰富的数据库操作工具和库，从低级的数据库驱动到高级的ORM框架。本文介绍了：

1. **关系型数据库操作**：SQLite、MySQL、PostgreSQL、Oracle
2. **NoSQL数据库操作**：MongoDB、Redis
3. **ORM框架**：SQLAlchemy、Django ORM
4. **数据库最佳实践**：连接池、参数化查询、批量操作、事务管理等

在选择数据库和相关工具时，应根据项目需求、性能要求、团队熟悉度等因素进行综合考虑。无论选择哪种数据库技术，确保遵循安全实践、优化性能并合理管理资源是至关重要的。
