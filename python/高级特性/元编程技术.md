# 元编程技术

元编程是指编写能够操作程序（包括自身）的程序代码。在Python中，元编程允许开发者动态地创建类和函数，修改现有代码的行为，并在运行时构建程序结构。

## 元类 (Metaclasses)

元类是类的类，用于控制类的创建过程。当定义一个新类时，元类可以拦截类定义，修改它，然后返回修改后的类。

### 基本元类示例

```python
# 定义元类
class Meta(type):
    def __new__(mcs, name, bases, attrs):
        # 在类属性字典中添加一个新属性
        attrs['added_by_meta'] = True
        # 修改现有方法
        if 'some_method' in attrs:
            original_method = attrs['some_method']
            def wrapped_method(self, *args, **kwargs):
                print("方法被调用")
                return original_method(self, *args, **kwargs)
            attrs['some_method'] = wrapped_method
        return super().__new__(mcs, name, bases, attrs)
        
    def __init__(cls, name, bases, attrs):
        print(f"类 {name} 被创建")
        super().__init__(name, bases, attrs)

# 使用元类
class MyClass(metaclass=Meta):
    def some_method(self):
        return "原始方法"
        
# 检查类
obj = MyClass()
print(obj.added_by_meta)  # True
print(obj.some_method())  # 输出: 方法被调用, 原始方法
```

### 元类应用场景

1. **自动注册**：将类自动注册到某个中央注册表

```python
class PluginRegistry(type):
    plugins = {}
    
    def __new__(mcs, name, bases, attrs):
        cls = super().__new__(mcs, name, bases, attrs)
        if hasattr(cls, 'plugin_name'):
            PluginRegistry.plugins[cls.plugin_name] = cls
        return cls
        
class Plugin(metaclass=PluginRegistry):
    pass
    
class AudioPlugin(Plugin):
    plugin_name = 'audio'
    
class VideoPlugin(Plugin):
    plugin_name = 'video'
    
# 获取已注册的插件
print(PluginRegistry.plugins)  # {'audio': <class '__main__.AudioPlugin'>, 'video': <class '__main__.VideoPlugin'>}
```

2. **强制规则执行**：在类定义时验证或强制执行某些规则

```python
class RequireAttributes(type):
    def __new__(mcs, name, bases, attrs):
        # 确保特定属性存在
        required = {'__slots__', 'validate'}
        missing = required - set(attrs)
        if missing:
            raise TypeError(f"Class {name} requires attributes: {missing}")
        return super().__new__(mcs, name, bases, attrs)
        
class Model(metaclass=RequireAttributes):
    pass
    
# 这会引发错误
# class User(Model):
#     pass
    
# 这不会引发错误
class User(Model):
    __slots__ = ('name', 'email')
    
    def validate(self):
        pass
```

3. **属性转换**：自动转换或处理类属性

```python
class Column:
    def __init__(self, col_type):
        self.col_type = col_type
        
class ModelMeta(type):
    def __new__(mcs, name, bases, attrs):
        # 收集列定义
        columns = {}
        for key, value in list(attrs.items()):
            if isinstance(value, Column):
                columns[key] = value
                attrs.pop(key)  # 从类属性中移除
        attrs['_columns'] = columns
        return super().__new__(mcs, name, bases, attrs)
        
class Model(metaclass=ModelMeta):
    pass
    
class User(Model):
    name = Column(str)
    age = Column(int)
    
# 查看转换后的结果
print(User._columns)  # {'name': <__main__.Column object at ...>, 'age': <__main__.Column object at ...>}
```

### `__prepare__` 方法

Python 3中的元类可以定义`__prepare__`方法，它返回一个映射对象，用于收集类定义中的属性。

```python
class OrderedMeta(type):
    @classmethod
    def __prepare__(mcs, name, bases):
        # 使用OrderedDict记录属性定义顺序
        from collections import OrderedDict
        return OrderedDict()
        
    def __new__(mcs, name, bases, attrs):
        # attrs是有序的，可以访问原始顺序
        print(f"类属性定义顺序: {list(attrs.keys())}")
        return super().__new__(mcs, name, bases, attrs)
        
class MyClass(metaclass=OrderedMeta):
    z = 1
    x = 2
    y = 3
```

## 类装饰器

类装饰器提供了另一种修改类的方法，通常比元类更简单，更易于使用。

### 基本类装饰器

```python
def add_repr(cls):
    """添加标准的__repr__方法"""
    def __repr__(self):
        attrs = ', '.join(f"{k}={v!r}" for k, v in self.__dict__.items())
        return f"{self.__class__.__name__}({attrs})"
    
    cls.__repr__ = __repr__
    return cls
    
@add_repr
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        
p = Person("Alice", 30)
print(p)  # Person(name='Alice', age=30)
```

### 参数化类装饰器

```python
def validate_attributes(*required_attrs):
    def decorator(cls):
        original_init = cls.__init__
        
        def __init__(self, *args, **kwargs):
            original_init(self, *args, **kwargs)
            # 验证必需的属性
            missing = [attr for attr in required_attrs if not hasattr(self, attr)]
            if missing:
                raise ValueError(f"Missing required attributes: {missing}")
        
        cls.__init__ = __init__
        return cls
    
    return decorator
    
@validate_attributes('name', 'age')
class Person:
    def __init__(self, name=None, age=None):
        self.name = name
        # 注释掉age赋值将导致验证失败
        self.age = age
```

### 类装饰器 vs 元类

类装饰器通常更适合于：
- 在类创建后修改类
- 添加方法或属性
- 简单的类转换

元类更适合于：
- 在类创建过程中干预
- 需要访问属性定义顺序
- 继承链中的所有子类都需要某种行为

## 动态代码生成

Python提供了多种方式在运行时动态生成代码。

### `exec` 和 `eval`

```python
# 动态执行Python代码
code = """
def greet(name):
    return f'Hello, {name}!'
"""
namespace = {}
exec(code, namespace)

# 现在可以使用这个函数
greet_func = namespace['greet']
print(greet_func("World"))  # Hello, World!

# 使用eval计算表达式
x = 10
y = 20
result = eval("x * y + 5")
print(result)  # 205
```

### `type` 动态创建类

使用`type`函数可以动态创建新类：

```python
# 动态创建类
def create_model_class(name, fields):
    attrs = {
        '__init__': lambda self, **kwargs: setattr(self, '__dict__', kwargs),
        '__repr__': lambda self: f"{name}({', '.join(f'{k}={v!r}' for k, v in self.__dict__.items())})"
    }
    
    # 添加字段的访问器方法
    for field in fields:
        attrs[f'get_{field}'] = lambda self, f=field: getattr(self, f)
        attrs[f'set_{field}'] = lambda self, value, f=field: setattr(self, f, value)
    
    # 创建并返回新类
    return type(name, (), attrs)

# 使用这个函数创建新类
User = create_model_class('User', ['name', 'email', 'age'])
user = User(name='Alice', email='alice@example.com', age=30)
print(user)  # User(name='Alice', email='alice@example.com', age=30)
print(user.get_name())  # Alice
user.set_age(31)
print(user.get_age())  # 31
```

### 动态导入模块

```python
import importlib

# 动态导入模块
module_name = 'math'
math_module = importlib.import_module(module_name)
print(math_module.sqrt(16))  # 4.0

# 根据字符串动态获取属性
module_attr = getattr(math_module, 'pi')
print(module_attr)  # 3.141592653589793
```

## 实用元编程技术

### 属性描述符

描述符是Python中实现属性访问控制的强大工具：

```python
class TypedProperty:
    def __init__(self, name, expected_type):
        self.name = f"_{name}"
        self.expected_type = expected_type
        
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return getattr(instance, self.name, None)
        
    def __set__(self, instance, value):
        if not isinstance(value, self.expected_type):
            raise TypeError(f"Expected {self.expected_type}, got {type(value)}")
        setattr(instance, self.name, value)
        
class Person:
    name = TypedProperty('name', str)
    age = TypedProperty('age', int)
    
    def __init__(self, name, age):
        self.name = name
        self.age = age
        
p = Person("Alice", 30)
print(p.name, p.age)  # Alice 30

# 这会引发TypeError
# p.age = "thirty"
```

### 属性构建器

使用描述符和元类，可以创建声明式的类定义：

```python
class Field:
    def __init__(self, field_type=None, required=False):
        self.field_type = field_type
        self.required = required
        
class ModelMeta(type):
    def __new__(mcs, name, bases, attrs):
        # 收集字段信息
        fields = {}
        for key, value in list(attrs.items()):
            if isinstance(value, Field):
                fields[key] = value
                
        # 创建验证方法
        def validate(self):
            for name, field in fields.items():
                value = getattr(self, name, None)
                if field.required and value is None:
                    raise ValueError(f"Field {name} is required")
                if field.field_type and value is not None and not isinstance(value, field.field_type):
                    raise TypeError(f"Field {name} must be of type {field.field_type}")
            return True
            
        attrs['validate'] = validate
        attrs['_fields'] = fields
        return super().__new__(mcs, name, bases, attrs)
        
class Model(metaclass=ModelMeta):
    def __init__(self, **kwargs):
        for key, value in kwargs.items():
            setattr(self, key, value)
            
class User(Model):
    name = Field(str, required=True)
    age = Field(int)
    email = Field(str, required=True)
    
# 创建并验证
user = User(name="Alice", email="alice@example.com", age=30)
user.validate()  # 成功

# 这会引发ValueError
# invalid_user = User(name="Bob")
# invalid_user.validate()
```

### 单例实现

使用元类实现单例模式：

```python
class Singleton(type):
    _instances = {}
    
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]
        
class Database(metaclass=Singleton):
    def __init__(self, connection_string=None):
        self.connection_string = connection_string
        print(f"数据库连接到 {connection_string}")
        
# 创建两个实例，但实际上是同一个对象
db1 = Database("sqlite:///db1.sqlite")  # 输出: 数据库连接到 sqlite:///db1.sqlite
db2 = Database("sqlite:///db2.sqlite")  # 没有输出，因为没有创建新实例
print(db1 is db2)  # True
print(db1.connection_string)  # sqlite:///db1.sqlite
```

## 元编程的最佳实践

1. **谨慎使用**：元编程可能使代码难以理解和维护
2. **记录行为**：清楚地记录元编程技术的行为和意图
3. **优先选择简单性**：在可能的情况下，优先使用更简单的技术（如类装饰器而非元类）
4. **适度使用**：仅在有明确收益的情况下使用元编程
5. **测试覆盖**：确保全面测试元编程代码的行为

## 元编程应用场景

元编程在以下场景特别有用：

1. **ORM（对象关系映射）**：自动将类映射到数据库表（如Django模型、SQLAlchemy）
2. **API客户端**：动态生成API端点方法
3. **序列化框架**：自动转换对象与其他格式（如JSON、XML）
4. **DSL（领域特定语言）**：创建内部DSL简化特定任务
5. **配置系统**：声明式配置定义与验证
6. **测试框架**：简化测试用例的定义与执行
7. **依赖注入容器**：自动注入依赖项
