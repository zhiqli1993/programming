# 类型提示与静态类型

Python作为一种动态类型语言，提供了极大的灵活性，但有时这种灵活性也会带来代码可读性和可维护性的挑战。从Python 3.5开始，Python引入了类型提示（Type Hints）功能，允许开发者在不改变Python动态特性的前提下，为代码添加静态类型信息。

## 类型提示基础

### 基本语法

类型提示使用冒号（:）来注解变量类型，使用箭头（->）来注解函数返回类型：

```python
def greeting(name: str) -> str:
    return f"Hello, {name}"

# 变量注解
age: int = 25
height: float = 175.5
is_active: bool = True
```

### 内置类型

Python内置类型可以直接用于类型注解：

```python
# 基本类型
x: int = 10
y: float = 3.14
name: str = "Alice"
is_valid: bool = True

# 集合类型
numbers: list = [1, 2, 3]
user_data: dict = {"name": "Bob", "age": 30}
unique_ids: set = {1, 2, 3}
coordinates: tuple = (10, 20)
```

### typing模块

`typing`模块提供了更复杂的类型提示功能：

```python
from typing import List, Dict, Set, Tuple, Optional, Union, Any, Callable

# 泛型集合类型
numbers: List[int] = [1, 2, 3]
user_data: Dict[str, Union[str, int]] = {"name": "Bob", "age": 30}
unique_ids: Set[int] = {1, 2, 3}
coordinates: Tuple[int, int] = (10, 20)

# 可选类型
def get_user(user_id: int) -> Optional[Dict[str, Any]]:
    if user_id > 0:
        return {"id": user_id, "name": "User " + str(user_id)}
    return None

# 联合类型
def process_input(data: Union[str, bytes]) -> str:
    if isinstance(data, bytes):
        return data.decode('utf-8')
    return data

# 可调用类型
def apply_operation(x: int, y: int, operation: Callable[[int, int], int]) -> int:
    return operation(x, y)
```

## 高级类型提示

### 类型别名

可以创建类型别名来简化复杂类型：

```python
from typing import Dict, List, Union, TypeAlias

# 类型别名
UserId = int
UserData = Dict[str, Union[str, int]]
UserList = List[UserData]

# 使用类型别名
def get_user(user_id: UserId) -> UserData:
    return {"id": user_id, "name": f"User {user_id}"}

def get_all_users() -> UserList:
    return [get_user(1), get_user(2), get_user(3)]
```

### 新类型和类型包装

`NewType`可以创建一个语义上不同但底层相同的类型：

```python
from typing import NewType

UserId = NewType('UserId', int)
AdminId = NewType('AdminId', int)

def get_user(user_id: UserId) -> Dict[str, str]:
    return {"id": str(user_id), "role": "user"}

def get_admin(admin_id: AdminId) -> Dict[str, str]:
    return {"id": str(admin_id), "role": "admin"}

# 创建实例
user_id = UserId(1)  # 正确
admin_id = AdminId(2)  # 正确

# 类型检查器会捕获这种错误
# get_admin(user_id)  # 类型错误：期望AdminId，得到UserId
```

### 泛型

可以使用泛型定义参数化类型：

```python
from typing import TypeVar, Generic, List

T = TypeVar('T')  # 定义一个类型变量

class Stack(Generic[T]):
    def __init__(self) -> None:
        self.items: List[T] = []
        
    def push(self, item: T) -> None:
        self.items.append(item)
        
    def pop(self) -> T:
        return self.items.pop()
        
    def empty(self) -> bool:
        return not self.items

# 使用泛型类
int_stack = Stack[int]()
int_stack.push(1)
int_stack.push(2)
i = int_stack.pop()  # 类型检查器知道 i 是 int 类型

str_stack = Stack[str]()
str_stack.push("hello")
s = str_stack.pop()  # 类型检查器知道 s 是 str 类型
```

### 协议类

Python 3.8引入了协议类，类似于接口但更灵活：

```python
from typing import Protocol, runtime_checkable

@runtime_checkable
class Drawable(Protocol):
    def draw(self) -> None:
        ...

class Canvas:
    def draw(self) -> None:
        print("Drawing on canvas")

class PrintedDocument:
    def draw(self) -> None:
        print("Drawing document")
        
    def print(self) -> None:
        print("Printing document")

def render(drawable: Drawable) -> None:
    drawable.draw()

# 以下都合法，因为这两个类都实现了draw方法
render(Canvas())
render(PrintedDocument())
```

### Literal类型

Python 3.8引入了`Literal`类型，限制变量只能是特定的字面值：

```python
from typing import Literal, Union

# 定义字面量类型
Mode = Literal["r", "w", "a"]

def open_file(filename: str, mode: Mode) -> None:
    with open(filename, mode) as f:
        pass

# 合法调用
open_file("test.txt", "r")
open_file("test.txt", "w")

# 类型检查器会发现这个错误
# open_file("test.txt", "x")  # 错误：'x'不是有效的Mode

# 联合字面量
HttpStatus = Union[Literal[200], Literal[404], Literal[500]]

def handle_response(status: HttpStatus) -> None:
    if status == 200:
        print("Success")
    elif status == 404:
        print("Not found")
    elif status == 500:
        print("Server error")
```

### Final和ClassVar

Python 3.8引入了`Final`和`ClassVar`标注常量和类变量：

```python
from typing import Final, ClassVar

# 常量
MAX_USERS: Final = 100

class Config:
    # 类变量
    DEBUG: ClassVar[bool] = False
    
    # 实例变量
    def __init__(self, name: str):
        self.name = name

# 尝试修改会被类型检查器捕获
# MAX_USERS = 200  # 错误：不能重新赋值Final变量
```

### Callable详解

`Callable`类型用于描述可调用对象：

```python
from typing import Callable, Dict, Any, TypeVar, ParamSpec

# 基本用法
def twice(func: Callable[[int], int], x: int) -> int:
    return func(func(x))

def add_one(x: int) -> int:
    return x + 1

result = twice(add_one, 1)  # 结果是 3

# 更复杂的Callable：具有关键字参数
def create_user(
    callback: Callable[[str, int], Dict[str, Any]]
) -> Dict[str, Any]:
    return callback("Alice", 30)

# Python 3.10中的更灵活参数规范
P = ParamSpec('P')
T = TypeVar('T')

def log_call(func: Callable[P, T]) -> Callable[P, T]:
    def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:
        print(f"Calling {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@log_call
def add(x: int, y: int) -> int:
    return x + y
```

## 类型检查工具

### mypy

mypy是最流行的Python静态类型检查器：

```bash
# 安装mypy
pip install mypy

# 检查单个文件
mypy program.py

# 检查整个包
mypy -p package_name
```

mypy配置文件（mypy.ini或setup.cfg）示例：

```ini
[mypy]
python_version = 3.9
warn_return_any = True
warn_unused_configs = True
disallow_untyped_defs = True
disallow_incomplete_defs = True

[mypy.plugins.numpy.ndarray]
plugin_is_numpy = True
```

### pyright / Pylance

Pyright是微软开发的类型检查器，也是VS Code中Pylance扩展的核心：

```bash
# 安装pyright
pip install pyright

# 检查代码
pyright program.py
```

pyright配置文件（pyrightconfig.json）示例：

```json
{
  "include": ["src"],
  "exclude": ["**/node_modules", "**/__pycache__"],
  "reportMissingImports": true,
  "reportMissingTypeStubs": false,
  "pythonVersion": "3.9",
  "typeCheckingMode": "strict"
}
```

### pyre-check

Facebook开发的类型检查器：

```bash
# 安装pyre-check
pip install pyre-check

# 初始化项目
pyre init

# 运行检查
pyre check
```

### pytype

Google开发的类型检查器：

```bash
# 安装pytype
pip install pytype

# 检查代码
pytype program.py
```

## 实用类型提示技巧

### 类型注释的前向引用

从Python 3.7开始，可以使用字符串作为类型提示，解决循环引用问题：

```python
class Tree:
    def __init__(self, value: int) -> None:
        self.value = value
        self.left: Optional['Tree'] = None
        self.right: Optional['Tree'] = None
```

### 带有TypedDict的结构化字典

TypedDict允许定义具有特定键和值类型的字典：

```python
from typing import TypedDict, Optional

class User(TypedDict):
    id: int
    name: str
    email: str
    active: bool
    metadata: Optional[dict]

def create_user(data: User) -> User:
    # 处理用户数据
    return data

# 使用
user_data: User = {
    "id": 1,
    "name": "Alice",
    "email": "alice@example.com",
    "active": True,
    "metadata": {"last_login": "2023-01-15"}
}

create_user(user_data)
```

### 类型保护

类型检查器可以理解类型保护模式，进行流程控制中的类型收缩：

```python
from typing import Union, List, Dict, TypeGuard

def is_list(obj: Union[List[int], Dict[str, int]]) -> TypeGuard[List[int]]:
    return isinstance(obj, list)

def process_item(obj: Union[List[int], Dict[str, int]]) -> int:
    if is_list(obj):
        # 类型检查器知道这里obj是List[int]
        return sum(obj)
    else:
        # 类型检查器知道这里obj是Dict[str, int]
        return sum(obj.values())
```

### 使用overload装饰器

`overload`装饰器允许为一个函数定义多个类型签名：

```python
from typing import overload, Union, List, Dict

@overload
def process(data: List[int]) -> int: ...

@overload
def process(data: Dict[str, int]) -> str: ...

def process(data: Union[List[int], Dict[str, int]]) -> Union[int, str]:
    if isinstance(data, list):
        return sum(data)
    else:
        return ", ".join(f"{k}={v}" for k, v in data.items())

# 调用
result1 = process([1, 2, 3])  # 类型检查器知道result1是int
result2 = process({"a": 1, "b": 2})  # 类型检查器知道result2是str
```

### 使用@property与类型

为类的属性方法添加类型提示：

```python
class Rectangle:
    def __init__(self, width: float, height: float) -> None:
        self._width = width
        self._height = height
    
    @property
    def width(self) -> float:
        return self._width
    
    @width.setter
    def width(self, value: float) -> None:
        if value <= 0:
            raise ValueError("Width must be positive")
        self._width = value
    
    @property
    def area(self) -> float:
        return self._width * self._height
```

### 类型注释中的self和cls

在方法中使用self和cls：

```python
class Database:
    def connect(self) -> bool:
        # 连接到数据库
        return True
    
    def query(self, sql: str) -> list:
        # 执行查询
        return []
    
    def get_connection(self) -> 'Database':
        # 返回self
        return self
    
    @classmethod
    def create(cls) -> 'Database':
        # 返回类的新实例
        return cls()
```

## 类型提示的最佳实践

### 渐进式类型化

不需要一次性为所有代码添加类型提示，可以渐进式地添加：

```python
# mypy配置
# [mypy]
# disallow_untyped_defs = False  # 不要求所有函数都有类型
# implicit_optional = True  # 允许隐式的可选类型

# 只为一些函数添加类型
def untyped_function(param):
    return param * 2

def typed_function(param: int) -> int:
    return param * 2
```

### 处理动态特性

Python的动态特性有时难以用类型提示表达：

```python
from typing import Any, Dict, cast

# 处理动态属性访问
def get_attribute(obj: Any, name: str) -> Any:
    return getattr(obj, name)

# 处理动态字典键访问
def safe_get(data: Dict[str, Any], key: str, default: Any = None) -> Any:
    return data.get(key, default)

# 使用cast进行类型转换
def process_user(user_id: Any) -> None:
    # 我们知道user_id应该是一个整数
    user_id = cast(int, user_id)
    # 现在类型检查器将user_id视为int
```

### 导入类型

可以从类型提示模块中导入类型而不运行代码：

```python
# Python 3.7+
from __future__ import annotations

# file: models.py
class User:
    def get_manager(self) -> User:  # 可以在定义前引用
        return User()

# Python 3.9+中导入注解中的类型
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from heavy_module import HeavyClass

def process(obj: 'HeavyClass') -> None:
    # HeavyClass只在类型检查时导入，不影响运行时
    pass
```

### 异步函数的类型提示

为异步函数添加类型提示：

```python
from typing import List, Dict, Any
import asyncio

async def fetch_user(user_id: int) -> Dict[str, Any]:
    await asyncio.sleep(1)  # 模拟网络请求
    return {"id": user_id, "name": f"User {user_id}"}

async def fetch_all_users(user_ids: List[int]) -> List[Dict[str, Any]]:
    tasks = [fetch_user(user_id) for user_id in user_ids]
    return await asyncio.gather(*tasks)
```

## 类型提示与文档

### 文档字符串与类型提示

类型提示可以与文档字符串结合使用：

```python
def calculate_area(width: float, height: float) -> float:
    """
    计算矩形面积。
    
    Args:
        width: 矩形的宽度，单位为米
        height: 矩形的高度，单位为米
        
    Returns:
        矩形的面积，单位为平方米
        
    Raises:
        ValueError: 如果宽度或高度为负数
    """
    if width < 0 or height < 0:
        raise ValueError("宽度和高度必须为非负数")
    return width * height
```

### 自动文档生成

使用sphinx-autodoc等工具可以从类型提示自动生成文档：

```python
# 安装sphinx和sphinx-autodoc-typehints
# pip install sphinx sphinx-autodoc-typehints

# 在sphinx配置文件conf.py中启用
# extensions = ['sphinx.ext.autodoc', 'sphinx_autodoc_typehints']
```

## 实际应用示例

### Web API类型提示

在Web API中使用类型提示：

```python
from typing import Dict, List, Any, Optional
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

class User(BaseModel):
    id: int
    name: str
    email: str
    active: bool = True

app = FastAPI()

@app.get("/users/{user_id}", response_model=User)
async def get_user(user_id: int) -> Dict[str, Any]:
    if user_id <= 0:
        raise HTTPException(status_code=404, detail="User not found")
    return {"id": user_id, "name": f"User {user_id}", "email": f"user{user_id}@example.com", "active": True}

@app.post("/users/", response_model=User)
async def create_user(user: User) -> Dict[str, Any]:
    # 创建用户
    return user.dict()
```

### 数据处理管道

在数据处理管道中使用类型提示：

```python
from typing import List, Dict, Any, Callable, TypeVar, cast

T = TypeVar('T')
ProcessFunc = Callable[[Dict[str, Any]], Dict[str, Any]]

def apply_pipeline(data: List[Dict[str, Any]], *processors: ProcessFunc) -> List[Dict[str, Any]]:
    """应用一系列处理函数到数据列表。"""
    result = data
    for processor in processors:
        result = [processor(item) for item in result]
    return result

# 处理函数
def normalize_names(item: Dict[str, Any]) -> Dict[str, Any]:
    if 'name' in item:
        item['name'] = item['name'].lower()
    return item

def add_timestamp(item: Dict[str, Any]) -> Dict[str, Any]:
    from datetime import datetime
    item['timestamp'] = datetime.now().isoformat()
    return item

# 使用管道
data = [{"name": "Alice"}, {"name": "BOB"}]
processed_data = apply_pipeline(data, normalize_names, add_timestamp)
```

### 插件系统

使用类型提示设计插件系统：

```python
from typing import Protocol, Dict, Any, List, Type

class Plugin(Protocol):
    @property
    def name(self) -> str:
        ...
    
    def initialize(self, config: Dict[str, Any]) -> bool:
        ...
    
    def process(self, data: Any) -> Any:
        ...

class PluginManager:
    def __init__(self) -> None:
        self.plugins: Dict[str, Plugin] = {}
    
    def register_plugin(self, plugin: Plugin) -> None:
        self.plugins[plugin.name] = plugin
    
    def get_plugin(self, name: str) -> Plugin:
        if name not in self.plugins:
            raise ValueError(f"Plugin {name} not found")
        return self.plugins[name]
    
    def initialize_all(self, config: Dict[str, Any]) -> List[str]:
        """初始化所有插件，返回成功初始化的插件名称列表。"""
        successful: List[str] = []
        for name, plugin in self.plugins.items():
            if plugin.initialize(config):
                successful.append(name)
        return successful

# 使用示例
class LoggerPlugin:
    @property
    def name(self) -> str:
        return "logger"
    
    def initialize(self, config: Dict[str, Any]) -> bool:
        print(f"Initializing logger with {config}")
        return True
    
    def process(self, data: Any) -> Any:
        print(f"Logging: {data}")
        return data

# 注册插件
manager = PluginManager()
manager.register_plugin(LoggerPlugin())
manager.initialize_all({"log_level": "info"})
```

## 类型提示的未来发展

### Python 3.10及以上的新特性

Python 3.10引入了新的类型提示特性：

```python
# 联合类型的新语法
# Python 3.9: from typing import Union; x: Union[int, str]
x: int | str = "hello"

# 带类型参数的内置集合
# Python 3.9: from typing import List; x: List[int]
x: list[int] = [1, 2, 3]

# 参数规范 (PEP 612)
from typing import ParamSpec, Callable, TypeVar

P = ParamSpec('P')
R = TypeVar('R')

def logged(f: Callable[P, R]) -> Callable[P, R]:
    def wrapped(*args: P.args, **kwargs: P.kwargs) -> R:
        print(f"Calling {f.__name__}")
        return f(*args, **kwargs)
    return wrapped
```

### Python 3.11的类型增强

Python 3.11进一步增强了类型系统：

```python
# 变量注解的类型保护
def process(x: str | int) -> None:
    if isinstance(x, str):
        # Python 3.11更精确地理解x在这里是str类型
        print(x.upper())
    else:
        # Python 3.11更精确地理解x在这里是int类型
        print(x + 1)

# Self类型 (PEP 673)
from typing import Self

class Builder:
    def add_attribute(self, key: str, value: str) -> Self:
        setattr(self, key, value)
        return self
    
    @classmethod
    def create(cls) -> Self:
        return cls()
```

### 运行时类型检查

除了静态类型检查，也可以实现运行时类型检查：

```python
from typing import List, Dict, Any, cast, get_type_hints
import inspect

def enforce_types(func):
    """强制运行时类型检查的装饰器。"""
    signature = inspect.signature(func)
    type_hints = get_type_hints(func)
    
    def wrapper(*args, **kwargs):
        bound = signature.bind(*args, **kwargs)
        bound.apply_defaults()
        
        # 检查参数类型
        for name, value in bound.arguments.items():
            if name in type_hints:
                expected_type = type_hints[name]
                if not isinstance(value, expected_type):
                    raise TypeError(f"Argument {name} must be {expected_type}, got {type(value)}")
        
        result = func(*args, **kwargs)
        
        # 检查返回值类型
        if 'return' in type_hints:
            expected_return_type = type_hints['return']
            if not isinstance(result, expected_return_type):
                raise TypeError(f"Return value must be {expected_return_type}, got {type(result)}")
        
        return result
    
    return wrapper

@enforce_types
def add(a: int, b: int) -> int:
    return a + b

# 正确调用
print(add(1, 2))  # 输出: 3

# 错误调用，会在运行时引发TypeError
# print(add("1", 2))
```

## 总结

类型提示为Python代码增加了清晰的接口定义和文档，并通过静态分析工具帮助开发者捕获潜在的错误。虽然Python保持了其动态特性，但类型提示使得代码更易于理解、维护和重构。

随着Python类型系统的不断发展，越来越多的开发者和项目开始采用类型提示，它已成为现代Python开发的重要组成部分。无论是个人项目还是大型企业应用，适当使用类型提示都能提高代码质量和开发效率。
