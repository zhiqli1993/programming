# 上下文管理器

上下文管理器是Python中一种用于管理资源分配和释放的机制，通常与`with`语句一起使用。它提供了一种优雅的方式来确保资源（如文件、网络连接、数据库连接等）在使用后得到正确释放，无论操作过程中是否发生异常。

## 上下文管理器协议

实现上下文管理器需要定义以下两个方法：

1. `__enter__(self)`: 在进入`with`块之前调用，返回值会被赋给`as`子句中的变量
2. `__exit__(self, exc_type, exc_val, exc_tb)`: 在退出`with`块时调用，无论是正常退出还是发生异常
   - `exc_type`: 异常类型，如果没有异常则为`None`
   - `exc_val`: 异常实例，如果没有异常则为`None`
   - `exc_tb`: 异常的回溯信息，如果没有异常则为`None`
   - 返回`True`表示异常已处理，不再向上传播；返回`False`或`None`表示异常会继续传播

## 基本上下文管理器示例

### 文件操作

Python的`open`函数返回的文件对象实现了上下文管理器协议：

```python
with open('example.txt', 'w') as file:
    file.write('Hello, world!')
# 文件会自动关闭，即使出现异常
```

### 自定义上下文管理器

```python
class Timer:
    def __enter__(self):
        import time
        self.start = time.time()
        return self
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        import time
        self.end = time.time()
        print(f"执行时间: {self.end - self.start:.6f} 秒")
        # 返回 False 表示不抑制异常
        return False
        
    def current(self):
        import time
        return time.time() - self.start
        
# 使用上下文管理器
with Timer() as timer:
    # 做一些耗时操作
    import time
    time.sleep(1.5)
    print(f"当前已执行: {timer.current():.6f} 秒")
# 输出:
# 当前已执行: 1.500123 秒
# 执行时间: 1.500345 秒
```

### 异常处理示例

```python
class DatabaseConnection:
    def __init__(self, connection_string):
        self.connection_string = connection_string
        self.connection = None
        
    def __enter__(self):
        print(f"连接到数据库: {self.connection_string}")
        self.connection = {"status": "connected"}
        return self.connection
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("关闭数据库连接")
        self.connection = None
        
        if exc_type is not None:
            print(f"处理异常: {exc_type.__name__}: {exc_val}")
            # 返回 True 表示异常已处理
            return True
            
# 无异常情况
with DatabaseConnection("postgres://localhost:5432/mydb") as conn:
    print(f"连接状态: {conn['status']}")
    
# 有异常情况
with DatabaseConnection("postgres://localhost:5432/mydb") as conn:
    print(f"连接状态: {conn['status']}")
    raise ValueError("模拟一个错误")
    
print("继续执行")  # 会执行到这里，因为异常被抑制了
```

## `contextlib` 模块

Python的标准库`contextlib`提供了一些工具，简化上下文管理器的创建和使用。

### `contextmanager` 装饰器

使用生成器函数创建上下文管理器：

```python
from contextlib import contextmanager

@contextmanager
def tempdir():
    import tempfile
    import shutil
    import os
    
    # __enter__ 部分
    path = tempfile.mkdtemp()
    print(f"创建临时目录: {path}")
    try:
        # yield 的值会被赋给 as 子句中的变量
        yield path
    finally:
        # __exit__ 部分
        print(f"删除临时目录: {path}")
        shutil.rmtree(path)
        
# 使用这个上下文管理器
with tempdir() as path:
    # 在临时目录中创建一个文件
    with open(os.path.join(path, 'test.txt'), 'w') as f:
        f.write('临时文件内容')
    print(f"在 {path} 中创建了文件")
# 临时目录会被自动删除
```

### `suppress` 上下文管理器

用于抑制特定异常：

```python
from contextlib import suppress

# 忽略文件不存在异常
with suppress(FileNotFoundError):
    os.remove('不存在的文件.txt')
    print("文件已删除")
    
print("继续执行")  # 即使文件不存在也会执行到这里
```

### `closing` 上下文管理器

确保对象在退出`with`块时调用其`close()`方法：

```python
from contextlib import closing
from urllib.request import urlopen

with closing(urlopen('https://www.python.org')) as page:
    content = page.read()
    print(f"获取了 {len(content)} 字节的数据")
# page.close() 会被自动调用
```

### `ExitStack` 上下文管理器

动态管理多个上下文管理器：

```python
from contextlib import ExitStack

def process_files(filenames):
    with ExitStack() as stack:
        # 动态打开多个文件
        files = [stack.enter_context(open(fname)) for fname in filenames]
        # 所有文件都会在退出with块时自动关闭
        
        # 处理文件
        for file in files:
            print(f"处理文件: {file.name}")
            # 文件处理逻辑...
            
# 使用示例
process_files(['file1.txt', 'file2.txt', 'file3.txt'])
```

### `nullcontext` 上下文管理器

提供一个什么都不做的上下文管理器，用于条件性地使用上下文管理器：

```python
from contextlib import nullcontext

def process_data(filename=None):
    # 根据是否提供文件名选择不同的上下文管理器
    cm = open(filename, 'r') if filename else nullcontext()
    with cm as file:
        data = file.read() if filename else "默认数据"
        print(f"处理数据: {data[:10]}...")
        
process_data()  # 使用默认数据
process_data('example.txt')  # 从文件读取数据
```

## 嵌套上下文管理器

上下文管理器可以嵌套使用，内部的上下文管理器会先退出：

```python
with open('outer.txt', 'w') as outer_file:
    outer_file.write('外部文件的内容\n')
    
    with open('inner.txt', 'w') as inner_file:
        inner_file.write('内部文件的内容\n')
        # inner_file先关闭
        
    # outer_file后关闭
    outer_file.write('回到外部文件\n')
```

## 异步上下文管理器 (Python 3.7+)

Python 3.7引入了异步上下文管理器，与`async with`语句一起使用：

```python
class AsyncDatabaseConnection:
    def __init__(self, connection_string):
        self.connection_string = connection_string
        self.connection = None
        
    async def __aenter__(self):
        print(f"异步连接到数据库: {self.connection_string}")
        # 模拟异步连接操作
        await asyncio.sleep(1)
        self.connection = {"status": "connected"}
        return self.connection
        
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        print("异步关闭数据库连接")
        # 模拟异步关闭操作
        await asyncio.sleep(0.5)
        self.connection = None
        return False
        
# 使用异步上下文管理器
import asyncio

async def main():
    async with AsyncDatabaseConnection("postgres://localhost:5432/mydb") as conn:
        print(f"连接状态: {conn['status']}")
        await asyncio.sleep(2)
        print("执行数据库操作")
        
asyncio.run(main())
```

### 异步上下文管理器的装饰器

`contextlib`也提供了`asynccontextmanager`装饰器来简化异步上下文管理器的创建：

```python
from contextlib import asynccontextmanager
import asyncio

@asynccontextmanager
async def async_tempdir():
    import tempfile
    import shutil
    
    # __aenter__ 部分
    path = tempfile.mkdtemp()
    print(f"创建临时目录: {path}")
    try:
        yield path
    finally:
        # __aexit__ 部分
        print(f"删除临时目录: {path}")
        await asyncio.sleep(0.5)  # 模拟异步操作
        shutil.rmtree(path)
        
async def main():
    async with async_tempdir() as path:
        print(f"在临时目录中工作: {path}")
        await asyncio.sleep(1)
        
asyncio.run(main())
```

## 上下文管理器的实际应用

### 资源管理

```python
class Resource:
    def __init__(self, name):
        self.name = name
        
    def __enter__(self):
        print(f"获取资源: {self.name}")
        return self
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        print(f"释放资源: {self.name}")
        if exc_type:
            print(f"处理资源 {self.name} 异常: {exc_val}")
        
    def use(self):
        print(f"使用资源: {self.name}")
        
def resource_intensive_operation():
    with Resource("database") as db, Resource("network") as net:
        db.use()
        net.use()
        # 即使这里出现异常，资源也会被正确释放
        print("执行操作")
        
resource_intensive_operation()
```

### 事务管理

```python
class Transaction:
    def __init__(self, connection):
        self.connection = connection
        
    def __enter__(self):
        print("开始事务")
        self.connection.execute("BEGIN TRANSACTION")
        return self
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type:
            print(f"回滚事务: {exc_val}")
            self.connection.execute("ROLLBACK")
        else:
            print("提交事务")
            self.connection.execute("COMMIT")
            
# 模拟数据库连接
class Connection:
    def execute(self, sql):
        print(f"执行SQL: {sql}")
        
conn = Connection()

# 成功的事务
with Transaction(conn):
    conn.execute("INSERT INTO users VALUES ('Alice', 30)")
    conn.execute("UPDATE accounts SET balance = balance - 100 WHERE user = 'Alice'")
    
# 失败的事务
with Transaction(conn):
    conn.execute("INSERT INTO users VALUES ('Bob', 25)")
    raise ValueError("发生错误")  # 将导致事务回滚
```

### 环境设置与恢复

```python
import os

class EnvironmentVariableContext:
    def __init__(self, **kwargs):
        self.env_vars = kwargs
        self.original = {}
        
    def __enter__(self):
        # 保存原始环境变量
        for key, value in self.env_vars.items():
            self.original[key] = os.environ.get(key)
            os.environ[key] = value
        return self
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        # 恢复原始环境变量
        for key in self.env_vars:
            if self.original[key] is None:
                del os.environ[key]
            else:
                os.environ[key] = self.original[key]
                
# 使用示例
with EnvironmentVariableContext(DEBUG='1', API_KEY='test_key'):
    print(f"DEBUG环境变量: {os.environ.get('DEBUG')}")
    print(f"API_KEY环境变量: {os.environ.get('API_KEY')}")
    # 在此环境中运行代码
    
# 退出后环境变量恢复原状
print(f"DEBUG环境变量: {os.environ.get('DEBUG')}")
```

### 日志上下文

```python
import logging

class LoggingContext:
    def __init__(self, logger, level=None, handler=None, formatter=None):
        self.logger = logger
        self.level = level
        self.handler = handler
        self.formatter = formatter
        self.old_level = None
        
    def __enter__(self):
        if self.level is not None:
            self.old_level = self.logger.level
            self.logger.setLevel(self.level)
            
        if self.handler:
            self.handler.setFormatter(self.formatter)
            self.logger.addHandler(self.handler)
            
        return self.logger
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.level is not None:
            self.logger.setLevel(self.old_level)
            
        if self.handler:
            self.logger.removeHandler(self.handler)
            
# 使用示例
logger = logging.getLogger('my_app')
logger.setLevel(logging.WARNING)

# 创建一个处理器和格式化器
handler = logging.StreamHandler()
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# 临时提高日志级别
with LoggingContext(logger, level=logging.DEBUG, handler=handler, formatter=formatter):
    logger.debug("这是一条调试日志")  # 将被记录
    logger.info("这是一条信息日志")   # 将被记录
    logger.warning("这是一条警告日志") # 将被记录
    
# 恢复到之前的级别
logger.debug("这是一条调试日志")  # 不会被记录
logger.warning("这是一条警告日志") # 将被记录
```

## 上下文管理器最佳实践

1. **资源释放**: 使用上下文管理器确保资源始终得到释放，无论是否发生异常
2. **异常处理**: 在`__exit__`方法中谨慎处理异常，只在确实可以恢复的情况下返回`True`
3. **可重入性**: 确保上下文管理器可以安全地多次进入
4. **简洁性**: 对于简单情况，优先使用`@contextmanager`装饰器而不是实现完整的协议
5. **异步支持**: 在异步代码中使用异步上下文管理器
6. **组合使用**: 使用`ExitStack`动态组合多个上下文管理器
7. **清晰的文档**: 记录上下文管理器的行为，特别是关于异常处理和资源管理的方面

## 上下文管理器内部机制

当执行`with`语句时，Python解释器会：

1. 调用上下文管理器的`__enter__`方法
2. 将`__enter__`的返回值赋给`as`子句中的变量（如果有的话）
3. 执行`with`块中的代码
4. 无论`with`块是否正常完成，都会调用`__exit__`方法
5. 如果`with`块引发异常，并且`__exit__`返回`False`或`None`，异常会继续传播
6. 如果`__exit__`返回`True`，异常会被抑制

理解这个过程对于正确实现和使用上下文管理器至关重要。
