# 描述符协议

描述符是Python中实现属性访问控制的强大机制，它允许开发者自定义对象属性的获取、设置和删除行为。描述符是实现了特定"描述符协议"方法的对象。

## 描述符协议基础

描述符是实现了以下一个或多个特殊方法的对象：

- `__get__(self, instance, owner)`: 定义当获取属性时的行为
- `__set__(self, instance, value)`: 定义当设置属性时的行为
- `__delete__(self, instance)`: 定义当删除属性时的行为
- `__set_name__(self, owner, name)`: 当描述符被分配给类属性时自动调用（Python 3.6+）

### 描述符类型

描述符可以分为两种类型：

1. **数据描述符**：同时实现了`__get__`和`__set__`方法
2. **非数据描述符**：只实现了`__get__`方法

这两种类型在属性查找顺序上有重要区别：数据描述符优先于实例字典，而非数据描述符则相反。

## 描述符的基本示例

### 简单的只读描述符

```python
class Constant:
    def __init__(self, value):
        self.value = value
        
    def __get__(self, instance, owner):
        return self.value
        
class Math:
    PI = Constant(3.14159)
    E = Constant(2.71828)
    
math = Math()
print(math.PI)  # 输出: 3.14159
```

### 类型验证描述符

```python
class Typed:
    def __init__(self, name, expected_type):
        self.name = name
        self.expected_type = expected_type
        
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__.get(self.name)
        
    def __set__(self, instance, value):
        if not isinstance(value, self.expected_type):
            raise TypeError(f"Expected {self.expected_type}, got {type(value)}")
        instance.__dict__[self.name] = value
        
    def __delete__(self, instance):
        del instance.__dict__[self.name]
        
class Person:
    name = Typed("name", str)
    age = Typed("age", int)
    
    def __init__(self, name, age):
        self.name = name
        self.age = age
        
p = Person("Alice", 30)
print(p.name, p.age)  # 输出: Alice 30

# 这会引发TypeError
# p.age = "thirty"
```

### 使用`__set_name__`简化描述符

Python 3.6引入了`__set_name__`方法，它在描述符被分配给类属性时自动调用，简化了描述符的实现：

```python
class Typed:
    def __init__(self, expected_type):
        self.expected_type = expected_type
        self.name = None
        
    def __set_name__(self, owner, name):
        self.name = name
        
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__.get(self.name)
        
    def __set__(self, instance, value):
        if not isinstance(value, self.expected_type):
            raise TypeError(f"{self.name} must be {self.expected_type.__name__}")
        instance.__dict__[self.name] = value
        
class Person:
    name = Typed(str)
    age = Typed(int)
    
    def __init__(self, name, age):
        self.name = name
        self.age = age
```

## 描述符应用场景

### 属性验证

描述符可以用于验证属性值是否符合特定条件：

```python
class Positive:
    def __init__(self):
        self.name = None
        
    def __set_name__(self, owner, name):
        self.name = name
        
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__.get(self.name, 0)
        
    def __set__(self, instance, value):
        if value <= 0:
            raise ValueError(f"{self.name} must be positive")
        instance.__dict__[self.name] = value
        
class Product:
    price = Positive()
    quantity = Positive()
    
    def __init__(self, price, quantity):
        self.price = price
        self.quantity = quantity
        
    @property
    def total(self):
        return self.price * self.quantity
        
p = Product(10, 5)
print(p.total)  # 输出: 50

# 这会引发ValueError
# p.price = -10
```

### 延迟计算属性

描述符可以用于实现属性的延迟计算，只有在首次访问时才计算值：

```python
class LazyProperty:
    def __init__(self, func):
        self.func = func
        self.name = func.__name__
        
    def __get__(self, instance, owner):
        if instance is None:
            return self
            
        # 计算值并存储在实例字典中
        value = self.func(instance)
        instance.__dict__[self.name] = value
        return value
        
class DataProcessor:
    def __init__(self, data):
        self.data = data
        
    @LazyProperty
    def processed_data(self):
        print("处理数据...")
        # 假设这是一个耗时操作
        result = [x * 2 for x in self.data]
        return result
        
processor = DataProcessor([1, 2, 3, 4, 5])
# 首次访问时计算
print(processor.processed_data)  # 输出: 处理数据... [2, 4, 6, 8, 10]
# 再次访问时直接返回缓存的结果
print(processor.processed_data)  # 输出: [2, 4, 6, 8, 10]
```

### 单位转换

描述符可以用于自动在不同单位之间转换：

```python
class Celsius:
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance._temperature
        
    def __set__(self, instance, value):
        instance._temperature = value
        
class Fahrenheit:
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance._temperature * 9/5 + 32
        
    def __set__(self, instance, value):
        instance._temperature = (value - 32) * 5/9
        
class Temperature:
    celsius = Celsius()
    fahrenheit = Fahrenheit()
    
    def __init__(self, celsius=0):
        self._temperature = celsius
        
temp = Temperature(25)
print(f"{temp.celsius}°C = {temp.fahrenheit}°F")  # 输出: 25°C = 77.0°F
temp.fahrenheit = 68
print(f"{temp.celsius}°C = {temp.fahrenheit}°F")  # 输出: 20.0°C = 68.0°F
```

## 描述符与属性查找顺序

Python的属性查找遵循一定的顺序：

1. 类中定义的数据描述符
2. 实例字典
3. 类中定义的非数据描述符
4. 类字典
5. 父类属性（按照MRO顺序）
6. 如果所有步骤都失败，调用`__getattr__`（如果定义了的话）

理解这个顺序对于正确实现描述符至关重要。

## 方法作为描述符

在Python中，方法实际上是作为非数据描述符实现的：

```python
class Method:
    def __init__(self, func):
        self.func = func
        
    def __get__(self, instance, owner):
        if instance is None:
            return self
        # 返回一个绑定方法，将实例作为第一个参数传递
        return lambda *args, **kwargs: self.func(instance, *args, **kwargs)
        
class MyClass:
    def __init__(self, value):
        self.value = value
        
    @Method
    def print_value(self):
        print(self.value)
        
obj = MyClass(42)
obj.print_value()  # 输出: 42
```

这与Python内置的方法行为类似，当你访问一个实例方法时，Python会返回一个绑定到该实例的方法对象。

## 属性描述符与`property`

Python的内置`property`函数实际上是一个数据描述符的工厂函数：

```python
class Person:
    def __init__(self, name):
        self._name = name
        
    @property
    def name(self):
        return self._name
        
    @name.setter
    def name(self, value):
        if not isinstance(value, str):
            raise TypeError("Name must be a string")
        self._name = value
```

`property`的实现类似于：

```python
class Property:
    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
        self.__doc__ = doc
        
    def __get__(self, instance, owner):
        if instance is None:
            return self
        if self.fget is None:
            raise AttributeError("unreadable attribute")
        return self.fget(instance)
        
    def __set__(self, instance, value):
        if self.fset is None:
            raise AttributeError("can't set attribute")
        self.fset(instance, value)
        
    def __delete__(self, instance):
        if self.fdel is None:
            raise AttributeError("can't delete attribute")
        self.fdel(instance)
        
    def setter(self, func):
        return type(self)(self.fget, func, self.fdel, self.__doc__)
        
    def deleter(self, func):
        return type(self)(self.fget, self.fset, func, self.__doc__)
```

## 描述符与实例变量存储

描述符通常有两种存储实例数据的方式：

### 1. 在实例字典中存储

```python
class Descriptor:
    def __init__(self):
        self.name = None
        
    def __set_name__(self, owner, name):
        self.name = name
        
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__.get(self.name)
        
    def __set__(self, instance, value):
        instance.__dict__[self.name] = value
```

### 2. 在描述符实例中存储

```python
class Descriptor:
    def __init__(self):
        self.values = {}
        
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return self.values.get(instance, None)
        
    def __set__(self, instance, value):
        self.values[instance] = value
```

第二种方法可能导致内存泄漏，因为描述符持有对实例的引用。最佳实践是使用弱引用：

```python
import weakref

class Descriptor:
    def __init__(self):
        self.values = weakref.WeakKeyDictionary()
        
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return self.values.get(instance)
        
    def __set__(self, instance, value):
        self.values[instance] = value
```

## 描述符最佳实践

1. **使用`__set_name__`**: 在Python 3.6+中，利用`__set_name__`自动获取描述符的名称
2. **使用适当的存储**: 针对不同场景选择合适的实例数据存储方式
3. **区分数据和非数据描述符**: 根据需要实现`__set__`
4. **文档化描述符行为**: 清楚描述描述符的作用和用法
5. **组合描述符**: 创建可复用的描述符类并组合使用
6. **考虑性能影响**: 描述符在属性访问时会有额外开销

## 描述符组合示例

```python
class Validated:
    def __set_name__(self, owner, name):
        self.name = name
        
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__.get(self.name)
        
    def __set__(self, instance, value):
        self.validate(value)
        instance.__dict__[self.name] = value
        
    def validate(self, value):
        pass
        
class String(Validated):
    def validate(self, value):
        if not isinstance(value, str):
            raise TypeError(f"{self.name} must be a string")
            
class PositiveNumber(Validated):
    def validate(self, value):
        if not isinstance(value, (int, float)):
            raise TypeError(f"{self.name} must be a number")
        if value <= 0:
            raise ValueError(f"{self.name} must be positive")
            
class OneOf(Validated):
    def __init__(self, *options):
        self.options = options
        
    def validate(self, value):
        if value not in self.options:
            raise ValueError(f"{self.name} must be one of {self.options}")
            
class Product:
    name = String()
    price = PositiveNumber()
    category = OneOf('electronics', 'clothing', 'food')
    
    def __init__(self, name, price, category):
        self.name = name
        self.price = price
        self.category = category
```

## 实际应用中的描述符

描述符在许多Python库和框架中广泛使用：

1. **Django ORM**: 模型字段是描述符
2. **SQLAlchemy**: 列定义是描述符
3. **attrs/dataclasses**: 字段验证和转换
4. **NumPy**: 数组视图和切片

理解描述符协议可以帮助开发者更好地理解和使用这些库，并在必要时创建自定义描述符来解决特定问题。
