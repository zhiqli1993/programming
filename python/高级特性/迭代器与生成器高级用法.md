# 迭代器与生成器高级用法

## 迭代器协议

迭代器是实现了迭代器协议的对象，具体包括:
- `__iter__()` 方法返回迭代器自身
- `__next__()` 方法返回下一个值，当没有更多值时抛出 StopIteration 异常

```python
class Countdown:
    def __init__(self, start):
        self.start = start
        
    def __iter__(self):
        return self
        
    def __next__(self):
        if self.start <= 0:
            raise StopIteration
        self.start -= 1
        return self.start + 1
        
# 使用迭代器
for i in Countdown(5):
    print(i)  # 输出: 5, 4, 3, 2, 1
```

## 生成器函数与表达式

### 生成器函数

生成器函数是包含 `yield` 语句的函数，每次调用 `yield` 会暂停函数执行并返回一个值。

```python
def fibonacci(n):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b
        
# 使用生成器
for num in fibonacci(10):
    print(num)  # 输出斐波那契数列的前10个数
```

### 生成器表达式

生成器表达式是一种创建生成器的简洁语法，类似于列表推导式但使用圆括号。

```python
# 生成器表达式
squares = (x*x for x in range(10))
print(next(squares))  # 0
print(next(squares))  # 1
```

## 高级生成器特性

### send() 方法

使用 `send()` 方法可以向生成器发送值，该值会成为 `yield` 表达式的结果。

```python
def echo():
    value = None
    while True:
        value = yield value
        print(f"Got: {value}")
        
gen = echo()
next(gen)  # 启动生成器
gen.send("Hello")  # 输出: Got: Hello
gen.send("World")  # 输出: Got: World
```

### throw() 和 close() 方法

- `throw()` 向生成器抛出异常
- `close()` 关闭生成器，引发 GeneratorExit 异常

```python
def sample_generator():
    try:
        yield 1
        yield 2
        yield 3
    except ValueError:
        print("ValueError caught!")
    finally:
        print("Generator closed")
        
gen = sample_generator()
print(next(gen))  # 1
gen.throw(ValueError)  # 输出: ValueError caught!
                       # 输出: Generator closed
                       # 抛出 StopIteration
```

## yield from 语法

`yield from` 用于将一个生成器委托给另一个生成器，简化嵌套生成器的代码。

```python
def sub_generator():
    yield 1
    yield 2
    yield 3
    
def main_generator():
    yield "Start"
    yield from sub_generator()
    yield "End"
    
for item in main_generator():
    print(item)  # 输出: Start, 1, 2, 3, End
```

## 迭代器与生成器的应用场景

1. 处理大数据集：生成器允许惰性计算，避免将整个数据集加载到内存
2. 无限序列：创建可能无限长的序列但只计算需要的部分
3. 数据管道：构建数据处理管道，每个阶段都是一个生成器
4. 协程：使用生成器实现简单的协程系统（在asyncio出现前）

## 性能考量

生成器和迭代器的主要优势:
- 内存效率：只在需要时计算值
- 按需计算：对于大数据或无限序列特别有用
- 组合性：易于将多个生成器组合成处理管道

然而，迭代器只能遍历一次，如果需要多次访问同一数据，可能需要重新生成或使用其他数据结构。
