# 魔术方法和运算符重载

Python的魔术方法（Magic Methods）是以双下划线开头和结尾的特殊方法，它们允许自定义类行为并实现运算符重载。通过实现这些方法，可以使自定义对象行为类似于内置类型。

## 对象创建与初始化

### `__new__` 和 `__init__`

```python
class MyClass:
    def __new__(cls, *args, **kwargs):
        print("创建实例")
        instance = super().__new__(cls)
        return instance
        
    def __init__(self, value):
        print("初始化实例")
        self.value = value
        
    def __del__(self):
        print(f"销毁值为 {self.value} 的实例")
```

- `__new__`：类方法，负责创建并返回实例，先于`__init__`调用
- `__init__`：实例方法，负责初始化实例属性
- `__del__`：当对象被垃圾回收时调用

## 对象表示

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        
    def __repr__(self):
        return f"Vector({self.x}, {self.y})"
        
    def __str__(self):
        return f"({self.x}, {self.y})"
        
    def __format__(self, format_spec):
        if format_spec == 'p':  # 极坐标
            import math
            r = math.sqrt(self.x**2 + self.y**2)
            theta = math.atan2(self.y, self.x)
            return f"r={r:.2f}, θ={theta:.2f}"
        return str(self)
```

- `__repr__`：返回对象的"官方"字符串表示，应包含重建对象所需的信息
- `__str__`：返回对象的"非正式"字符串表示，面向用户友好
- `__format__`：自定义格式化，如`format(obj, 'p')`或f字符串

## 比较操作符

```python
class Temperature:
    def __init__(self, celsius):
        self.celsius = celsius
        
    def __eq__(self, other):
        if isinstance(other, Temperature):
            return self.celsius == other.celsius
        return self.celsius == other
        
    def __lt__(self, other):
        if isinstance(other, Temperature):
            return self.celsius < other.celsius
        return self.celsius < other
        
    def __le__(self, other):
        return self < other or self == other
```

主要比较魔术方法:
- `__eq__`: 等于 (`==`)
- `__ne__`: 不等于 (`!=`)，通常从`__eq__`派生
- `__lt__`: 小于 (`<`)
- `__le__`: 小于等于 (`<=`)
- `__gt__`: 大于 (`>`)
- `__ge__`: 大于等于 (`>=`)

## 数值操作符

```python
class Vector2D:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        
    def __add__(self, other):
        if isinstance(other, Vector2D):
            return Vector2D(self.x + other.x, self.y + other.y)
        return NotImplemented
        
    def __sub__(self, other):
        if isinstance(other, Vector2D):
            return Vector2D(self.x - other.x, self.y - other.y)
        return NotImplemented
        
    def __mul__(self, scalar):
        if isinstance(scalar, (int, float)):
            return Vector2D(self.x * scalar, self.y * scalar)
        return NotImplemented
        
    def __rmul__(self, scalar):
        return self.__mul__(scalar)
        
    def __neg__(self):
        return Vector2D(-self.x, -self.y)
        
    def __abs__(self):
        return (self.x**2 + self.y**2)**0.5
```

- `__add__`, `__sub__`, `__mul__`: 加、减、乘
- `__radd__`, `__rsub__`, `__rmul__`: 反向操作（右操作数为自定义类型）
- `__iadd__`, `__isub__`, `__imul__`: 增强赋值 (`+=`, `-=`, `*=`)
- `__neg__`: 负号 (`-obj`)
- `__abs__`: 绝对值 (`abs(obj)`)

## 容器行为

```python
class CustomDict:
    def __init__(self):
        self._data = {}
        
    def __getitem__(self, key):
        return self._data[key]
        
    def __setitem__(self, key, value):
        self._data[key] = value
        
    def __delitem__(self, key):
        del self._data[key]
        
    def __contains__(self, key):
        return key in self._data
        
    def __len__(self):
        return len(self._data)
        
    def __iter__(self):
        return iter(self._data)
```

- `__getitem__`: 索引访问 (`obj[key]`)
- `__setitem__`: 索引赋值 (`obj[key] = value`)
- `__delitem__`: 索引删除 (`del obj[key]`)
- `__contains__`: 成员检测 (`key in obj`)
- `__len__`: 长度 (`len(obj)`)
- `__iter__`: 迭代 (`for x in obj`)

## 可调用对象

```python
class Multiplier:
    def __init__(self, factor):
        self.factor = factor
        
    def __call__(self, x):
        return x * self.factor
        
double = Multiplier(2)
print(double(10))  # 输出: 20
```

- `__call__`: 使对象可以像函数一样调用

## 上下文管理

```python
class DatabaseConnection:
    def __init__(self, connection_string):
        self.connection_string = connection_string
        self.connection = None
        
    def __enter__(self):
        print(f"连接到 {self.connection_string}")
        self.connection = {"状态": "已连接"}
        return self.connection
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("关闭连接")
        self.connection = None
        return False  # 不抑制异常
```

- `__enter__`: 进入上下文 (`with obj as x:`)
- `__exit__`: 退出上下文并处理异常

## 属性访问控制

```python
class Person:
    def __init__(self, name):
        self._name = name
        
    def __getattr__(self, name):
        return f"属性 {name} 不存在"
        
    def __setattr__(self, name, value):
        print(f"设置 {name} = {value}")
        super().__setattr__(name, value)
        
    def __delattr__(self, name):
        print(f"删除属性 {name}")
        super().__delattr__(name)
        
    def __getattribute__(self, name):
        print(f"获取属性 {name}")
        return super().__getattribute__(name)
```

- `__getattr__`: 访问不存在的属性时调用
- `__getattribute__`: 访问任何属性时调用（谨慎使用，易导致无限递归）
- `__setattr__`: 设置任何属性时调用
- `__delattr__`: 删除任何属性时调用

## 序列化

```python
class User:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        
    def __getstate__(self):
        state = self.__dict__.copy()
        state['version'] = 1  # 添加版本信息
        del state['age']  # 移除敏感信息
        return state
        
    def __setstate__(self, state):
        if state.get('version', 0) == 1:
            state['age'] = None  # 恢复缺失信息的默认值
        self.__dict__.update(state)
```

- `__getstate__`: 控制对象pickle序列化内容
- `__setstate__`: 控制对象pickle反序列化过程

## 高级运算符重载示例

```python
class DecimalFraction:
    def __init__(self, numerator, denominator=1):
        self.numerator = numerator
        self.denominator = denominator
        self._normalize()
        
    def _normalize(self):
        from math import gcd
        g = gcd(self.numerator, self.denominator)
        self.numerator //= g
        self.denominator //= g
        
    def __float__(self):
        return self.numerator / self.denominator
        
    def __int__(self):
        return self.numerator // self.denominator
        
    def __round__(self, ndigits=0):
        value = round(float(self), ndigits)
        if ndigits == 0:
            return int(value)
        return value
        
    def __complex__(self):
        return complex(float(self), 0)
        
    def __bool__(self):
        return self.numerator != 0
        
    def __hash__(self):
        return hash((self.numerator, self.denominator))
```

- `__float__`, `__int__`, `__complex__`: 类型转换
- `__round__`: 四舍五入
- `__bool__`: 布尔上下文
- `__hash__`: 使对象可哈希，用于字典键和集合成员

## 描述符协议与魔术方法

```python
class Positive:
    def __set_name__(self, owner, name):
        self.name = f"_{name}"
        
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return getattr(instance, self.name, 0)
        
    def __set__(self, instance, value):
        if value <= 0:
            raise ValueError("值必须为正数")
        setattr(instance, self.name, value)
        
class Product:
    price = Positive()
    quantity = Positive()
    
    def __init__(self, price, quantity):
        self.price = price
        self.quantity = quantity
```

- `__set_name__`: 设置描述符名称（Python 3.6+）
- `__get__`: 获取属性
- `__set__`: 设置属性
- `__delete__`: 删除属性

## 最佳实践

1. **保持一致性**: 实现对称的魔术方法（例如，如果实现了`__eq__`，也应该实现`__ne__`）
2. **返回 NotImplemented**: 当不支持操作或类型不兼容时，返回`NotImplemented`而不是抛出异常
3. **避免过度使用**: 不要为了炫技而实现不必要的魔术方法
4. **文档化**: 记录自定义行为，特别是当行为与内置类型不一致时
5. **防止递归**: 在像`__getattribute__`这样的方法中小心递归调用
