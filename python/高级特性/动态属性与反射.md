# 动态属性与反射

Python是一种高度动态的语言，允许在运行时检查、修改和操作对象的属性和结构。这种能力称为反射（Reflection），是Python灵活性和动态特性的核心。

## 动态属性访问

### 基本属性访问

Python提供了多种方式来动态访问和修改对象的属性：

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# 创建实例
p = Person("Alice", 30)

# 直接访问属性
print(p.name)  # 输出: Alice

# 使用getattr函数动态访问属性
name = getattr(p, "name")
print(name)  # 输出: Alice

# 提供默认值（当属性不存在时）
email = getattr(p, "email", "未设置")
print(email)  # 输出: 未设置

# 使用setattr函数动态设置属性
setattr(p, "email", "alice@example.com")
print(p.email)  # 输出: alice@example.com

# 使用hasattr函数检查属性是否存在
print(hasattr(p, "name"))  # 输出: True
print(hasattr(p, "address"))  # 输出: False

# 使用delattr函数删除属性
delattr(p, "email")
print(hasattr(p, "email"))  # 输出: False
```

### 属性字典`__dict__`

每个Python对象都有一个`__dict__`属性，它是一个字典，包含了对象的所有属性：

```python
# 查看对象的__dict__属性
print(p.__dict__)  # 输出: {'name': 'Alice', 'age': 30}

# 直接修改__dict__
p.__dict__['height'] = 175
print(p.height)  # 输出: 175

# 注意：使用__slots__的类实例没有__dict__属性
class SlottedPerson:
    __slots__ = ['name', 'age']
    
    def __init__(self, name, age):
        self.name = name
        self.age = age

sp = SlottedPerson("Bob", 25)
# print(sp.__dict__)  # 这会引发AttributeError
```

### 拦截属性访问

Python允许通过特殊方法拦截属性访问：

```python
class DynamicPerson:
    def __init__(self, **kwargs):
        # 存储提供的所有属性
        for key, value in kwargs.items():
            setattr(self, key, value)
    
    def __getattr__(self, name):
        """当属性不存在时调用"""
        return f"属性 {name} 不存在"
    
    def __setattr__(self, name, value):
        """当设置属性时调用"""
        print(f"设置属性: {name} = {value}")
        # 必须使用基类的__setattr__或者self.__dict__[name] = value
        # 否则会导致无限递归
        super().__setattr__(name, value)
    
    def __delattr__(self, name):
        """当删除属性时调用"""
        print(f"删除属性: {name}")
        super().__delattr__(name)
    
    def __getattribute__(self, name):
        """访问任何属性时调用，包括存在的属性"""
        print(f"获取属性: {name}")
        return super().__getattribute__(name)

# 使用动态属性类
dp = DynamicPerson(name="Charlie", age=35)
print(dp.name)  # 触发__getattribute__并输出: Charlie
print(dp.email)  # 触发__getattribute__和__getattr__
dp.address = "123 Main St"  # 触发__setattr__
del dp.address  # 触发__delattr__
```

### 属性描述符

描述符提供了更强大的方式来控制属性访问：

```python
class ValidString:
    def __init__(self, minlen=0, maxlen=100):
        self.minlen = minlen
        self.maxlen = maxlen
        self.name = None
    
    def __set_name__(self, owner, name):
        self.name = name
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__.get(self.name, "")
    
    def __set__(self, instance, value):
        if not isinstance(value, str):
            raise TypeError(f"{self.name} 必须是字符串")
        if len(value) < self.minlen:
            raise ValueError(f"{self.name} 长度不能小于 {self.minlen}")
        if len(value) > self.maxlen:
            raise ValueError(f"{self.name} 长度不能大于 {self.maxlen}")
        instance.__dict__[self.name] = value

class User:
    name = ValidString(minlen=2, maxlen=50)
    bio = ValidString(maxlen=200)
    
    def __init__(self, name, bio=""):
        self.name = name
        self.bio = bio

# 使用带描述符的类
user = User("David")
print(user.name)  # 输出: David
# user.name = "A"  # 引发ValueError: name 长度不能小于 2
user.bio = "Python开发者"
print(user.bio)  # 输出: Python开发者
```

## 内省与类型检查

### 类型和实例检查

```python
# 使用type()获取对象的类型
print(type(p))  # 输出: <class '__main__.Person'>
print(type(p) is Person)  # 输出: True

# 使用isinstance()检查对象是否是某个类的实例
print(isinstance(p, Person))  # 输出: True
print(isinstance(p, object))  # 输出: True（所有类都继承自object）
print(isinstance(p, SlottedPerson))  # 输出: False

# 使用issubclass()检查类是否是另一个类的子类
print(issubclass(Person, object))  # 输出: True
print(issubclass(SlottedPerson, Person))  # 输出: False
```

### 获取对象的属性和方法

```python
# dir()函数列出对象的所有属性和方法
print(dir(p))  # 输出所有属性和方法的列表

# vars()函数返回对象的__dict__
print(vars(p))  # 等同于p.__dict__

# 检查是否是可调用对象
def greet():
    return "Hello"

print(callable(greet))  # 输出: True
print(callable(p))  # 输出: False（除非Person定义了__call__方法）
```

### 获取类的成员

```python
class Shape:
    PI = 3.14159
    
    def __init__(self, color):
        self.color = color
    
    def area(self):
        pass
    
    @classmethod
    def factory(cls, *args, **kwargs):
        return cls(*args, **kwargs)
    
    @staticmethod
    def utility():
        return "实用方法"

# 获取类的属性
print(dir(Shape))

# 获取类的文档字符串
print(Shape.__doc__)

# 获取类的名称
print(Shape.__name__)

# 获取类的模块
print(Shape.__module__)

# 获取类的基类
print(Shape.__bases__)

# 获取类的字典
print(Shape.__dict__)
```

### 成员类型判断

```python
import inspect

# 检查对象是否是模块、类、方法等
print(inspect.ismodule(inspect))  # 输出: True
print(inspect.isclass(Person))  # 输出: True
print(inspect.isfunction(greet))  # 输出: True
print(inspect.ismethod(p.greet))  # 假设Person有greet方法

# 获取函数的参数签名
def add(a, b=1, *args, **kwargs):
    return a + b

signature = inspect.signature(add)
print(signature)  # 输出: (a, b=1, *args, **kwargs)
print(signature.parameters['a'].kind)  # 输出: POSITIONAL_OR_KEYWORD
```

## 动态创建和修改类

### 动态创建类

使用`type`函数可以动态创建类：

```python
# 动态创建类
def say_hello(self):
    return f"Hello, my name is {self.name}"

# 使用type创建类
# 参数：类名、基类元组、类字典
DynamicClass = type(
    'DynamicClass',  # 类名
    (object,),       # 基类元组
    {
        'name': "",
        'age': 0,
        'say_hello': say_hello,
        '__init__': lambda self, name, age: setattr(self, 'name', name) or setattr(self, 'age', age)
    }
)

# 使用动态创建的类
dc = DynamicClass("Eve", 28)
print(dc.say_hello())  # 输出: Hello, my name is Eve
```

### 使用元类

元类提供了更强大的方式来控制类的创建：

```python
class ModelMeta(type):
    def __new__(mcs, name, bases, attrs):
        # 在类创建前处理属性
        print(f"创建类 {name}")
        
        # 添加一个方法到类
        attrs['get_fields'] = lambda self: list(attrs.keys())
        
        # 调用父类的__new__方法来创建类
        return super().__new__(mcs, name, bases, attrs)

class Model(metaclass=ModelMeta):
    """使用ModelMeta元类的基类"""
    pass

class User(Model):
    name = "默认名称"
    email = "默认邮箱"

# 使用带元类的类
u = User()
print(u.get_fields())  # 输出类的属性列表
```

### 运行时修改类

```python
# 在运行时添加方法到类
def jump(self):
    return f"{self.name} is jumping"

# 添加到现有类
Person.jump = jump

# 现在所有Person实例都有jump方法
print(p.jump())  # 输出: Alice is jumping

# 添加类方法
@classmethod
def create(cls, name, age):
    return cls(name, age)

Person.create = create

# 使用新增的类方法
p2 = Person.create("Frank", 40)
print(p2.name)  # 输出: Frank
```

## 反射的应用

### 动态导入模块

```python
# 使用importlib动态导入模块
import importlib

# 动态导入标准库模块
math_module = importlib.import_module('math')
print(math_module.pi)  # 输出: 3.141592653589793

# 动态导入本地模块（假设有一个mymodule.py）
try:
    mymodule = importlib.import_module('mymodule')
    print(mymodule.hello())
except ImportError:
    print("找不到mymodule")

# 动态导入并重新加载
import time
time_module = importlib.reload(time)
```

### 基于字符串获取和调用方法

```python
class API:
    def get_users(self):
        return ["用户1", "用户2", "用户3"]
    
    def get_products(self):
        return ["产品1", "产品2", "产品3"]
    
    def get_orders(self):
        return ["订单1", "订单2", "订单3"]

api = API()

# 基于字符串调用方法
def call_api_method(method_name):
    if hasattr(api, method_name):
        method = getattr(api, method_name)
        if callable(method):
            return method()
        return method
    return f"方法 {method_name} 不存在"

# 调用不同的API方法
print(call_api_method("get_users"))  # 输出用户列表
print(call_api_method("get_products"))  # 输出产品列表
print(call_api_method("get_unknown"))  # 输出: 方法 get_unknown 不存在
```

### 自动注册机制

```python
# 创建一个注册表来存储处理器
handlers = {}

# 装饰器用于注册处理器
def register(name):
    def decorator(func):
        handlers[name] = func
        return func
    return decorator

# 注册各种处理器
@register("text")
def process_text(data):
    return f"处理文本: {data}"

@register("number")
def process_number(data):
    return f"处理数字: {data * 2}"

@register("list")
def process_list(data):
    return f"处理列表: {', '.join(data)}"

# 根据类型名动态调用相应的处理器
def process(type_name, data):
    if type_name in handlers:
        return handlers[type_name](data)
    return f"未知类型: {type_name}"

# 使用处理系统
print(process("text", "Hello"))  # 输出: 处理文本: Hello
print(process("number", 42))  # 输出: 处理数字: 84
print(process("list", ["a", "b", "c"]))  # 输出: 处理列表: a, b, c
```

### 序列化和反序列化

```python
class SerializableMixin:
    """提供序列化和反序列化能力的混入类"""
    
    def to_dict(self):
        """将对象转换为字典"""
        result = {}
        for key, value in self.__dict__.items():
            # 跳过私有属性
            if key.startswith('_'):
                continue
                
            # 如果值也是可序列化的，递归转换
            if hasattr(value, 'to_dict'):
                value = value.to_dict()
                
            result[key] = value
        return result
    
    @classmethod
    def from_dict(cls, data):
        """从字典创建对象"""
        instance = cls()
        for key, value in data.items():
            setattr(instance, key, value)
        return instance

class User(SerializableMixin):
    def __init__(self, name="", email="", age=0):
        self.name = name
        self.email = email
        self.age = age

# 使用序列化/反序列化
user = User("Grace", "grace@example.com", 32)
user_dict = user.to_dict()
print(user_dict)  # 输出字典表示

# 创建新用户对象
new_user = User.from_dict(user_dict)
print(new_user.name)  # 输出: Grace
```

## 反射的高级应用

### 代理和包装

```python
class Proxy:
    """代理另一个对象，可以在访问前后添加行为"""
    
    def __init__(self, obj):
        self._obj = obj
    
    def __getattr__(self, name):
        print(f"获取属性: {name}")
        return getattr(self._obj, name)
    
    def __setattr__(self, name, value):
        if name == '_obj':
            # 直接设置_obj属性
            super().__setattr__(name, value)
        else:
            print(f"设置属性: {name} = {value}")
            setattr(self._obj, name, value)
    
    def __call__(self, *args, **kwargs):
        print(f"调用对象，参数: {args}, {kwargs}")
        if callable(self._obj):
            return self._obj(*args, **kwargs)
        raise TypeError("被代理对象不可调用")

# 使用代理
def greet(name):
    return f"Hello, {name}!"

# 代理函数
proxy_func = Proxy(greet)
print(proxy_func("World"))  # 输出调用日志和 "Hello, World!"

# 代理对象
user = User("Helen", "helen@example.com", 29)
proxy_user = Proxy(user)
print(proxy_user.name)  # 输出获取属性日志和 "Helen"
proxy_user.age = 30  # 输出设置属性日志并修改age
```

### 钩子系统

```python
class HookSystem:
    """允许注册和触发钩子的系统"""
    
    def __init__(self):
        self._hooks = {}
    
    def register_hook(self, name, callback):
        """注册一个钩子"""
        if name not in self._hooks:
            self._hooks[name] = []
        self._hooks[name].append(callback)
    
    def trigger_hook(self, name, *args, **kwargs):
        """触发一个钩子"""
        if name not in self._hooks:
            return []
            
        results = []
        for callback in self._hooks[name]:
            results.append(callback(*args, **kwargs))
        return results

# 使用钩子系统
hooks = HookSystem()

# 注册钩子
hooks.register_hook("startup", lambda: print("系统启动"))
hooks.register_hook("shutdown", lambda: print("系统关闭"))
hooks.register_hook("data_received", lambda data: f"处理数据: {data}")

# 触发钩子
hooks.trigger_hook("startup")  # 输出: 系统启动
results = hooks.trigger_hook("data_received", "样本数据")
print(results)  # 输出: ['处理数据: 样本数据']
```

### 动态接口实现

```python
class DynamicInterface:
    """动态实现接口的类"""
    
    def implements(self, interface_class):
        """声明该类实现了特定接口"""
        # 检查接口中定义的所有方法
        for name, attr in interface_class.__dict__.items():
            if callable(attr) and not name.startswith('__'):
                # 检查该类是否实现了这个方法
                if not hasattr(self, name) or not callable(getattr(self, name)):
                    raise NotImplementedError(
                        f"{self.__class__.__name__} 必须实现 {name} 方法"
                    )
        return True

# 定义接口
class Drawable:
    def draw(self):
        pass
    
    def resize(self, width, height):
        pass

# 实现接口
class Circle(DynamicInterface):
    def __init__(self, x, y, radius):
        self.x = x
        self.y = y
        self.radius = radius
    
    def draw(self):
        return f"绘制位于 ({self.x}, {self.y}) 半径为 {self.radius} 的圆"
    
    def resize(self, width, height):
        self.radius = (width + height) / 4
        return f"调整圆大小，新半径: {self.radius}"

# 检查接口实现
circle = Circle(10, 10, 5)
print(circle.implements(Drawable))  # 输出: True
print(circle.draw())  # 输出: 绘制位于 (10, 10) 半径为 5 的圆
```

### 运行时代码生成和执行

```python
# 动态生成并执行代码
def generate_function(name, body):
    code = f"""
def {name}(x, y):
    {body}
    """
    
    # 创建一个命名空间来执行代码
    namespace = {}
    exec(code, namespace)
    
    # 返回创建的函数
    return namespace[name]

# 生成不同的函数
add_func = generate_function("add", "return x + y")
mul_func = generate_function("multiply", "return x * y")

# 使用生成的函数
print(add_func(5, 3))  # 输出: 8
print(mul_func(5, 3))  # 输出: 15
```

## 反射的陷阱和性能考虑

### 反射的陷阱

1. **命名冲突**：使用`__getattr__`等方法时，可能会干扰Python的内置行为。
2. **无限递归**：在`__getattribute__`中调用`self.something`会导致无限递归。
3. **效率问题**：过度使用反射可能导致性能下降。
4. **可读性问题**：过度动态的代码可能难以理解和调试。
5. **类型安全**：反射操作通常会绕过类型检查。

### 性能考虑

```python
import time

# 测量反射性能
class TestClass:
    def __init__(self):
        self.value = 42
    
    def get_value(self):
        return self.value

obj = TestClass()

# 直接访问
def direct_access():
    return obj.value

# 使用getattr
def reflection_access():
    return getattr(obj, "value")

# 方法调用
def direct_method_call():
    return obj.get_value()

# 使用反射调用方法
def reflection_method_call():
    method = getattr(obj, "get_value")
    return method()

# 测量性能
def measure(func, iterations=1000000):
    start = time.time()
    for _ in range(iterations):
        func()
    end = time.time()
    return end - start

print(f"直接访问: {measure(direct_access):.6f} 秒")
print(f"反射访问: {measure(reflection_access):.6f} 秒")
print(f"直接方法调用: {measure(direct_method_call):.6f} 秒")
print(f"反射方法调用: {measure(reflection_method_call):.6f} 秒")
```

### 优化反射操作

```python
# 1. 缓存反射结果
class CachedAPI:
    def __init__(self):
        self._method_cache = {}
    
    def call(self, method_name, *args, **kwargs):
        # 检查缓存
        if method_name not in self._method_cache:
            if hasattr(self, method_name):
                self._method_cache[method_name] = getattr(self, method_name)
            else:
                raise AttributeError(f"方法 {method_name} 不存在")
        
        # 调用缓存的方法
        return self._method_cache[method_name](*args, **kwargs)

# 2. 使用__slots__减少属性查找的开销
class FastObject:
    __slots__ = ['name', 'value']
    
    def __init__(self, name, value):
        self.name = name
        self.value = value
```

## 最佳实践

1. **明智使用**：反射强大但复杂，只在必要时使用。
2. **缓存结果**：频繁的反射操作应考虑缓存结果。
3. **错误处理**：使用`getattr`的默认值或异常处理来处理属性缺失。
4. **文档化**：记录动态行为，使代码更易于理解。
5. **测试**：动态代码需要更全面的测试覆盖。
6. **权衡取舍**：在灵活性和性能之间找到平衡。
7. **考虑替代方案**：有时简单的字典或显式API可能更好。

反射是Python最强大的特性之一，它使得Python具有极高的灵活性和动态性。然而，这种能力应当谨慎使用，以免导致难以维护的代码。在适当的场景中，反射可以大大简化设计并提供优雅的解决方案。
