# Python装饰器

装饰器是Python中一个强大的函数式编程特性，允许在不修改原函数代码的情况下扩展其功能。本文详细介绍装饰器的原理、实现和高级应用。

## 装饰器基础

### 什么是装饰器

装饰器本质上是一个callable对象（通常是函数），它接受一个函数作为参数，并返回一个新的函数，通常用于在不修改原函数代码的情况下扩展其功能。

装饰器可以被视为一个包装器，它为现有函数添加额外的功能，同时保持函数的原始接口。Python使用`@`符号作为装饰器的语法糖。

### 装饰器的工作原理

Python装饰器的基本工作原理可以通过以下简化模型理解：

```python
def decorator(func):
    def wrapper(*args, **kwargs):
        # 在调用原函数前执行的代码
        print("Something is happening before the function is called.")
        
        result = func(*args, **kwargs)  # 调用原函数
        
        # 在调用原函数后执行的代码
        print("Something is happening after the function is called.")
        
        return result
    return wrapper

# 手动应用装饰器
def say_hello():
    print("Hello!")

say_hello = decorator(say_hello)  # 使用装饰器包装函数
say_hello()  # 调用包装后的函数
```

使用`@`语法糖，上面的代码可以简化为：

```python
@decorator
def say_hello():
    print("Hello!")
    
say_hello()  # 调用包装后的函数
```

两种写法的效果是完全相同的，但`@`语法糖使代码更加简洁易读。

## 简单装饰器实现

### 不带参数的装饰器

最基本的装饰器不接受额外参数，只包装被装饰的函数：

```python
import functools
import time

def timer(func):
    """测量函数执行时间的装饰器"""
    @functools.wraps(func)  # 保留原函数的元信息
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"函数 {func.__name__} 执行耗时: {end_time - start_time:.4f} 秒")
        return result
    return wrapper

@timer
def slow_function(n):
    """一个耗时的函数"""
    time.sleep(n)  # 模拟耗时操作
    return f"完成耗时 {n} 秒的操作"

# 测试装饰器
print(slow_function(1.5))
# 输出:
# 函数 slow_function 执行耗时: 1.5004 秒
# 完成耗时 1.5 秒的操作
```

### 带参数的装饰器

装饰器也可以接受参数，这需要增加一层嵌套：

```python
def repeat(n=2):
    """
    创建一个装饰器，重复执行被装饰函数n次
    
    参数:
        n: 重复次数，默认为2
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            results = []
            for _ in range(n):
                results.append(func(*args, **kwargs))
            return results
        return wrapper
    return decorator

@repeat(n=3)
def greet(name):
    return f"Hello, {name}!"

# 测试装饰器
print(greet("World"))
# 输出: ['Hello, World!', 'Hello, World!', 'Hello, World!']
```

### 类作为装饰器

装饰器不限于函数，类也可以作为装饰器，只要它实现了`__call__`方法：

```python
class CountCalls:
    """计算函数调用次数的装饰器类"""
    
    def __init__(self, func):
        functools.update_wrapper(self, func)
        self.func = func
        self.count = 0
    
    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"函数 {self.func.__name__} 已被调用 {self.count} 次")
        return self.func(*args, **kwargs)

@CountCalls
def say_hello(name):
    return f"Hello, {name}!"

# 测试装饰器类
print(say_hello("Alice"))  # 函数 say_hello 已被调用 1 次
print(say_hello("Bob"))    # 函数 say_hello 已被调用 2 次
```

## 装饰器的应用场景

### 日志记录

使用装饰器记录函数的调用信息：

```python
def logger(func):
    """记录函数调用的装饰器"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        args_repr = [repr(a) for a in args]
        kwargs_repr = [f"{k}={v!r}" for k, v in kwargs.items()]
        signature = ", ".join(args_repr + kwargs_repr)
        print(f"调用 {func.__name__}({signature})")
        try:
            result = func(*args, **kwargs)
            print(f"{func.__name__} 返回 {result!r}")
            return result
        except Exception as e:
            print(f"{func.__name__} 抛出异常: {e}")
            raise
    return wrapper

@logger
def divide(a, b):
    return a / b

# 测试日志装饰器
divide(10, 5)
# 输出:
# 调用 divide(10, 5)
# divide 返回 2.0

try:
    divide(10, 0)
except ZeroDivisionError:
    pass
# 输出:
# 调用 divide(10, 0)
# divide 抛出异常: division by zero
```

### 性能监控

使用装饰器监控函数的性能：

```python
import time
import functools

def performance_monitor(func):
    """监控函数性能的装饰器"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        # 测量内存使用（需要安装psutil）
        try:
            import psutil
            process = psutil.Process()
            memory_before = process.memory_info().rss
        except (ImportError, NameError):
            memory_before = 0
        
        # 测量时间
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        
        # 再次测量内存
        try:
            memory_after = process.memory_info().rss
            memory_diff = memory_after - memory_before
        except (ImportError, NameError):
            memory_diff = 0
        
        print(f"函数 {func.__name__} 性能报告:")
        print(f"  - 执行时间: {end_time - start_time:.6f} 秒")
        if memory_diff > 0:
            print(f"  - 内存增加: {memory_diff / 1024:.2f} KB")
        
        return result
    return wrapper

@performance_monitor
def create_large_list(size):
    return [i ** 2 for i in range(size)]

# 测试性能监控装饰器
result = create_large_list(100000)
# 输出:
# 函数 create_large_list 性能报告:
#   - 执行时间: 0.023156 秒
#   - 内存增加: 781.25 KB
```

### 缓存/记忆化

使用装饰器缓存函数结果以提高性能：

```python
def memoize(func):
    """缓存函数结果的装饰器"""
    cache = {}
    @functools.wraps(func)
    def wrapper(*args):
        if args in cache:
            return cache[args]
        result = func(*args)
        cache[args] = result
        return result
    return wrapper

@memoize
def fibonacci(n):
    """计算斐波那契数列的第n个数"""
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# 测试缓存装饰器
import time
start = time.time()
result = fibonacci(35)
end = time.time()
print(f"斐波那契数列第35项: {result}")
print(f"耗时: {end - start:.6f} 秒")  # 非常快，因为有缓存
```

Python 3.2+ 提供了内置的缓存装饰器`functools.lru_cache`，效果更好：

```python
@functools.lru_cache(maxsize=128)
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# 这比自定义memoize更高效，还提供了缓存统计
```

### 权限验证

使用装饰器进行权限控制：

```python
def require_auth(func):
    """检查用户是否已认证的装饰器"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        # 假设我们通过某种方式获取当前用户
        user = get_current_user()  # 这是假想的函数
        if not user:
            raise PermissionError("需要登录才能访问此功能")
        if not user.is_authenticated:
            raise PermissionError("认证失败")
        return func(*args, **kwargs)
    return wrapper

def require_role(role):
    """检查用户是否具有特定角色的装饰器"""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            user = get_current_user()  # 假想的函数
            if not user:
                raise PermissionError("需要登录才能访问此功能")
            if role not in user.roles:
                raise PermissionError(f"需要 {role} 角色才能访问此功能")
            return func(*args, **kwargs)
        return wrapper
    return decorator

@require_auth
def user_profile():
    return "用户资料页面"

@require_role("admin")
def admin_panel():
    return "管理员面板"
```

### 输入验证

使用装饰器验证函数输入：

```python
def validate_types(**expected_types):
    """验证函数参数类型的装饰器"""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # 获取函数的参数名
            func_code = func.__code__
            param_names = func_code.co_varnames[:func_code.co_argcount]
            
            # 绑定参数
            bound_args = dict(zip(param_names, args))
            bound_args.update(kwargs)
            
            # 检查参数类型
            for arg_name, expected_type in expected_types.items():
                if arg_name in bound_args:
                    actual_value = bound_args[arg_name]
                    if not isinstance(actual_value, expected_type):
                        raise TypeError(
                            f"参数 '{arg_name}' 应为 {expected_type.__name__} 类型，"
                            f"实际为 {type(actual_value).__name__} 类型"
                        )
            
            return func(*args, **kwargs)
        return wrapper
    return decorator

@validate_types(name=str, age=int)
def create_user(name, age):
    return f"创建用户: {name}, {age}岁"

# 测试类型验证装饰器
print(create_user("Alice", 30))  # 成功
try:
    print(create_user("Bob", "30"))  # 失败，age应为int类型
except TypeError as e:
    print(f"错误: {e}")
```

### 路由注册

在Web框架中，装饰器经常用于注册路由：

```python
class Router:
    """简单的路由注册器"""
    def __init__(self):
        self.routes = {}
    
    def route(self, path):
        """注册路由的装饰器"""
        def decorator(func):
            self.routes[path] = func
            return func
        return decorator
    
    def handle_request(self, path):
        """处理请求的方法"""
        if path in self.routes:
            return self.routes[path]()
        else:
            return "404 Not Found"

# 创建应用实例
app = Router()

# 使用装饰器注册路由
@app.route("/")
def index():
    return "首页"

@app.route("/about")
def about():
    return "关于我们"

# 测试路由系统
print(app.handle_request("/"))      # 输出: 首页
print(app.handle_request("/about")) # 输出: 关于我们
print(app.handle_request("/unknown"))  # 输出: 404 Not Found
```

## 高级装饰器技巧

### 保留函数元信息

默认情况下，装饰器会覆盖原函数的元信息（如名称、文档字符串等）。使用`functools.wraps`可以保留这些信息：

```python
import functools

def my_decorator(func):
    @functools.wraps(func)  # 保留func的元信息
    def wrapper(*args, **kwargs):
        """wrapper函数的文档"""
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def example():
    """example函数的文档"""
    pass

print(example.__name__)  # 输出: example (而不是wrapper)
print(example.__doc__)   # 输出: example函数的文档
```

### 可调用装饰器类

如果装饰器需要维护状态，使用类作为装饰器是个好选择：

```python
class Profiler:
    """跟踪函数调用次数和总执行时间的装饰器类"""
    
    def __init__(self, func=None, *, prefix=''):
        self.func = func
        self.prefix = prefix
        self.calls = 0
        self.total_time = 0
        functools.update_wrapper(self, func)
    
    def __call__(self, *args, **kwargs):
        if self.func is None:
            # 被当作带参数装饰器使用
            # @Profiler(prefix='DEBUG')
            def inner(func):
                return Profiler(func, prefix=self.prefix)
            return inner
        
        # 被当作普通装饰器使用
        # @Profiler
        self.calls += 1
        start = time.time()
        result = self.func(*args, **kwargs)
        self.total_time += time.time() - start
        
        print(f"{self.prefix}函数 {self.func.__name__} 已调用 {self.calls} 次，"
              f"总耗时: {self.total_time:.4f} 秒，"
              f"平均耗时: {self.total_time/self.calls:.4f} 秒")
        
        return result

# 用作普通装饰器
@Profiler
def slow_function(n):
    time.sleep(n)
    return n

# 用作带参数的装饰器
@Profiler(prefix='DEBUG: ')
def another_slow_function(n):
    time.sleep(n)
    return n

slow_function(0.1)
slow_function(0.2)
another_slow_function(0.1)
```

### 装饰器的叠加使用

多个装饰器可以叠加使用，按照自下而上的顺序应用：

```python
def bold(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        return f"<b>{func(*args, **kwargs)}</b>"
    return wrapper

def italic(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        return f"<i>{func(*args, **kwargs)}</i>"
    return wrapper

@bold
@italic
def greet(name):
    return f"Hello, {name}!"

print(greet("World"))
# 输出: <b><i>Hello, World!</i></b>
# 先应用italic，再应用bold
```

### 装饰器工厂

装饰器工厂是返回装饰器的函数，可以根据参数创建自定义装饰器：

```python
def create_decorator(label):
    """创建一个装饰器的工厂函数"""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            print(f"{label}: 函数 {func.__name__} 被调用")
            return func(*args, **kwargs)
        return wrapper
    return decorator

# 使用装饰器工厂创建不同的装饰器
debug = create_decorator("DEBUG")
info = create_decorator("INFO")
warning = create_decorator("WARNING")

@debug
def test_debug():
    return "This is a debug function"

@info
def test_info():
    return "This is an info function"

@warning
def test_warning():
    return "This is a warning function"

test_debug()   # DEBUG: 函数 test_debug 被调用
test_info()    # INFO: 函数 test_info 被调用
test_warning() # WARNING: 函数 test_warning 被调用
```

### 装饰类方法

装饰器也可以应用于类方法，包括实例方法、类方法和静态方法：

```python
def log_method(func):
    """记录方法调用的装饰器"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print(f"调用方法 {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

class MyClass:
    @log_method
    def instance_method(self, x):
        return f"instance_method: {x}"
    
    @classmethod
    @log_method
    def class_method(cls, x):
        return f"class_method: {x}"
    
    @staticmethod
    @log_method
    def static_method(x):
        return f"static_method: {x}"

obj = MyClass()
print(obj.instance_method(1))  # 调用方法 instance_method
print(MyClass.class_method(2))  # 调用方法 class_method
print(MyClass.static_method(3))  # 调用方法 static_method
```

### 参数化装饰器与类装饰器

结合参数化装饰器和类装饰器，可以创建更灵活的装饰器：

```python
class Tracer:
    """可参数化的跟踪装饰器类"""
    
    def __init__(self, *, show_args=True, show_result=True):
        self.show_args = show_args
        self.show_result = show_result
    
    def __call__(self, func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # 显示参数
            if self.show_args:
                args_str = ', '.join(str(a) for a in args)
                kwargs_str = ', '.join(f"{k}={v}" for k, v in kwargs.items())
                all_args = ', '.join(filter(bool, [args_str, kwargs_str]))
                print(f"{func.__name__}({all_args})")
            
            # 调用函数
            result = func(*args, **kwargs)
            
            # 显示结果
            if self.show_result:
                print(f"{func.__name__} 返回: {result}")
            
            return result
        return wrapper

# 只显示参数
@Tracer(show_args=True, show_result=False)
def add(a, b):
    return a + b

# 只显示结果
@Tracer(show_args=False, show_result=True)
def multiply(a, b):
    return a * b

# 同时显示参数和结果
@Tracer()
def divide(a, b):
    return a / b

add(2, 3)  # add(2, 3)
multiply(4, 5)  # multiply 返回: 20
divide(10, 2)  # divide(10, 2) \n divide 返回: 5.0
```

## 实际应用案例

### Web框架中的路由装饰器

Flask等Web框架使用装饰器注册路由：

```python
from flask import Flask, request

app = Flask(__name__)

@app.route("/", methods=["GET"])
def index():
    return "Welcome to the home page!"

@app.route("/user/<username>")
def user_profile(username):
    return f"Profile page for {username}"

@app.route("/api/data", methods=["POST"])
def add_data():
    data = request.get_json()
    # 处理数据...
    return {"status": "success", "data": data}
```

### 属性装饰器

Python内置的`@property`装饰器可以将方法转换为属性：

```python
class Circle:
    def __init__(self, radius):
        self._radius = radius
    
    @property
    def radius(self):
        """半径属性的getter方法"""
        return self._radius
    
    @radius.setter
    def radius(self, value):
        """半径属性的setter方法"""
        if value <= 0:
            raise ValueError("半径必须为正数")
        self._radius = value
    
    @property
    def area(self):
        """圆的面积（只读属性）"""
        return 3.14159 * self._radius ** 2
    
    @property
    def circumference(self):
        """圆的周长（只读属性）"""
        return 2 * 3.14159 * self._radius

# 使用属性
circle = Circle(5)
print(circle.radius)  # 5
print(circle.area)    # 78.53975
circle.radius = 10    # 使用setter
print(circle.area)    # 314.159
# circle.area = 100   # 错误，area是只读属性
```

### 注册插件的装饰器

装饰器常用于插件系统，注册回调函数：

```python
class PluginRegistry:
    """插件注册系统"""
    
    def __init__(self):
        self.startup_callbacks = []
        self.shutdown_callbacks = []
        self.event_handlers = {}
    
    def on_startup(self, func):
        """注册启动时调用的回调函数"""
        self.startup_callbacks.append(func)
        return func
    
    def on_shutdown(self, func):
        """注册关闭时调用的回调函数"""
        self.shutdown_callbacks.append(func)
        return func
    
    def on_event(self, event_name):
        """注册事件处理函数的装饰器"""
        def decorator(func):
            if event_name not in self.event_handlers:
                self.event_handlers[event_name] = []
            self.event_handlers[event_name].append(func)
            return func
        return decorator
    
    def start(self):
        """启动系统，调用所有启动回调"""
        print("系统启动中...")
        for callback in self.startup_callbacks:
            callback()
    
    def stop(self):
        """关闭系统，调用所有关闭回调"""
        print("系统关闭中...")
        for callback in self.shutdown_callbacks:
            callback()
    
    def trigger_event(self, event_name, *args, **kwargs):
        """触发事件，调用对应的处理函数"""
        if event_name in self.event_handlers:
            for handler in self.event_handlers[event_name]:
                handler(*args, **kwargs)

# 创建插件注册表
registry = PluginRegistry()

# 注册各种回调
@registry.on_startup
def initialize_database():
    print("初始化数据库连接...")

@registry.on_shutdown
def close_database():
    print("关闭数据库连接...")

@registry.on_event("user_login")
def log_user_login(username):
    print(f"用户登录: {username}")

@registry.on_event("user_login")
def send_welcome_message(username):
    print(f"发送欢迎消息给 {username}")

# 使用插件系统
registry.start()  # 系统启动中... \n 初始化数据库连接...
registry.trigger_event("user_login", "alice")  # 用户登录: alice \n 发送欢迎消息给 alice
registry.stop()  # 系统关闭中... \n 关闭数据库连接...
```

### 单元测试装饰器

在单元测试中，装饰器用于设置测试环境、标记测试特性等：

```python
import unittest
import functools

def skip_if(condition, reason):
    """有条件地跳过测试的装饰器"""
    def decorator(test_func):
        @functools.wraps(test_func)
        def wrapper(*args, **kwargs):
            if condition:
                print(f"跳过测试: {reason}")
                return None
            return test_func(*args, **kwargs)
        return wrapper
    return decorator

def requires_network(test_func):
    """标记需要网络连接的测试"""
    @functools.wraps(test_func)
    def wrapper(*args, **kwargs):
        try:
            # 简单检查网络连接
            import socket
            socket.create_connection(("www.google.com", 80), timeout=1)
            return test_func(*args, **kwargs)
        except (socket.error, socket.timeout):
            print("跳过测试: 没有网络连接")
            return None
    return wrapper

class MyTestCase(unittest.TestCase):
    @skip_if(True, "演示跳过测试")
    def test_skipped(self):
        self.assertTrue(False)  # 这个断言不会执行
    
    @requires_network
    def test_network_feature(self):
        # 测试需要网络连接的功能
        pass
```

## 最佳实践与陷阱

### 最佳实践

1. **使用`functools.wraps`保留原函数的元信息**
   
   ```python
   def my_decorator(func):
       @functools.wraps(func)
       def wrapper(*args, **kwargs):
           return func(*args, **kwargs)
       return wrapper
   ```

2. **将复杂逻辑分解为小型装饰器**
   
   ```python
   @validate_input
   @log_calls
   @time_it
   def process_data(data):
       # 处理数据...
       pass
   ```

3. **为装饰器提供良好的文档**
   
   ```python
   def log_calls(func):
       """
       记录函数调用的装饰器
       
       记录函数的名称、参数和返回值
       """
       @functools.wraps(func)
       def wrapper(*args, **kwargs):
           # 实现...
           pass
       return wrapper
   ```

4. **考虑装饰器对性能的影响**，尤其是在频繁调用的函数上
   
   ```python
   # 优化版本的装饰器
   def optimized_decorator(func):
       # 预先计算一些值，避免在每次调用时重复计算
       computed_value = expensive_calculation()
       
       @functools.wraps(func)
       def wrapper(*args, **kwargs):
           # 使用预计算的值
           return func(*args, **kwargs) + computed_value
       return wrapper
   ```

5. **避免过度使用装饰器**，以免使代码难以理解
   
   ```python
   # 装饰器层级太多，难以理解
   @decorator1
   @decorator2
   @decorator3
   @decorator4
   @decorator5
   def overly_decorated_function():
       pass
   ```

### 常见陷阱

1. **无法访问被装饰函数的属性**（如未使用`functools.wraps`）
   
   ```python
   def bad_decorator(func):
       def wrapper(*args, **kwargs):
           return func(*args, **kwargs)
       return wrapper  # 没有使用functools.wraps
   
   @bad_decorator
   def example():
       """这个文档字符串将丢失"""
       pass
   
   print(example.__name__)  # 输出: wrapper
   print(example.__doc__)   # 输出: None
   ```

2. **装饰器顺序问题**
   
   ```python
   @decorator_a
   @decorator_b
   def func():
       pass
   
   # 等价于:
   # func = decorator_a(decorator_b(func))
   # 而不是:
   # func = decorator_b(decorator_a(func))
   ```

3. **不正确地处理函数参数**
   
   ```python
   def incorrect_decorator(func):
       def wrapper(*args):  # 没有处理关键字参数
           return func(*args)
       return wrapper
   
   @incorrect_decorator
   def func_with_kwargs(x, y=10):
       return x + y
   
   # 这将失败
   func_with_kwargs(5, y=15)  # TypeError: wrapper() got an unexpected keyword argument 'y'
   ```

4. **装饰器副作用**
   
   ```python
   counter = 0
   
   def count_calls(func):
       def wrapper(*args, **kwargs):
           global counter
           counter += 1  # 全局变量副作用
           return func(*args, **kwargs)
       return wrapper
   
   @count_calls
   def example():
       pass
   
   # 使用全局变量追踪状态不是好主意
   ```

5. **装饰器递归问题**
   
   ```python
   def memoize(func):
       cache = {}
       
       @functools.wraps(func)
       def wrapper(*args):
           if args in cache:
               return cache[args]
           result = func(*args)  # 递归调用时可能出现问题
           cache[args] = result
           return result
       return wrapper
   
   @memoize
   def factorial(n):
       if n <= 1:
           return 1
       return n * factorial(n-1)  # 这里会调用被装饰后的factorial
   ```

## 装饰器与函数式编程

装饰器是Python中函数式编程的重要体现，它们使用了高阶函数和闭包等函数式编程概念。

### 高阶函数

装饰器本质上是高阶函数，因为它们接受函数作为参数并返回新函数：

```python
def twice(func):
    """一个简单的高阶函数，调用原函数两次"""
    def wrapper(*args, **kwargs):
        func(*args, **kwargs)
        return func(*args, **kwargs)
    return wrapper

# 作为装饰器使用
@twice
def print_message(msg):
    print(msg)
    return msg

# 作为普通高阶函数使用
def add(a, b):
    return a + b

twice_add = twice(add)
result = twice_add(3, 5)  # 返回第二次调用的结果: 8
```

### 闭包

装饰器广泛使用闭包来"记住"原函数和其他变量：

```python
def counter(start=0):
    """创建一个计数器函数的闭包"""
    count = [start]  # 使用可变对象避免nonlocal声明
    
    def increment():
        count[0] += 1
        return count[0]
    
    return increment

# 创建两个计数器
counter1 = counter(10)
counter2 = counter(100)

print(counter1())  # 11
print(counter1())  # 12
print(counter2())  # 101
print(counter1())  # 13
```

### 函数组合

装饰器也可以用于函数组合，即将多个函数组合成一个新函数：

```python
def compose(*functions):
    """函数组合：compose(f, g, h)(x) == f(g(h(x)))"""
    def inner(x):
        result = x
        for f in reversed(functions):
            result = f(result)
        return result
    return inner

# 定义一些简单函数
def double(x):
    return x * 2

def increment(x):
    return x + 1

def square(x):
    return x * x

# 组合函数
transformed = compose(square, double, increment)
# 等价于: square(double(increment(x)))

print(transformed(5))  # square(double(increment(5))) = square(double(6)) = square(12) = 144
```

### 柯里化与偏函数应用

装饰器也可以实现柯里化和偏函数应用：

```python
def curry(func):
    """将一个多参数函数转换为一系列单参数函数的装饰器"""
    @functools.wraps(func)
    def curried(*args, **kwargs):
        if len(args) + len(kwargs) >= func.__code__.co_argcount:
            return func(*args, **kwargs)
        return lambda *more_args, **more_kwargs: curried(*(args + more_args), **{**kwargs, **more_kwargs})
    return curried

@curry
def add(a, b, c):
    return a + b + c

# 柯里化使用
add_1 = add(1)
add_1_2 = add_1(2)
result = add_1_2(3)  # 1 + 2 + 3 = 6
print(result)

# 或者一次性传入所有参数
print(add(1, 2, 3))  # 6

# 偏函数应用
from functools import partial

def add(a, b, c):
    return a + b + c

add_5 = partial(add, 5)  # 固定第一个参数为5
add_5_10 = partial(add_5, 10)  # 固定第二个参数为10
print(add_5_10(15))  # 5 + 10 + 15 = 30
```

## 结论

装饰器是Python中一个强大而灵活的特性，它们能够以一种非侵入式的方式扩展和修改函数和类的行为。装饰器广泛应用于日志记录、性能监控、缓存、权限控制等方面，是实现横切关注点的理想工具。

通过掌握装饰器的基本原理和高级用法，你可以编写更加简洁、模块化和可维护的代码。装饰器不仅体现了Python的函数式编程特性，也反映了Python设计哲学中的优雅和实用性。

然而，装饰器也可能导致代码难以理解和调试，因此应谨慎使用，并遵循最佳实践，以确保代码的清晰性和可维护性。在正确使用的情况下，装饰器是Python编程工具箱中不可或缺的强大工具。
