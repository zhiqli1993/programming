# Python面向对象编程进阶特性

本文详细介绍Python面向对象编程的进阶特性，包括继承与多态、抽象基类、元类、描述符等高级概念，帮助你更深入地理解和应用Python的面向对象编程范式。

## 继承与多态深入理解

### 继承链与方法解析顺序(MRO)

Python使用C3线性化算法来确定方法解析顺序(MRO)，这对于多重继承尤为重要：

```python
class A:
    def method(self):
        return "A.method"

class B(A):
    def method(self):
        return "B.method"

class C(A):
    def method(self):
        return "C.method"

class D(B, C):
    pass

# 查看MRO
print(D.__mro__)
# 输出: (<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)

d = D()
print(d.method())  # 输出: B.method
```

MRO遵循以下规则：
1. 子类优先于父类
2. 多个父类按照它们在继承列表中的顺序检查
3. 如果存在多条继承路径，保持单调性（一旦一个类被检查过，就不会再次检查）

### super()函数深入解析

`super()`函数是一个代理，指向MRO中的下一个类：

```python
class A:
    def method(self):
        print("A.method")

class B(A):
    def method(self):
        print("B.method")
        super().method()  # 调用A.method

class C(A):
    def method(self):
        print("C.method")
        super().method()  # 调用A.method

class D(B, C):
    def method(self):
        print("D.method")
        super().method()  # 调用B.method

d = D()
d.method()
# 输出:
# D.method
# B.method
# C.method
# A.method
```

`super()`与MRO密切相关，它不一定总是调用"父类"的方法，而是调用MRO中的下一个类的方法。

### 使用super()的最佳实践

1. **构造函数中使用super()**

```python
class Base:
    def __init__(self, x):
        self.x = x

class Left(Base):
    def __init__(self, x, y):
        super().__init__(x)
        self.y = y

class Right(Base):
    def __init__(self, x, z):
        super().__init__(x)
        self.z = z

class Combined(Left, Right):
    def __init__(self, x, y, z):
        super().__init__(x, y)  # 调用Left.__init__，而Left.__init__会调用Base.__init__
        self.z = z

# 创建实例
obj = Combined(1, 2, 3)
print(obj.x, obj.y, obj.z)  # 1 2 3
```

2. **多重继承中的合作性多重继承**

```python
class A:
    def method(self):
        print("A.method")

class B(A):
    def method(self):
        print("B.method")
        super().method()

class C(A):
    def method(self):
        print("C.method")
        super().method()

class D(B, C):
    def method(self):
        print("D.method")
        super().method()

d = D()
d.method()
# 输出:
# D.method
# B.method
# C.method
# A.method
```

## 多重继承与Mixin模式

### 多重继承的挑战

多重继承可能导致：
1. 菱形继承问题(钻石问题)
2. 方法解析顺序复杂
3. 代码可维护性降低

### Mixin模式

Mixin是一种设计模式，通过创建提供特定功能的小类，然后通过多重继承组合这些功能：

```python
class SerializableMixin:
    def to_json(self):
        import json
        return json.dumps(self.__dict__)
    
    def to_xml(self):
        # 简化的XML序列化
        xml = ["<object>"]
        for key, value in self.__dict__.items():
            xml.append(f"  <{key}>{value}</{key}>")
        xml.append("</object>")
        return "\n".join(xml)

class LoggableMixin:
    def log(self, message):
        print(f"[LOG] {message}")
    
    def log_method_call(self, method_name):
        self.log(f"Calling method: {method_name}")

class Person(SerializableMixin, LoggableMixin):
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def greet(self):
        self.log_method_call("greet")
        return f"Hello, my name is {self.name}"

# 使用Person类
person = Person("Alice", 30)
print(person.greet())  # [LOG] Calling method: greet
                       # Hello, my name is Alice
print(person.to_json())  # {"name": "Alice", "age": 30}
print(person.to_xml())  # <object>
                       #   <name>Alice</name>
                       #   <age>30</age>
                       # </object>
```

### Mixin设计原则

1. **单一职责**：每个Mixin应该只提供一种特定功能
2. **无状态**：Mixin通常不应该有`__init__`方法或实例属性
3. **可组合**：Mixin应该可以灵活组合，不应互相依赖
4. **明确命名**：通常以"Mixin"或"able"结尾（如Serializable, Printable）

## 抽象基类(ABC)

抽象基类定义接口但不实现具体功能，强制子类实现特定方法。

### 创建抽象基类

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        """计算面积"""
        pass
    
    @abstractmethod
    def perimeter(self):
        """计算周长"""
        pass
    
    def describe(self):
        """非抽象方法可以有默认实现"""
        return f"这是一个形状，面积为{self.area()}，周长为{self.perimeter()}"

# 尝试实例化抽象类会失败
# shape = Shape()  # TypeError: Can't instantiate abstract class Shape with abstract methods area, perimeter

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14 * self.radius ** 2
    
    def perimeter(self):
        return 2 * 3.14 * self.radius

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)

# 使用具体子类
circle = Circle(5)
print(circle.area())  # 78.5
print(circle.describe())  # 这是一个形状，面积为78.5，周长为31.4
```

### 抽象属性

除了抽象方法，还可以定义抽象属性：

```python
from abc import ABC, abstractmethod, abstractproperty

class Vehicle(ABC):
    @property
    @abstractmethod
    def wheels(self):
        """车轮数量"""
        pass
    
    @abstractmethod
    def start(self):
        """启动车辆"""
        pass

class Car(Vehicle):
    @property
    def wheels(self):
        return 4
    
    def start(self):
        return "汽车发动机启动"

class Motorcycle(Vehicle):
    @property
    def wheels(self):
        return 2
    
    def start(self):
        return "摩托车发动机启动"

# 使用具体子类
car = Car()
print(car.wheels)  # 4
print(car.start())  # 汽车发动机启动
```

### 抽象基类的应用场景

1. **定义API**：确保所有子类都提供特定功能
2. **框架开发**：定义插件或扩展必须实现的接口
3. **代码契约**：明确类与类之间的行为约定

## 元类编程

元类是创建类的类，可以控制类的创建过程。

### 理解类的创建过程

```python
# 一个普通的类定义
class MyClass:
    x = 1
    
    def method(self):
        return self.x

# 等价于
MyClass = type('MyClass', (), {
    'x': 1,
    'method': lambda self: self.x
})
```

`type`是Python中的默认元类，用于创建类对象。

### 自定义元类

```python
class Meta(type):
    def __new__(mcs, name, bases, namespace):
        # 在类创建前修改类的定义
        print(f"创建类: {name}")
        
        # 添加一个新方法到类
        namespace['added_method'] = lambda self: "这是由元类添加的方法"
        
        # 修改现有属性
        if 'x' in namespace:
            namespace['x'] = namespace['x'] * 2
        
        # 调用type.__new__创建类
        return super().__new__(mcs, name, bases, namespace)

# 使用自定义元类
class MyClass(metaclass=Meta):
    x = 5
    
    def method(self):
        return self.x

# 输出: 创建类: MyClass

# 使用类
obj = MyClass()
print(obj.x)  # 10 (已被元类修改)
print(obj.added_method())  # 这是由元类添加的方法
```

### 元类应用场景

1. **自动注册**：自动注册子类到注册表中

```python
class PluginRegistry(type):
    plugins = {}
    
    def __new__(mcs, name, bases, namespace):
        cls = super().__new__(mcs, name, bases, namespace)
        if name != 'Plugin':  # 不注册基类
            mcs.plugins[name] = cls
        return cls

class Plugin(metaclass=PluginRegistry):
    """插件基类"""
    
    def run(self):
        raise NotImplementedError("子类必须实现run方法")

class TextPlugin(Plugin):
    def run(self):
        return "处理文本"

class ImagePlugin(Plugin):
    def run(self):
        return "处理图像"

# 使用注册表
print(PluginRegistry.plugins)
# 输出: {'TextPlugin': <class '__main__.TextPlugin'>, 'ImagePlugin': <class '__main__.ImagePlugin'>}

# 动态获取插件
plugin_name = "TextPlugin"
plugin_class = PluginRegistry.plugins[plugin_name]
plugin = plugin_class()
print(plugin.run())  # 处理文本
```

2. **属性验证**：在类定义时验证属性

```python
class ValidateMeta(type):
    def __new__(mcs, name, bases, namespace):
        # 验证方法是否有文档字符串
        for key, value in namespace.items():
            if callable(value) and not key.startswith('__'):
                if not value.__doc__:
                    raise TypeError(f"{name}.{key} 方法缺少文档字符串")
        
        return super().__new__(mcs, name, bases, namespace)

class MyClass(metaclass=ValidateMeta):
    def method_with_doc(self):
        """这个方法有文档字符串"""
        return True
    
    # 这会引发异常
    # def method_without_doc(self):
    #     return True
```

3. **ORM映射**：如Django的Model类

```python
class ModelMeta(type):
    def __new__(mcs, name, bases, namespace):
        # 收集字段信息
        fields = {}
        for key, value in namespace.items():
            if isinstance(value, Field):
                fields[key] = value
                value.name = key
        
        # 将字段信息存储在类中
        namespace['_fields'] = fields
        
        return super().__new__(mcs, name, bases, namespace)

class Field:
    def __init__(self, field_type, required=False):
        self.field_type = field_type
        self.required = required
        self.name = None  # 将在元类中设置

class Model(metaclass=ModelMeta):
    @classmethod
    def fields(cls):
        return cls._fields

class User(Model):
    name = Field(str, required=True)
    age = Field(int)
    email = Field(str, required=True)

# 检查模型字段
for name, field in User.fields().items():
    print(f"字段: {name}, 类型: {field.field_type.__name__}, 必填: {field.required}")
```

## 描述符协议

描述符是实现了`__get__`、`__set__`或`__delete__`方法的对象，用于自定义属性访问行为。

### 基本描述符

```python
class Descriptor:
    def __get__(self, instance, owner):
        print(f"获取: {instance} 的属性")
        return instance._value if instance else None
    
    def __set__(self, instance, value):
        print(f"设置: {instance} 的属性为 {value}")
        instance._value = value
    
    def __delete__(self, instance):
        print(f"删除: {instance} 的属性")
        del instance._value

class MyClass:
    attribute = Descriptor()
    
    def __init__(self):
        self._value = None

# 使用描述符
obj = MyClass()
obj.attribute = 10  # 设置: <__main__.MyClass object at 0x...> 的属性为 10
print(obj.attribute)  # 获取: <__main__.MyClass object at 0x...> 的属性
                      # 10
del obj.attribute  # 删除: <__main__.MyClass object at 0x...> 的属性
```

### 数据验证描述符

```python
class Validated:
    def __init__(self, name=None, **kwargs):
        self.name = name
        for key, value in kwargs.items():
            setattr(self, key, value)
    
    def __set__(self, instance, value):
        self.validate(value)
        instance.__dict__[self.name] = value
    
    def validate(self, value):
        pass

class OneOf(Validated):
    def __init__(self, *args, **kwargs):
        self.options = set(args)
        super().__init__(**kwargs)
    
    def validate(self, value):
        if value not in self.options:
            raise ValueError(f"{value!r} 不是有效选项: {self.options}")

class Number(Validated):
    def __init__(self, min_value=None, max_value=None, **kwargs):
        self.min_value = min_value
        self.max_value = max_value
        super().__init__(**kwargs)
    
    def validate(self, value):
        if not isinstance(value, (int, float)):
            raise TypeError(f"{value!r} 不是数字")
        if self.min_value is not None and value < self.min_value:
            raise ValueError(f"{value} 小于最小值 {self.min_value}")
        if self.max_value is not None and value > self.max_value:
            raise ValueError(f"{value} 大于最大值 {self.max_value}")

class String(Validated):
    def __init__(self, min_length=None, max_length=None, pattern=None, **kwargs):
        self.min_length = min_length
        self.max_length = max_length
        self.pattern = pattern
        super().__init__(**kwargs)
    
    def validate(self, value):
        if not isinstance(value, str):
            raise TypeError(f"{value!r} 不是字符串")
        if self.min_length is not None and len(value) < self.min_length:
            raise ValueError(f"{value!r} 长度小于 {self.min_length}")
        if self.max_length is not None and len(value) > self.max_length:
            raise ValueError(f"{value!r} 长度大于 {self.max_length}")
        if self.pattern is not None and not self.pattern.match(value):
            raise ValueError(f"{value!r} 不匹配模式 {self.pattern}")

# 使用这些描述符
import re

class Person:
    name = String(min_length=2, max_length=30, name="name")
    age = Number(min_value=0, max_value=120, name="age")
    email = String(pattern=re.compile(r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$"), name="email")
    gender = OneOf("male", "female", "other", name="gender")
    
    def __init__(self, name, age, email, gender):
        self.name = name
        self.age = age
        self.email = email
        self.gender = gender

# 创建有效的Person对象
person = Person("Alice", 30, "alice@example.com", "female")

# 这些会引发异常
# Person("A", 30, "alice@example.com", "female")  # 名字太短
# Person("Alice", -5, "alice@example.com", "female")  # 年龄无效
# Person("Alice", 30, "invalid-email", "female")  # 邮箱无效
# Person("Alice", 30, "alice@example.com", "unknown")  # 性别选项无效
```

### 懒加载属性

```python
class LazyProperty:
    def __init__(self, function):
        self.function = function
        self.name = function.__name__
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        
        value = self.function(instance)
        # 计算一次后，将结果存储在实例字典中
        instance.__dict__[self.name] = value
        return value

class DataProcessor:
    def __init__(self, data):
        self.data = data
    
    @LazyProperty
    def processed_data(self):
        print("处理数据...这可能很耗时")
        result = [x * 2 for x in self.data]
        return result

# 使用懒加载属性
processor = DataProcessor([1, 2, 3, 4, 5])
print("创建了处理器")
# 第一次访问时计算
print(processor.processed_data)  # 处理数据...这可能很耗时
                                # [2, 4, 6, 8, 10]
# 后续访问直接返回计算结果
print(processor.processed_data)  # [2, 4, 6, 8, 10]
```

## 属性访问控制

Python提供了多种方法来控制属性的访问。

### `__slots__`属性

`__slots__`可以限制类的实例可以拥有的属性，并节省内存：

```python
class RegularClass:
    def __init__(self, x, y):
        self.x = x
        self.y = y

class SlottedClass:
    __slots__ = ('x', 'y')
    
    def __init__(self, x, y):
        self.x = x
        self.y = y

# 常规类可以添加任意属性
regular = RegularClass(1, 2)
regular.z = 3  # 正常工作

# 带有__slots__的类只能有指定的属性
slotted = SlottedClass(1, 2)
# slotted.z = 3  # AttributeError: 'SlottedClass' object has no attribute 'z'

# 内存效率比较（需要导入sys模块）
import sys
print(sys.getsizeof(regular))  # 通常较大
print(sys.getsizeof(slotted))  # 通常较小
```

### 属性名称修饰

Python通过名称修饰（命名改写）实现"私有"属性：

```python
class MyClass:
    def __init__(self):
        self.public = "公有属性"
        self._protected = "保护属性"  # 约定为保护属性
        self.__private = "私有属性"  # 名称会被修饰
    
    def get_private(self):
        return self.__private

obj = MyClass()
print(obj.public)  # 公有属性
print(obj._protected)  # 保护属性（约定不直接访问）
# print(obj.__private)  # AttributeError: 'MyClass' object has no attribute '__private'

# 名称修饰后的实际属性名
print(obj._MyClass__private)  # 私有属性
print(obj.get_private())  # 私有属性
```

### 属性访问的特殊方法

Python提供了特殊方法来控制属性的访问：

```python
class AccessControl:
    def __init__(self):
        self._attributes = {}
    
    def __getattr__(self, name):
        """处理对不存在属性的访问"""
        print(f"获取不存在的属性: {name}")
        if name in self._attributes:
            return self._attributes[name]
        raise AttributeError(f"'{self.__class__.__name__}' 对象没有属性 '{name}'")
    
    def __setattr__(self, name, value):
        """处理所有属性赋值"""
        if name == '_attributes':
            # 避免递归
            super().__setattr__(name, value)
        else:
            print(f"设置属性: {name} = {value}")
            self._attributes[name] = value
    
    def __delattr__(self, name):
        """处理属性删除"""
        if name == '_attributes':
            super().__delattr__(name)
        else:
            print(f"删除属性: {name}")
            if name in self._attributes:
                del self._attributes[name]
            else:
                raise AttributeError(f"'{self.__class__.__name__}' 对象没有属性 '{name}'")
    
    def __getattribute__(self, name):
        """处理所有属性访问（比__getattr__优先级高）"""
        if name.startswith('_'):
            # 对于内部属性，使用默认行为
            return super().__getattribute__(name)
        else:
            print(f"访问属性: {name}")
            # 仍然需要通过super()获取，避免递归
            attributes = super().__getattribute__('_attributes')
            if name in attributes:
                return attributes[name]
            # 如果属性不存在，则调用__getattr__
            return self.__getattr__(name)

# 使用自定义属性访问控制
obj = AccessControl()
obj.x = 10  # 设置属性: x = 10
print(obj.x)  # 访问属性: x
              # 10
# print(obj.y)  # 访问属性: y
              # 获取不存在的属性: y
              # AttributeError: 'AccessControl' 对象没有属性 'y'
del obj.x  # 删除属性: x
```

## 多态与鸭子类型

### Python的动态类型和鸭子类型

Python是动态类型语言，使用"鸭子类型"（如果它走起来像鸭子、叫起来像鸭子，那么它就是鸭子）：

```python
class Duck:
    def quack(self):
        return "嘎嘎!"
    
    def fly(self):
        return "鸭子飞行"

class Person:
    def quack(self):
        return "人模仿鸭子叫"
    
    def fly(self):
        return "人模仿鸭子飞行"

def duck_test(obj):
    """鸭子测试：只要对象实现了预期的方法，就可以使用它"""
    print(obj.quack())
    print(obj.fly())

# 两个不同类型的对象都可以通过测试
duck = Duck()
person = Person()

duck_test(duck)  # 嘎嘎!
                # 鸭子飞行
duck_test(person)  # 人模仿鸭子叫
                  # 人模仿鸭子飞行
```

### 协议与接口

Python使用协议（非正式接口）概念，而不是严格的接口定义：

```python
# 可迭代协议：实现__iter__方法
class CustomIterableWithIter:
    def __init__(self, data):
        self.data = data
    
    def __iter__(self):
        return iter(self.data)

# 序列协议：实现__len__和__getitem__方法
class CustomSequence:
    def __init__(self, data):
        self.data = data
    
    def __len__(self):
        return len(self.data)
    
    def __getitem__(self, index):
        return self.data[index]

# 上下文管理协议：实现__enter__和__exit__方法
class CustomContextManager:
    def __enter__(self):
        print("进入上下文")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("退出上下文")
        return False

# 使用这些实现了不同协议的类
iterable = CustomIterableWithIter([1, 2, 3])
for item in iterable:
    print(item)  # 1, 2, 3

sequence = CustomSequence([4, 5, 6])
print(len(sequence))  # 3
print(sequence[1])    # 5
for item in sequence:  # 序列也是可迭代的，Python会自动调用__iter__
    print(item)  # 4, 5, 6

with CustomContextManager() as cm:
    print("在上下文中")
# 输出:
# 进入上下文
# 在上下文中
# 退出上下文
```

### 抽象基类vs鸭子类型

抽象基类(ABC)提供了显式的接口定义，而鸭子类型则是隐式的：

```python
from abc import ABC, abstractmethod
import random

# 使用ABC的明确接口
class RandomProvider(ABC):
    @abstractmethod
    def get_random(self):
        """返回一个随机值"""
        pass

class DiceRoller(RandomProvider):
    def get_random(self):
        return random.randint(1, 6)

class CoinFlipper(RandomProvider):
    def get_random(self):
        return random.choice(["正面", "反面"])

# 没有继承ABC的类，但实现了相同的方法（鸭子类型）
class RandomPicker:
    def __init__(self, items):
        self.items = items
    
    def get_random(self):
        return random.choice(self.items)

def get_random_value(provider):
    """这个函数可以接受任何有get_random方法的对象"""
    return provider.get_random()

# 使用各种对象
dice = DiceRoller()
coin = CoinFlipper()
picker = RandomPicker(["苹果", "香蕉", "橙子"])

print(get_random_value(dice))
print(get_random_value(coin))
print(get_random_value(picker))

# 使用isinstance进行类型检查
print(isinstance(dice, RandomProvider))    # True
print(isinstance(coin, RandomProvider))    # True
print(isinstance(picker, RandomProvider))  # False，但仍然可以用于get_random_value函数
```

## 运算符重载

Python允许通过特殊方法自定义对象的运算符行为：

### 基本运算符重载

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __repr__(self):
        return f"Vector({self.x}, {self.y})"
    
    # 加法: v1 + v2
    def __add__(self, other):
        if isinstance(other, Vector):
            return Vector(self.x + other.x, self.y + other.y)
        return NotImplemented
    
    # 减法: v1 - v2
    def __sub__(self, other):
        if isinstance(other, Vector):
            return Vector(self.x - other.x, self.y - other.y)
        return NotImplemented
    
    # 乘法: v * scalar
    def __mul__(self, scalar):
        if isinstance(scalar, (int, float)):
            return Vector(self.x * scalar, self.y * scalar)
        return NotImplemented
    
    # 右乘法: scalar * v
    def __rmul__(self, scalar):
        return self.__mul__(scalar)
    
    # 相等比较: v1 == v2
    def __eq__(self, other):
        if not isinstance(other, Vector):
            return NotImplemented
        return self.x == other.x and self.y == other.y
    
    # 长度: len(v)
    def __abs__(self):
        return (self.x ** 2 + self.y ** 2) ** 0.5
    
    # 布尔值: bool(v)
    def __bool__(self):
        return bool(abs(self))

# 使用Vector类
v1 = Vector(2, 4)
v2 = Vector(3, 6)

print(v1 + v2)     # Vector(5, 10)
print(v1 - v2)     # Vector(-1, -2)
print(v1 * 3)      # Vector(6, 12)
print(2 * v2)      # Vector(6, 12)
print(v1 == Vector(2, 4))  # True
print(abs(v1))     # 4.47213595499958
print(bool(v1))    # True
print(bool(Vector(0, 0)))  # False
```

### 容器操作符重载

```python
class CustomList:
    def __init__(self, items):
        self.items = list(items)
    
    def __repr__(self):
        return f"CustomList({self.items})"
    
    # 获取元素: obj[index]
    def __getitem__(self, index):
        return self.items[index]
    
    # 设置元素: obj[index] = value
    def __setitem__(self, index, value):
        self.items[index] = value
    
    # 删除元素: del obj[index]
    def __delitem__(self, index):
        del self.items[index]
    
    # 长度: len(obj)
    def __len__(self):
        return len(self.items)
    
    # 包含判断: item in obj
    def __contains__(self, item):
        return item in self.items
    
    # 迭代: for item in obj
    def __iter__(self):
        return iter(self.items)
    
    # 反向迭代: for item in reversed(obj)
    def __reversed__(self):
        return reversed(self.items)

# 使用CustomList
custom = CustomList([1, 2, 3, 4, 5])
print(custom[1])  # 2
custom[1] = 20
print(custom)  # CustomList([1, 20, 3, 4, 5])
del custom[0]
print(custom)  # CustomList([20, 3, 4, 5])
print(len(custom))  # 4
print(3 in custom)  # True
print([x for x in custom])  # [20, 3, 4, 5]
print([x for x in reversed(custom)])  # [5, 4, 3, 20]
```

## 函数式特性与类

Python的面向对象编程可以结合函数式编程特性。

### 将类设计为函数

通过实现`__call__`方法，可以使类的实例像函数一样被调用：

```python
class Adder:
    def __init__(self, n):
        self.n = n
    
    def __call__(self, x):
        return self.n + x

# 创建一个将参数加5的"函数"
add5 = Adder(5)
print(add5(10))  # 15
print(add5(20))  # 25

# 可以创建多个不同的"函数"实例
add3 = Adder(3)
print(add3(10))  # 13
```

### 用于组织函数的类

类可以用作命名空间，组织相关的函数：

```python
class StringUtils:
    @staticmethod
    def reverse(s):
        return s[::-1]
    
    @staticmethod
    def capitalize_words(s):
        return ' '.join(word.capitalize() for word in s.split())
    
    @staticmethod
    def remove_punctuation(s):
        import string
        translator = str.maketrans('', '', string.punctuation)
        return s.translate(translator)

# 使用类的静态方法
print(StringUtils.reverse("hello"))  # olleh
print(StringUtils.capitalize_words("hello world"))  # Hello World
print(StringUtils.remove_punctuation("Hello, world!"))  # Hello world
```

### 装饰器类

类也可以作为装饰器使用：

```python
class CountCalls:
    def __init__(self, func):
        self.func = func
        self.count = 0
    
    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"函数 {self.func.__name__} 被调用了 {self.count} 次")
        return self.func(*args, **kwargs)

@CountCalls
def say_hello(name):
    return f"Hello, {name}!"

print(say_hello("Alice"))  # 函数 say_hello 被调用了 1 次
                          # Hello, Alice!
print(say_hello("Bob"))    # 函数 say_hello 被调用了 2 次
                          # Hello, Bob!
```

## 设计模式在Python中的实现

### 单例模式

```python
class Singleton:
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class Logger(Singleton):
    def __init__(self, name="default"):
        # 只在第一次初始化
        if not hasattr(self, 'initialized'):
            self.name = name
            self.logs = []
            self.initialized = True
    
    def log(self, message):
        self.logs.append(message)
        print(f"[{self.name}] {message}")
    
    def get_logs(self):
        return self.logs

# 创建Logger实例
logger1 = Logger("主日志")
logger1.log("第一条日志")

# 创建另一个实例，实际上是同一个对象
logger2 = Logger("尝试创建第二个日志")
logger2.log("第二条日志")

print(logger1 is logger2)  # True
print(logger1.name)        # 主日志（不是"尝试创建第二个日志"）
print(logger1.get_logs())  # ['第一条日志', '第二条日志']
```

### 工厂模式

```python
class Animal:
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "汪汪!"

class Cat(Animal):
    def speak(self):
        return "喵喵!"

class AnimalFactory:
    @staticmethod
    def create_animal(animal_type):
        if animal_type == "dog":
            return Dog()
        elif animal_type == "cat":
            return Cat()
        else:
            raise ValueError(f"未知的动物类型: {animal_type}")

# 使用工厂创建对象
factory = AnimalFactory()
dog = factory.create_animal("dog")
cat = factory.create_animal("cat")

print(dog.speak())  # 汪汪!
print(cat.speak())  # 喵喵!
```

### 观察者模式

```python
class Subject:
    def __init__(self):
        self._observers = []
    
    def attach(self, observer):
        if observer not in self._observers:
            self._observers.append(observer)
    
    def detach(self, observer):
        try:
            self._observers.remove(observer)
        except ValueError:
            pass
    
    def notify(self, *args, **kwargs):
        for observer in self._observers:
            observer.update(self, *args, **kwargs)

class Observer:
    def update(self, subject, *args, **kwargs):
        pass

class DataCenter(Subject):
    def __init__(self):
        super().__init__()
        self._temperature = 0
    
    @property
    def temperature(self):
        return self._temperature
    
    @temperature.setter
    def temperature(self, value):
        self._temperature = value
        self.notify()

class TemperatureDisplay(Observer):
    def update(self, subject, *args, **kwargs):
        print(f"温度显示更新: {subject.temperature}°C")

class TemperatureAlert(Observer):
    def __init__(self, threshold):
        self.threshold = threshold
    
    def update(self, subject, *args, **kwargs):
        if subject.temperature > self.threshold:
            print(f"警报: 温度 {subject.temperature}°C 超过阈值 {self.threshold}°C!")

# 使用观察者模式
data_center = DataCenter()
display = TemperatureDisplay()
alert = TemperatureAlert(30)

data_center.attach(display)
data_center.attach(alert)

data_center.temperature = 25  # 温度显示更新: 25°C
data_center.temperature = 32  # 温度显示更新: 32°C
                             # 警报: 温度 32°C 超过阈值 30°C!
```

## 总结

Python的面向对象编程提供了强大的高级特性，包括：

1. **继承与多态**：通过方法解析顺序(MRO)和`super()`函数实现灵活的继承机制
2. **多重继承与Mixin**：提供代码复用和功能组合的机制
3. **抽象基类**：定义接口规范，确保子类实现必要的方法
4. **元类编程**：控制类的创建过程，实现高级功能如自动注册和属性验证
5. **描述符协议**：自定义属性访问行为，实现属性验证和懒加载
6. **属性访问控制**：通过`__slots__`、名称修饰和特殊方法控制属性访问
7. **鸭子类型与协议**：通过行为而非类型定义接口，实现灵活的多态
8. **运算符重载**：通过特殊方法自定义对象的运算符行为
9. **函数式特性**：结合函数式编程和面向对象编程的优点
10. **设计模式**：以Python风格实现常见的设计模式

掌握这些高级特性可以帮助你编写更加灵活、高效和可维护的Python代码。
