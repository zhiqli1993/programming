# Python类与对象

面向对象编程是Python的核心编程范式之一。本文详细介绍Python中类与对象的概念、定义方法和使用技巧。

## 类的基本概念

类(Class)是对象(Object)的蓝图或模板，定义了一组属性和方法，用于创建具有相似特性的对象集合。

### 类与实例

- **类(Class)**: 定义对象的结构和行为的模板
- **实例(Instance)**: 根据类创建的具体对象
- **属性(Attribute)**: 存储在类或实例中的数据
- **方法(Method)**: 定义在类中的函数，用于操作属性或执行其他功能

## 类的定义与实例化

### 基本语法

```python
class ClassName:
    """类的文档字符串"""
    
    # 类属性
    class_attribute = value
    
    # 初始化方法
    def __init__(self, param1, param2, ...):
        # 实例属性
        self.instance_attribute1 = param1
        self.instance_attribute2 = param2
    
    # 实例方法
    def method_name(self, param1, ...):
        # 方法体
        return result
```

### 简单示例

```python
class Person:
    """人员类，表示一个人的基本信息"""
    
    # 类属性
    species = "Homo sapiens"
    
    # 初始化方法
    def __init__(self, name, age):
        self.name = name  # 实例属性
        self.age = age    # 实例属性
    
    # 实例方法
    def introduce(self):
        return f"我叫{self.name}，今年{self.age}岁。"
    
    def have_birthday(self):
        self.age += 1
        return f"{self.name}过生日了，现在{self.age}岁。"

# 创建Person类的实例
person1 = Person("张三", 25)
person2 = Person("李四", 30)

# 访问实例属性
print(person1.name)  # 张三
print(person2.age)   # 30

# 调用实例方法
print(person1.introduce())  # 我叫张三，今年25岁。
print(person2.have_birthday())  # 李四过生日了，现在31岁。

# 访问类属性
print(Person.species)  # Homo sapiens
print(person1.species)  # Homo sapiens
```

## 类属性与实例属性

### 类属性

类属性是属于类本身的变量，被该类的所有实例共享。

```python
class Circle:
    pi = 3.14159  # 类属性
    
    def __init__(self, radius):
        self.radius = radius  # 实例属性
    
    def area(self):
        return Circle.pi * self.radius ** 2

circle1 = Circle(5)
circle2 = Circle(3)

print(circle1.area())  # 78.53975
print(circle2.area())  # 28.27431

# 修改类属性会影响所有实例
Circle.pi = 3.14
print(circle1.area())  # 78.5
print(circle2.area())  # 28.26
```

### 实例属性

实例属性是属于特定对象实例的变量，每个实例可以有不同的值。

```python
class Student:
    school = "Python Academy"  # 类属性
    
    def __init__(self, name, grade):
        self.name = name    # 实例属性
        self.grade = grade  # 实例属性
    
    def update_grade(self, new_grade):
        self.grade = new_grade

student1 = Student("Alice", 85)
student2 = Student("Bob", 92)

print(f"{student1.name}: {student1.grade}")  # Alice: 85
print(f"{student2.name}: {student2.grade}")  # Bob: 92

# 修改实例属性只影响该实例
student1.update_grade(90)
print(f"{student1.name}: {student1.grade}")  # Alice: 90
print(f"{student2.name}: {student2.grade}")  # Bob: 92
```

## self参数

在Python类方法中，`self`是一个约定俗成的参数名，表示方法调用的实例本身。

```python
class Example:
    def instance_method(self, x):
        return f"实例 {id(self)} 调用了方法，参数 x = {x}"

example = Example()
print(example.instance_method(10))
# 输出类似: 实例 140292453464336 调用了方法，参数 x = 10
```

虽然可以使用其他名称代替`self`，但强烈建议遵循这一约定。

## 构造函数与析构函数

### __init__ 方法

`__init__`是构造函数，在创建实例时自动调用，用于初始化对象状态。

```python
class Book:
    def __init__(self, title, author, pages):
        self.title = title
        self.author = author
        self.pages = pages
        self.current_page = 1
        print(f"《{self.title}》实例已创建")

book = Book("Python编程", "张三", 500)
# 输出: 《Python编程》实例已创建
```

### __del__ 方法

`__del__`是析构函数，在对象被垃圾回收时调用，用于执行清理操作。

```python
class Resource:
    def __init__(self, name):
        self.name = name
        print(f"资源 {self.name} 已分配")
    
    def __del__(self):
        print(f"资源 {self.name} 已释放")

def create_resource():
    r = Resource("临时资源")
    # 函数结束后，r超出作用域，触发__del__
    return

create_resource()
# 输出:
# 资源 临时资源 已分配
# 资源 临时资源 已释放
```

注意：不应依赖`__del__`进行关键清理操作，因为垃圾回收的时机不确定。

## 实例方法、类方法和静态方法

Python类支持三种类型的方法：

### 实例方法

实例方法是最常见的方法类型，第一个参数是`self`，通过实例调用。

```python
class Calculator:
    def add(self, a, b):
        return a + b

calc = Calculator()
result = calc.add(5, 3)  # 8
```

### 类方法

类方法使用`@classmethod`装饰器，第一个参数是`cls`(类本身)，可以通过类或实例调用。

```python
class Date:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day
    
    @classmethod
    def from_string(cls, date_string):
        """从字符串创建Date实例的替代构造函数"""
        year, month, day = map(int, date_string.split('-'))
        return cls(year, month, day)
    
    def display(self):
        return f"{self.year}-{self.month:02d}-{self.day:02d}"

# 使用标准构造函数
date1 = Date(2023, 7, 15)
print(date1.display())  # 2023-07-15

# 使用类方法作为替代构造函数
date2 = Date.from_string("2023-12-31")
print(date2.display())  # 2023-12-31
```

### 静态方法

静态方法使用`@staticmethod`装饰器，不接收特殊的第一个参数，可以通过类或实例调用。

```python
class MathUtils:
    @staticmethod
    def is_prime(n):
        """判断一个数是否为素数"""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True

# 通过类调用静态方法
print(MathUtils.is_prime(17))  # True

# 通过实例调用静态方法
math_utils = MathUtils()
print(math_utils.is_prime(10))  # False
```

## 实例方法、类方法和静态方法的比较

```python
class Example:
    class_attr = "类属性"
    
    def __init__(self, instance_attr):
        self.instance_attr = instance_attr
    
    # 实例方法
    def instance_method(self):
        """可以访问实例属性和类属性"""
        return f"实例属性: {self.instance_attr}, 类属性: {self.class_attr}"
    
    # 类方法
    @classmethod
    def class_method(cls):
        """可以访问类属性，但不能访问实例属性"""
        return f"类属性: {cls.class_attr}"
    
    # 静态方法
    @staticmethod
    def static_method():
        """既不能访问实例属性，也不能访问类属性(除非通过类名)"""
        return "静态方法不直接访问属性"

example = Example("实例属性值")
print(example.instance_method())  # 实例属性: 实例属性值, 类属性: 类属性
print(Example.class_method())     # 类属性: 类属性
print(example.static_method())    # 静态方法不直接访问属性
```

## 私有属性和方法

Python使用名称修饰(name mangling)实现属性和方法的私有性，即以双下划线开头的名称在类外部不能直接访问。

```python
class BankAccount:
    def __init__(self, owner, balance):
        self.owner = owner       # 公有属性
        self.__balance = balance  # 私有属性
    
    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            return self.__get_message("存款成功")
    
    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            return self.__get_message("取款成功")
        return "余额不足"
    
    def get_balance(self):
        return self.__balance
    
    # 私有方法
    def __get_message(self, action):
        return f"{action}，当前余额: {self.__balance}"

account = BankAccount("张三", 1000)
print(account.owner)         # 张三
print(account.get_balance()) # 1000

# 私有属性不能直接访问
# print(account.__balance)  # AttributeError

# 私有方法不能直接调用
# print(account.__get_message("测试"))  # AttributeError

# 名称修饰后的实际名称
print(account._BankAccount__balance)  # 1000 (不推荐这样访问)
```

注意：Python的私有属性并不是真正的私有，而是通过名称修饰使其更难被直接访问。

## 属性访问与特殊方法

### 属性访问器方法

Python提供了特殊方法来控制属性的访问：

```python
class Temperature:
    def __init__(self, celsius):
        self._celsius = celsius
    
    # 获取属性值
    def __getattr__(self, name):
        if name == "fahrenheit":
            return self._celsius * 9/5 + 32
        raise AttributeError(f"'{type(self).__name__}' 对象没有属性 '{name}'")
    
    # 设置属性值
    def __setattr__(self, name, value):
        if name == "fahrenheit":
            self._celsius = (value - 32) * 5/9
        else:
            # 调用父类的__setattr__方法
            super().__setattr__(name, value)
    
    # 检查属性是否存在
    def __hasattr__(self, name):
        return name in ["_celsius", "fahrenheit"]

temp = Temperature(25)
print(temp._celsius)    # 25
print(temp.fahrenheit)  # 77.0

temp.fahrenheit = 86
print(temp._celsius)    # 30.0
```

### 属性装饰器

`@property`装饰器提供了更简洁的方式来定义属性访问器：

```python
class Circle:
    def __init__(self, radius):
        self._radius = radius
    
    @property
    def radius(self):
        """半径的getter方法"""
        return self._radius
    
    @radius.setter
    def radius(self, value):
        """半径的setter方法"""
        if value <= 0:
            raise ValueError("半径必须为正数")
        self._radius = value
    
    @property
    def diameter(self):
        """直径属性"""
        return self._radius * 2
    
    @property
    def area(self):
        """面积属性"""
        return 3.14159 * self._radius ** 2

circle = Circle(5)
print(circle.radius)   # 5
print(circle.diameter) # 10
print(circle.area)     # 78.53975

circle.radius = 10
print(circle.diameter) # 20
print(circle.area)     # 314.159

# 无setter的属性不能直接设置
# circle.diameter = 30  # AttributeError

# 值验证
# circle.radius = -5  # ValueError: 半径必须为正数
```

## 特殊方法(魔术方法)

Python类可以实现特殊方法(以双下划线开头和结尾)来支持各种操作：

### 字符串表示

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    # 供开发者使用的字符串表示
    def __repr__(self):
        return f"Person(name='{self.name}', age={self.age})"
    
    # 供用户友好的字符串表示
    def __str__(self):
        return f"{self.name}, {self.age}岁"

person = Person("张三", 30)
print(repr(person))  # Person(name='张三', age=30)
print(str(person))   # 张三, 30岁
print(person)        # 张三, 30岁 (使用__str__)
```

### 比较操作

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __eq__(self, other):
        if not isinstance(other, Point):
            return NotImplemented
        return self.x == other.x and self.y == other.y
    
    def __lt__(self, other):
        if not isinstance(other, Point):
            return NotImplemented
        return (self.x, self.y) < (other.x, other.y)

p1 = Point(1, 2)
p2 = Point(1, 2)
p3 = Point(3, 4)

print(p1 == p2)  # True
print(p1 == p3)  # False
print(p1 < p3)   # True
```

### 数值操作

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __add__(self, other):
        if not isinstance(other, Vector):
            return NotImplemented
        return Vector(self.x + other.x, self.y + other.y)
    
    def __sub__(self, other):
        if not isinstance(other, Vector):
            return NotImplemented
        return Vector(self.x - other.x, self.y - other.y)
    
    def __mul__(self, scalar):
        if not isinstance(scalar, (int, float)):
            return NotImplemented
        return Vector(self.x * scalar, self.y * scalar)
    
    def __rmul__(self, scalar):
        return self.__mul__(scalar)
    
    def __str__(self):
        return f"Vector({self.x}, {self.y})"

v1 = Vector(1, 2)
v2 = Vector(3, 4)
print(v1 + v2)     # Vector(4, 6)
print(v1 - v2)     # Vector(-2, -2)
print(v1 * 3)      # Vector(3, 6)
print(2 * v2)      # Vector(6, 8)
```

### 容器操作

```python
class CustomList:
    def __init__(self, items):
        self._items = list(items)
    
    def __len__(self):
        return len(self._items)
    
    def __getitem__(self, index):
        return self._items[index]
    
    def __setitem__(self, index, value):
        self._items[index] = value
    
    def __delitem__(self, index):
        del self._items[index]
    
    def __contains__(self, item):
        return item in self._items
    
    def __iter__(self):
        return iter(self._items)
    
    def __reversed__(self):
        return reversed(self._items)

clist = CustomList([1, 2, 3, 4, 5])
print(len(clist))         # 5
print(clist[2])           # 3
clist[2] = 10
print(clist[2])           # 10
del clist[0]
print(3 in clist)         # False
print(10 in clist)        # True

for item in clist:
    print(item, end=" ")  # 2 10 4 5
print()

for item in reversed(clist):
    print(item, end=" ")  # 5 4 10 2
```

### 上下文管理器

```python
class DatabaseConnection:
    def __init__(self, db_name):
        self.db_name = db_name
        self.connected = False
    
    def __enter__(self):
        print(f"连接到数据库 '{self.db_name}'")
        self.connected = True
        return self  # 返回上下文管理器对象
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print(f"关闭数据库连接 '{self.db_name}'")
        self.connected = False
        # 返回True表示异常已处理，返回None或False则传播异常
        return False
    
    def execute(self, query):
        if not self.connected:
            raise RuntimeError("未连接到数据库")
        print(f"执行查询: {query}")

# 使用with语句自动管理资源
with DatabaseConnection("example_db") as db:
    db.execute("SELECT * FROM users")
    db.execute("UPDATE users SET active = 1")
# 离开with块时自动调用__exit__
```

## 类的继承

继承是面向对象编程的核心机制之一，允许一个类(子类)继承另一个类(父类)的属性和方法。

### 基本继承

```python
# 父类
class Animal:
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        return "动物发出声音"
    
    def eat(self):
        return f"{self.name}正在吃东西"

# 子类
class Dog(Animal):
    def speak(self):
        return "汪汪!"

# 子类
class Cat(Animal):
    def __init__(self, name, color):
        # 调用父类的__init__方法
        super().__init__(name)
        self.color = color
    
    def speak(self):
        return "喵喵!"
    
    def purr(self):
        return f"{self.color}色的{self.name}在打呼噜"

# 创建实例
animal = Animal("动物")
dog = Dog("小黑")
cat = Cat("小花", "橘")

print(animal.speak())  # 动物发出声音
print(dog.speak())     # 汪汪!
print(cat.speak())     # 喵喵!

print(animal.eat())    # 动物正在吃东西
print(dog.eat())       # 小黑正在吃东西
print(cat.eat())       # 小花正在吃东西

print(cat.purr())      # 橘色的小花在打呼噜
```

### 多继承

Python支持多继承，一个类可以继承多个父类。

```python
class Swimmer:
    def swim(self):
        return "正在游泳"
    
    def move(self):
        return "水中移动"

class Flyer:
    def fly(self):
        return "正在飞行"
    
    def move(self):
        return "空中移动"

# 多继承
class Duck(Swimmer, Flyer):
    def __init__(self, name):
        self.name = name
    
    def quack(self):
        return f"{self.name}: 嘎嘎!"

duck = Duck("唐老鸭")
print(duck.swim())   # 正在游泳
print(duck.fly())    # 正在飞行
print(duck.quack())  # 唐老鸭: 嘎嘎!
print(duck.move())   # 水中移动 (使用第一个父类Swimmer的方法)
```

注意：在多继承中，Python使用方法解析顺序(MRO, Method Resolution Order)来确定使用哪个父类的方法。

### 方法解析顺序(MRO)

MRO决定了Python在多继承时查找方法的顺序。可以通过`__mro__`属性或`mro()`方法查看。

```python
class A:
    def method(self):
        return "A的方法"

class B(A):
    def method(self):
        return "B的方法"

class C(A):
    def method(self):
        return "C的方法"

class D(B, C):
    pass

# 查看MRO
print(D.__mro__)
# (<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)

d = D()
print(d.method())  # B的方法 (按照MRO顺序，先查找B类)
```

### 抽象基类

抽象基类(ABC, Abstract Base Class)定义接口但不实现全部方法，要求子类实现这些方法。

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        """计算面积"""
        pass
    
    @abstractmethod
    def perimeter(self):
        """计算周长"""
        pass
    
    def describe(self):
        """形状描述"""
        return "这是一个形状"

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14159 * self.radius ** 2
    
    def perimeter(self):
        return 2 * 3.14159 * self.radius

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)

# 尝试实例化抽象类会失败
# shape = Shape()  # TypeError: Can't instantiate abstract class Shape

circle = Circle(5)
rectangle = Rectangle(4, 6)

print(circle.area())       # 78.53975
print(rectangle.area())    # 24
print(circle.describe())   # 这是一个形状
```

## 类的组合

组合是一种通过在一个类中包含其他类的实例来建立类之间关系的方式。

```python
class Engine:
    def __init__(self, power):
        self.power = power
    
    def start(self):
        return f"{self.power}马力引擎启动"
    
    def stop(self):
        return "引擎停止"

class Wheel:
    def __init__(self, size):
        self.size = size
    
    def rotate(self):
        return f"{self.size}英寸车轮旋转"

class Car:
    def __init__(self, model, engine_power, wheel_size):
        self.model = model
        self.engine = Engine(engine_power)  # 组合
        self.wheels = [Wheel(wheel_size) for _ in range(4)]  # 组合
    
    def start(self):
        engine_status = self.engine.start()
        wheels_status = [wheel.rotate() for wheel in self.wheels]
        return f"{self.model} - {engine_status}, {', '.join(wheels_status)}"
    
    def stop(self):
        return f"{self.model} - {self.engine.stop()}"

car = Car("特斯拉", 300, 19)
print(car.start())
# 特斯拉 - 300马力引擎启动, 19英寸车轮旋转, 19英寸车轮旋转, 19英寸车轮旋转, 19英寸车轮旋转
print(car.stop())
# 特斯拉 - 引擎停止
```

## 继承与组合的比较

- **继承**："是一个"(is-a)关系，子类是父类的一个特例
- **组合**："有一个"(has-a)关系，类包含其他类的实例作为属性

```python
# 继承示例: 鸟是一个动物
class Animal:
    def eat(self):
        return "吃东西"

class Bird(Animal):  # is-a关系
    def fly(self):
        return "飞翔"

# 组合示例: 汽车有一个引擎
class Engine:
    def start(self):
        return "引擎启动"

class Car:
    def __init__(self):
        self.engine = Engine()  # has-a关系
    
    def start(self):
        return f"汽车启动 - {self.engine.start()}"
```

一般而言，优先考虑组合而不是继承，因为组合提供了更灵活的设计。

## 类的设计原则

设计Python类时，应遵循以下原则：

1. **单一职责原则(SRP)**：一个类应该只有一个改变的理由
2. **开放封闭原则(OCP)**：类应该对扩展开放，对修改关闭
3. **里氏替换原则(LSP)**：子类应该可以替换父类而不影响程序正确性
4. **接口隔离原则(ISP)**：多个专用接口优于一个通用接口
5. **依赖倒置原则(DIP)**：依赖抽象而不是具体实现

```python
# 不良设计: 违反单一职责原则
class UserManager:
    def register_user(self, username, password):
        # 注册用户
        pass
    
    def send_email(self, user, message):
        # 发送邮件
        pass
    
    def save_to_database(self, data):
        # 保存到数据库
        pass

# 改进设计: 遵循单一职责原则
class UserManager:
    def register_user(self, username, password):
        # 注册用户
        pass

class EmailService:
    def send_email(self, user, message):
        # 发送邮件
        pass

class DatabaseService:
    def save(self, data):
        # 保存到数据库
        pass
```

## 最佳实践

1. **遵循命名约定**：
   - 类名使用驼峰命名法(CamelCase)
   - 方法和属性使用小写加下划线(snake_case)
   - 私有属性和方法以双下划线开头

2. **合理使用特性**：
   - 使用`@property`代替简单的getter方法
   - 使用特殊方法使对象行为更Pythonic

3. **减少耦合**：
   - 使用依赖注入而不是直接实例化依赖
   - 优先使用组合而不是继承

4. **保持简单**：
   - 遵循KISS原则(Keep It Simple, Stupid)
   - 避免过度工程化
   - 类的设计应该反映问题领域
