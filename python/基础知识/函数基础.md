# Python函数基础

函数是Python中最基本的代码组织和重用单位。本文档介绍了Python函数的基础知识、参数系统、返回值和作用域规则，以及各种高级函数特性。

## 函数定义与调用

### 基本语法

Python函数使用`def`关键字定义，语法如下：

```python
def 函数名(参数1, 参数2, ...):
    """文档字符串（可选）"""
    # 函数体
    return 返回值  # 可选
```

简单示例：

```python
def greet(name):
    """向指定的人打招呼"""
    return f"Hello, {name}!"

# 调用函数
message = greet("Alice")
print(message)  # 输出: Hello, Alice!
```

### 文档字符串

文档字符串（docstring）是一个函数的第一个语句，用三引号括起来，描述函数的功能、参数和返回值。它们可以通过`help()`函数或`.__doc__`属性访问。

```python
def calculate_area(radius):
    """
    计算圆的面积。
    
    参数:
        radius (float): 圆的半径
        
    返回:
        float: 圆的面积
    """
    import math
    return math.pi * radius ** 2

# 访问文档字符串
print(help(calculate_area))
print(calculate_area.__doc__)
```

## 函数参数

Python提供了非常灵活的函数参数系统，包括位置参数、默认参数、关键字参数和可变参数。

### 位置参数

位置参数是函数定义中最基本的参数形式，调用时必须按照定义的顺序提供相应的参数。

```python
def power(base, exponent):
    return base ** exponent

result = power(2, 3)  # 2^3 = 8
```

### 默认参数

默认参数在函数定义时指定一个默认值，如果调用时没有提供该参数，将使用默认值。

```python
def power(base, exponent=2):
    return base ** exponent

result1 = power(2)      # 使用默认指数2，结果为4
result2 = power(2, 3)   # 指定指数3，结果为8
```

默认参数需要遵循一些规则：

1. 默认参数必须放在位置参数之后
2. 默认参数的值在函数定义时确定，而不是调用时
3. 默认参数应该是不可变对象，避免使用可变对象（如列表、字典）作为默认值

```python
# 错误示例：可变对象作为默认参数
def add_item(item, items=[]):
    items.append(item)
    return items

print(add_item("apple"))  # ['apple']
print(add_item("banana"))  # ['apple', 'banana'] -- 可能不是预期的结果!

# 正确做法
def add_item(item, items=None):
    if items is None:
        items = []
    items.append(item)
    return items
```

### 关键字参数

关键字参数允许通过参数名指定参数，而不必关心顺序。

```python
def describe_person(name, age, city):
    return f"{name} is {age} years old and lives in {city}."

# 使用关键字参数
result = describe_person(age=30, city="New York", name="Alice")
print(result)  # Alice is 30 years old and lives in New York.
```

也可以混合使用位置参数和关键字参数，但位置参数必须在关键字参数之前：

```python
# 正确：位置参数在前，关键字参数在后
describe_person("Bob", city="Boston", age=25)

# 错误：位置参数在关键字参数之后
# describe_person(name="Charlie", 35, "Chicago")
```

### 可变位置参数 (*args)

`*args`参数允许函数接受任意数量的位置参数，这些参数被打包成一个元组。

```python
def sum_all(*numbers):
    """计算所有参数的和"""
    total = 0
    for num in numbers:
        total += num
    return total

# 调用带有不同数量参数的函数
print(sum_all(1, 2))        # 3
print(sum_all(1, 2, 3, 4))  # 10
print(sum_all())            # 0
```

也可以在调用函数时使用`*`展开序列：

```python
numbers = [1, 2, 3, 4, 5]
result = sum_all(*numbers)  # 相当于sum_all(1, 2, 3, 4, 5)
print(result)  # 15
```

### 可变关键字参数 (**kwargs)

`**kwargs`参数允许函数接受任意数量的关键字参数，这些参数被打包成一个字典。

```python
def create_profile(**user_info):
    """创建用户资料"""
    print("User Profile:")
    for key, value in user_info.items():
        print(f"{key}: {value}")
    return user_info

# 调用带有不同关键字参数的函数
profile1 = create_profile(name="Alice", age=30, city="New York")
profile2 = create_profile(name="Bob", email="bob@example.com", is_active=True)
```

同样，可以在调用函数时使用`**`展开字典：

```python
user_data = {"name": "Charlie", "occupation": "Developer", "years_experience": 5}
create_profile(**user_data)  # 相当于create_profile(name="Charlie", occupation="Developer", years_experience=5)
```

### 参数顺序

在定义函数时，参数必须按照以下顺序排列：

1. 位置参数
2. `*args`参数
3. 默认参数
4. `**kwargs`参数

```python
def complex_function(pos1, pos2, *args, default1="default", default2=10, **kwargs):
    # 函数体
    pass
```

## 返回值

### 基本返回值

Python函数可以使用`return`语句返回值。如果没有显式的`return`语句，函数将返回`None`。

```python
def add(a, b):
    return a + b

def say_hello(name):
    print(f"Hello, {name}!")
    # 没有return语句，隐式返回None

result1 = add(3, 4)  # 7
result2 = say_hello("Alice")  # 打印"Hello, Alice!"，并返回None
```

### 返回多个值

Python函数可以返回多个值，实际上是返回一个元组，但可以通过解包直接获取各个值。

```python
def get_dimensions():
    return 100, 50, 25  # 返回元组(100, 50, 25)

# 解包返回值
length, width, height = get_dimensions()
print(f"Length: {length}, Width: {width}, Height: {height}")

# 也可以直接获取元组
dimensions = get_dimensions()
print(f"Dimensions: {dimensions}")  # Dimensions: (100, 50, 25)
```

### 提前返回

`return`语句会立即结束函数的执行并返回值。这可以用来处理特殊情况或错误条件。

```python
def divide(a, b):
    if b == 0:
        return "Error: Division by zero"
    return a / b

print(divide(10, 2))  # 5.0
print(divide(10, 0))  # Error: Division by zero
```

## 变量作用域与命名空间

### LEGB规则

Python在解析变量名时遵循LEGB规则，按以下顺序查找变量：

1. **Local**（局部）：函数内部定义的变量
2. **Enclosing**（嵌套）：外层函数定义的变量
3. **Global**（全局）：模块级别定义的变量
4. **Built-in**（内置）：Python内置的名称

```python
x = "global x"  # 全局变量

def outer_function():
    x = "outer x"  # 外层函数的局部变量
    
    def inner_function():
        x = "inner x"  # 内层函数的局部变量
        print(f"内层函数: x = {x}")
    
    inner_function()
    print(f"外层函数: x = {x}")

outer_function()
print(f"全局作用域: x = {x}")

# 输出:
# 内层函数: x = inner x
# 外层函数: x = outer x
# 全局作用域: x = global x
```

### global和nonlocal关键字

使用`global`关键字可以在函数内部修改全局变量：

```python
counter = 0

def increment():
    global counter
    counter += 1
    return counter

print(increment())  # 1
print(increment())  # 2
print(counter)      # 2
```

使用`nonlocal`关键字可以在嵌套函数中修改外层函数的变量：

```python
def outer():
    count = 0
    
    def inner():
        nonlocal count
        count += 1
        return count
    
    return inner

counter = outer()
print(counter())  # 1
print(counter())  # 2
print(counter())  # 3
```

这种创建带有状态的函数的模式称为"闭包"。

## 函数作为对象

在Python中，函数是一等公民（first-class objects），这意味着函数可以：

1. 赋值给变量
2. 作为参数传递给其他函数
3. 作为其他函数的返回值
4. 存储在数据结构中

### 函数赋值给变量

```python
def greet(name):
    return f"Hello, {name}!"

# 将函数赋值给变量
welcome = greet
print(welcome("Alice"))  # Hello, Alice!
```

### 函数作为参数

```python
def apply_function(func, value):
    """应用函数到值上并返回结果"""
    return func(value)

def square(x):
    return x ** 2

def double(x):
    return x * 2

print(apply_function(square, 5))  # 25
print(apply_function(double, 5))  # 10
```

### 函数作为返回值

```python
def get_operation(operation_name):
    """返回对应的操作函数"""
    def add(a, b):
        return a + b
    
    def subtract(a, b):
        return a - b
    
    def multiply(a, b):
        return a * b
    
    def divide(a, b):
        if b == 0:
            return "Error: Division by zero"
        return a / b
    
    operations = {
        "add": add,
        "subtract": subtract,
        "multiply": multiply,
        "divide": divide
    }
    
    return operations.get(operation_name, lambda a, b: "Invalid operation")

# 获取函数并调用
add_func = get_operation("add")
print(add_func(5, 3))  # 8

divide_func = get_operation("divide")
print(divide_func(10, 2))  # 5.0
```

### 存储在数据结构中

```python
def add(a, b): return a + b
def subtract(a, b): return a - b
def multiply(a, b): return a * b
def divide(a, b): return a / b if b != 0 else "Error"

# 存储在列表中
operations = [add, subtract, multiply, divide]
for op in operations:
    print(op(10, 5))  # 15, 5, 50, 2.0

# 存储在字典中
op_dict = {
    "+": add,
    "-": subtract,
    "*": multiply,
    "/": divide
}
print(op_dict["+"](7, 3))  # 10
print(op_dict["*"](7, 3))  # 21
```

## 匿名函数 (lambda)

lambda函数是一种小型匿名函数，可以在需要函数对象的地方使用。lambda函数可以有任意数量的参数，但只能有一个表达式。

```python
# 基本lambda函数
square = lambda x: x ** 2
print(square(5))  # 25

# 多参数lambda函数
add = lambda a, b: a + b
print(add(3, 4))  # 7

# 在其他函数中使用lambda
pairs = [(1, 'one'), (3, 'three'), (2, 'two'), (4, 'four')]
pairs.sort(key=lambda pair: pair[0])
print(pairs)  # [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]

# 与map和filter一起使用
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x**2, numbers))
print(squared)  # [1, 4, 9, 16, 25]

even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)  # [2, 4]
```

lambda函数最适合需要简单函数的场景，特别是作为其他函数的参数。对于更复杂的函数，应该使用常规的`def`语句。

## 递归函数

递归函数是调用自身的函数。递归需要有基本情况（base case）来停止递归，否则会导致无限递归。

```python
def factorial(n):
    """计算n的阶乘"""
    if n <= 1:  # 基本情况
        return 1
    else:  # 递归情况
        return n * factorial(n - 1)

print(factorial(5))  # 120 (5 * 4 * 3 * 2 * 1)
```

递归函数的另一个例子是计算斐波那契数列：

```python
def fibonacci(n):
    """计算斐波那契数列的第n个数"""
    if n <= 1:  # 基本情况
        return n
    else:  # 递归情况
        return fibonacci(n - 1) + fibonacci(n - 2)

# 打印斐波那契数列的前10个数
for i in range(10):
    print(fibonacci(i), end=" ")  # 0 1 1 2 3 5 8 13 21 34
```

递归是一种强大的编程技术，特别适合解决那些可以分解为相似子问题的问题，但需要注意：

1. 每个递归函数必须有一个或多个基本情况（终止条件）
2. 递归函数可能导致栈溢出，特别是对于深层递归
3. Python的默认递归深度限制是1000，可以通过`sys.setrecursionlimit()`修改
4. 有些递归解决方案可能效率较低，可以考虑使用记忆化或迭代方法优化

## 函数高级特性

### 函数注解

Python 3引入了函数注解，可以为函数参数和返回值提供类型提示。注解不会强制执行类型检查，但可以供IDE、类型检查工具和文档使用。

```python
def greeting(name: str, age: int = 30) -> str:
    """返回一个问候语句"""
    return f"Hello {name}, you are {age} years old!"

# 访问函数注解
print(greeting.__annotations__)  # {'name': <class 'str'>, 'age': <class 'int'>, 'return': <class 'str'>}
```

### 局部函数

可以在函数内定义另一个函数，这种函数称为局部函数。局部函数只能在包含它的函数内部访问。

```python
def outer(x):
    """外部函数"""
    def inner(y):
        """内部函数"""
        return x + y
    
    return inner(10)  # 调用内部函数

print(outer(5))  # 15
```

### 闭包

闭包是一个函数对象，它记住了创建它的环境中的值。

```python
def make_multiplier(factor):
    """返回一个将数字乘以factor的函数"""
    def multiplier(number):
        return number * factor
    
    return multiplier

# 创建闭包
double = make_multiplier(2)
triple = make_multiplier(3)

print(double(5))  # 10
print(triple(5))  # 15
```

### 装饰器

装饰器是一种特殊的函数，它可以修改其他函数的行为。装饰器接受一个函数作为参数，并返回一个新函数。

```python
def log_function_call(func):
    """记录函数调用的装饰器"""
    def wrapper(*args, **kwargs):
        print(f"调用函数: {func.__name__}")
        result = func(*args, **kwargs)
        print(f"函数 {func.__name__} 返回: {result}")
        return result
    
    return wrapper

@log_function_call
def add(a, b):
    return a + b

result = add(3, 5)  # 自动应用装饰器
# 输出:
# 调用函数: add
# 函数 add 返回: 8
```

装饰器语法`@decorator`等同于`function = decorator(function)`。

### 生成器函数

生成器函数使用`yield`语句而不是`return`语句返回值。当调用生成器函数时，它返回一个生成器对象，可以迭代生成值。

```python
def countdown(n):
    """从n倒数到1的生成器"""
    while n > 0:
        yield n
        n -= 1

# 使用生成器
for i in countdown(5):
    print(i, end=" ")  # 5 4 3 2 1

# 使用next()函数手动迭代
counter = countdown(3)
print(next(counter))  # 3
print(next(counter))  # 2
print(next(counter))  # 1
# print(next(counter))  # 引发StopIteration异常
```

生成器可以有效处理大数据集或无限序列，因为它们一次只生成一个值，而不是在内存中存储整个序列。

### 函数缓存

Python 3.2引入了`functools.lru_cache`装饰器，可以缓存函数调用的结果，避免重复计算。

```python
import functools
import time

@functools.lru_cache(maxsize=None)  # 无限缓存大小
def fibonacci(n):
    """使用缓存计算斐波那契数列"""
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# 测试性能
start = time.time()
print(fibonacci(35))  # 9227465
print(f"用时: {time.time() - start:.6f}秒")  # 非常快，因为有缓存

# 没有缓存的版本会非常慢
def fibonacci_slow(n):
    if n <= 1:
        return n
    return fibonacci_slow(n-1) + fibonacci_slow(n-2)

# start = time.time()
# print(fibonacci_slow(35))  # 会非常慢
# print(f"用时: {time.time() - start:.6f}秒")
```

## 常见函数设计模式

### 函数组合

```python
def compose(f, g):
    """组合两个函数"""
    return lambda x: f(g(x))

# 示例函数
def double(x): return x * 2
def square(x): return x ** 2

# 组合函数
double_then_square = compose(square, double)
square_then_double = compose(double, square)

print(double_then_square(3))  # 36 (= (3*2)^2)
print(square_then_double(3))  # 18 (= (3^2)*2)
```

### 部分应用和柯里化

```python
from functools import partial

def multiply(a, b, c):
    return a * b * c

# 部分应用
double = partial(multiply, 2, 1)
print(double(5))  # 10

# 手动柯里化
def curry_multiply(a):
    def with_b(b):
        def with_c(c):
            return a * b * c
        return with_c
    return with_b

multiply_curried = curry_multiply(2)(3)
print(multiply_curried(4))  # 24
```

### 回调函数

```python
def process_data(data, callback):
    """处理数据并应用回调函数"""
    result = []
    for item in data:
        # 处理数据
        processed = item * 2
        # 应用回调
        result.append(callback(processed))
    return result

# 定义回调函数
def square(x):
    return x ** 2

def add_one(x):
    return x + 1

# 应用不同的回调
data = [1, 2, 3, 4, 5]
result1 = process_data(data, square)
result2 = process_data(data, add_one)

print(result1)  # [4, 16, 36, 64, 100]
print(result2)  # [3, 5, 7, 9, 11]
```

## 函数设计最佳实践

1. **单一职责原则**：每个函数应该只做一件事，并且做好。

2. **短小精悍**：保持函数简短，通常不超过20-30行。

3. **参数数量**：尽量减少参数数量，通常不超过3-4个。

4. **命名清晰**：函数名应该清晰地表明其功能，使用动词或动词短语。

5. **提供文档**：为重要函数编写文档字符串，说明功能、参数和返回值。

6. **处理错误**：妥善处理可能的错误情况，可以使用异常或返回错误值。

7. **避免副作用**：尽量避免修改函数外部的状态，特别是全局变量。

8. **返回值一致性**：函数的返回值类型应该保持一致，避免在不同情况下返回不同类型。

9. **函数抽象**：将重复的代码提取为函数，增强代码的可维护性。

10. **测试驱动开发**：编写函数时考虑如何测试它，使函数易于测试。

遵循这些原则可以帮助你编写出更清晰、更可维护的Python函数，提高代码质量和可读性。
