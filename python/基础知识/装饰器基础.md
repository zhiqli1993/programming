# Python装饰器基础

装饰器是Python中一个强大而灵活的特性，它允许程序员修改函数或类的行为而不改变其源代码。本文详细介绍Python装饰器的基本概念、工作原理和常见应用场景。

## 装饰器的基本概念

装饰器本质上是一个可调用对象（通常是函数），它接受一个函数作为输入，并返回另一个函数。装饰器的主要目的是在不修改原函数代码的情况下，增强或修改函数的功能。

装饰器的工作原理可以简单概括为：

1. 接收一个函数作为参数
2. 定义一个内部包装函数
3. 在包装函数中增强原函数的功能
4. 返回这个包装函数

## 基本装饰器

### 简单装饰器示例

下面是一个最简单的装饰器示例，用于计算函数的执行时间：

```python
import time
import functools

def timer(func):
    """计算函数执行时间的装饰器"""
    @functools.wraps(func)  # 保留原函数的元信息
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"函数 {func.__name__} 执行时间: {end_time - start_time:.4f} 秒")
        return result
    return wrapper

# 使用装饰器
@timer
def slow_function(n):
    """一个耗时的函数"""
    time.sleep(n)
    return f"睡眠了 {n} 秒"

# 调用被装饰的函数
print(slow_function(1))
```

输出：
```
函数 slow_function 执行时间: 1.0010 秒
睡眠了 1 秒
```

### 装饰器语法糖

上面的`@timer`语法是Python的一种语法糖，等价于：

```python
def slow_function(n):
    time.sleep(n)
    return f"睡眠了 {n} 秒"

# 手动应用装饰器
slow_function = timer(slow_function)
```

这种`@decorator`语法更加简洁和直观，是Python中使用装饰器的标准方式。

### 为什么使用functools.wraps

在上面的例子中，我们使用了`@functools.wraps(func)`。这是一个重要的实践，它能够保留原函数的元信息，如函数名、文档字符串和参数签名等。不使用`wraps`会导致这些信息丢失：

```python
def timer_without_wraps(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"函数执行时间: {end_time - start_time:.4f} 秒")
        return result
    return wrapper

@timer_without_wraps
def example():
    """这是示例函数的文档字符串"""
    pass

# 查看函数信息
print(example.__name__)  # 输出: wrapper，而不是example
print(example.__doc__)   # 输出: None，而不是原函数的文档字符串
```

使用`@functools.wraps`后，这些元信息会被正确保留：

```python
def timer_with_wraps(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"函数执行时间: {end_time - start_time:.4f} 秒")
        return result
    return wrapper

@timer_with_wraps
def example():
    """这是示例函数的文档字符串"""
    pass

# 查看函数信息
print(example.__name__)  # 输出: example
print(example.__doc__)   # 输出: 这是示例函数的文档字符串
```

## 带参数的装饰器

有时我们需要创建可以接受参数的装饰器。为了实现这一点，需要在外部再包装一层函数：

```python
def repeat(n=1):
    """一个可以接受参数的装饰器，用于重复执行函数n次"""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            results = []
            for _ in range(n):
                results.append(func(*args, **kwargs))
            return results
        return wrapper
    return decorator

# 使用带参数的装饰器
@repeat(3)
def greet(name):
    return f"Hello, {name}!"

# 调用被装饰的函数
print(greet("World"))  # 输出: ['Hello, World!', 'Hello, World!', 'Hello, World!']
```

在这个例子中：
1. `repeat(3)`返回装饰器函数`decorator`
2. `@decorator`然后装饰`greet`函数
3. 调用`greet("World")`实际上是调用`wrapper("World")`，它会执行`greet`函数3次

### 装饰器参数的默认值

带参数的装饰器也可以有默认值，使其在不传递参数时仍然可以工作：

```python
@repeat  # 使用默认参数n=1
def say_hi():
    return "Hi!"

print(say_hi())  # 输出: ['Hi!']

@repeat(5)  # 指定参数n=5
def say_hello():
    return "Hello!"

print(say_hello())  # 输出: ['Hello!', 'Hello!', 'Hello!', 'Hello!', 'Hello!']
```

## 类装饰器

装饰器不仅可以装饰函数，还可以装饰类。类装饰器接收一个类作为参数，并返回一个新类：

```python
def add_greeting(cls):
    """为类添加greet方法的装饰器"""
    def greet(self, name):
        return f"{self.__class__.__name__} says: Hello, {name}!"
    
    cls.greet = greet
    return cls

@add_greeting
class Person:
    def __init__(self, name):
        self.name = name

# 使用被装饰的类
person = Person("Alice")
print(person.greet("Bob"))  # 输出: Person says: Hello, Bob!
```

## 类作为装饰器

装饰器也可以是一个类，而不仅仅是函数。要使类作为装饰器，需要实现`__call__`方法：

```python
class CountCalls:
    """统计函数被调用次数的装饰器类"""
    def __init__(self, func):
        functools.update_wrapper(self, func)
        self.func = func
        self.count = 0
    
    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"函数 {self.func.__name__} 已被调用 {self.count} 次")
        return self.func(*args, **kwargs)

@CountCalls
def say_hello(name):
    return f"Hello, {name}!"

# 调用被装饰的函数
print(say_hello("Alice"))
print(say_hello("Bob"))
print(say_hello("Charlie"))
```

输出：
```
函数 say_hello 已被调用 1 次
Hello, Alice!
函数 say_hello 已被调用 2 次
Hello, Bob!
函数 say_hello 已被调用 3 次
Hello, Charlie!
```

使用类作为装饰器的优势在于可以维护状态（如上例中的`count`变量），这在某些场景下比函数装饰器更加方便。

## 装饰器链

可以将多个装饰器应用于一个函数，这称为装饰器链。装饰器的应用顺序是从下到上的：

```python
def bold(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        return f"<b>{func(*args, **kwargs)}</b>"
    return wrapper

def italic(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        return f"<i>{func(*args, **kwargs)}</i>"
    return wrapper

@bold
@italic
def greet(name):
    return f"Hello, {name}!"

print(greet("World"))  # 输出: <b><i>Hello, World!</i></b>
```

装饰器的应用顺序非常重要。在上面的例子中，`italic`首先应用于`greet`，然后`bold`应用于`italic(greet)`的结果。因此，最终的输出是粗体包围斜体。

如果调换装饰器的顺序：

```python
@italic
@bold
def greet(name):
    return f"Hello, {name}!"

print(greet("World"))  # 输出: <i><b>Hello, World!</b></i>
```

现在斜体包围粗体，结果不同了。

## 装饰器的实际应用

装饰器在实际开发中有许多应用场景，以下是一些常见的例子：

### 1. 日志记录

```python
import logging
logging.basicConfig(level=logging.INFO)

def log_function_call(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        logging.info(f"调用函数: {func.__name__}")
        try:
            result = func(*args, **kwargs)
            logging.info(f"函数 {func.__name__} 执行成功")
            return result
        except Exception as e:
            logging.error(f"函数 {func.__name__} 执行出错: {e}")
            raise
    return wrapper

@log_function_call
def divide(a, b):
    return a / b

# 测试日志装饰器
try:
    print(divide(10, 2))  # 正常执行
    print(divide(10, 0))  # 引发异常
except ZeroDivisionError:
    pass
```

### 2. 缓存/记忆化

```python
def memoize(func):
    """缓存函数结果的装饰器"""
    cache = {}
    
    @functools.wraps(func)
    def wrapper(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    
    return wrapper

@memoize
def fibonacci(n):
    """计算斐波那契数列的第n个数"""
    if n < 2:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

# 测试缓存装饰器
import time
start = time.time()
print(fibonacci(35))
end = time.time()
print(f"计算用时: {end - start:.4f} 秒")  # 非常快，因为中间结果被缓存
```

### 3. 身份验证和授权

```python
def require_auth(func):
    """要求用户登录的装饰器"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        # 检查用户是否已登录
        if not is_authenticated():
            raise PermissionError("请先登录")
        return func(*args, **kwargs)
    return wrapper

def admin_only(func):
    """仅允许管理员访问的装饰器"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        # 检查用户是否是管理员
        if not is_admin():
            raise PermissionError("需要管理员权限")
        return func(*args, **kwargs)
    return wrapper

@require_auth
def view_profile():
    return "用户个人资料"

@require_auth
@admin_only
def admin_panel():
    return "管理员控制面板"
```

### 4. 输入验证

```python
def validate_types(**expected_types):
    """验证函数参数类型的装饰器"""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # 获取函数参数
            sig = inspect.signature(func)
            bound_args = sig.bind(*args, **kwargs)
            bound_args.apply_defaults()
            
            # 验证参数类型
            for param_name, param_value in bound_args.arguments.items():
                if param_name in expected_types:
                    expected_type = expected_types[param_name]
                    if not isinstance(param_value, expected_type):
                        raise TypeError(
                            f"参数 '{param_name}' 必须是 {expected_type.__name__} 类型, "
                            f"但提供的是 {type(param_value).__name__}"
                        )
            
            return func(*args, **kwargs)
        return wrapper
    return decorator

@validate_types(a=int, b=int)
def add(a, b):
    return a + b

try:
    print(add(1, 2))     # 正常执行
    print(add("1", 2))   # 引发类型错误
except TypeError as e:
    print(e)
```

### 5. 重试机制

```python
def retry(max_attempts=3, delay=1):
    """自动重试失败操作的装饰器"""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            attempts = 0
            while attempts < max_attempts:
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    attempts += 1
                    if attempts == max_attempts:
                        raise
                    print(f"尝试失败 ({attempts}/{max_attempts}): {e}")
                    print(f"等待 {delay} 秒后重试...")
                    time.sleep(delay)
            return None  # 不会执行到这里，因为最后一次失败会抛出异常
        return wrapper
    return decorator

@retry(max_attempts=3, delay=0.5)
def unstable_network_call():
    """模拟不稳定的网络调用"""
    import random
    if random.random() < 0.7:  # 70%的概率失败
        raise ConnectionError("网络连接失败")
    return "数据获取成功"

try:
    result = unstable_network_call()
    print(result)
except ConnectionError:
    print("最终失败，无法连接")
```

## 装饰器的高级用法

### 1. 装饰器工厂

装饰器工厂是一个返回装饰器的函数，可以根据需要生成不同的装饰器：

```python
def create_formatter(format_type):
    """创建不同类型的格式化装饰器"""
    def formatter(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            result = func(*args, **kwargs)
            if format_type == "upper":
                return result.upper()
            elif format_type == "lower":
                return result.lower()
            elif format_type == "title":
                return result.title()
            else:
                return result
        return wrapper
    return formatter

# 使用装饰器工厂
@create_formatter("upper")
def greet1(name):
    return f"Hello, {name}!"

@create_formatter("lower")
def greet2(name):
    return f"Hello, {name}!"

@create_formatter("title")
def greet3(name):
    return f"hello, {name}!"

print(greet1("World"))  # 输出: HELLO, WORLD!
print(greet2("World"))  # 输出: hello, world!
print(greet3("world"))  # 输出: Hello, World!
```

### 2. 保留装饰器状态

有时需要在装饰器之间共享状态，或者在装饰器外部访问装饰器的状态：

```python
def stateful_decorator(func):
    """一个保存状态的装饰器"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        wrapper.calls += 1
        return func(*args, **kwargs)
    
    # 初始化状态
    wrapper.calls = 0
    return wrapper

@stateful_decorator
def hello():
    return "Hello!"

# 调用函数
for _ in range(5):
    hello()

# 访问装饰器状态
print(f"函数hello被调用了 {hello.calls} 次")  # 输出: 函数hello被调用了 5 次
```

### 3. 为被装饰函数添加属性

装饰器可以为被装饰的函数添加新的属性和方法：

```python
def add_metadata(author, date):
    """为函数添加元数据的装饰器"""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        
        # 添加元数据
        wrapper.author = author
        wrapper.date = date
        wrapper.get_metadata = lambda: f"作者: {author}, 日期: {date}"
        
        return wrapper
    return decorator

@add_metadata("Alice", "2023-01-15")
def process_data():
    return "数据处理完成"

# 访问添加的属性和方法
print(process_data())  # 输出: 数据处理完成
print(process_data.author)  # 输出: Alice
print(process_data.date)  # 输出: 2023-01-15
print(process_data.get_metadata())  # 输出: 作者: Alice, 日期: 2023-01-15
```

## 装饰器的注意事项

### 1. 性能开销

装饰器会引入额外的函数调用，可能导致性能开销。对于频繁调用的小函数，这种开销可能会显著影响性能：

```python
import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"函数 {func.__name__} 执行时间: {end - start:.8f} 秒")
        return result
    return wrapper

@timer
def fast_function():
    return 42

# 测试装饰器开销
start = time.time()
for _ in range(1000000):
    fast_function()
end = time.time()
print(f"总执行时间: {end - start:.4f} 秒")
```

### 2. 调试困难

装饰器可能使代码调试变得复杂，因为它改变了函数的行为和调用栈：

```python
def debug(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        args_repr = [repr(a) for a in args]
        kwargs_repr = [f"{k}={v!r}" for k, v in kwargs.items()]
        signature = ", ".join(args_repr + kwargs_repr)
        print(f"调用 {func.__name__}({signature})")
        result = func(*args, **kwargs)
        print(f"{func.__name__} 返回 {result!r}")
        return result
    return wrapper

@debug
def add(a, b):
    return a + b

add(3, 4)  # 输出详细的调试信息
```

### 3. 副作用

装饰器可能引入意外的副作用，特别是当多个装饰器交互时：

```python
def add_prefix(prefix):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            return prefix + func(*args, **kwargs)
        return wrapper
    return decorator

def add_suffix(suffix):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs) + suffix
        return wrapper
    return decorator

@add_prefix("Hello, ")
@add_suffix("!")
def get_name():
    return "World"

print(get_name())  # 输出: Hello, World!

# 改变装饰器顺序可能导致不同的结果
@add_suffix("!")
@add_prefix("Hello, ")
def get_name2():
    return "World"

print(get_name2())  # 输出: Hello, World!
# 注意：在这个例子中结果相同，但在其他情况下可能会有差异
```

## 内置装饰器

Python提供了几个内置的装饰器，用于特定场景：

### 1. @property

将方法转换为属性：

```python
class Circle:
    def __init__(self, radius):
        self._radius = radius
    
    @property
    def radius(self):
        """获取半径"""
        return self._radius
    
    @radius.setter
    def radius(self, value):
        """设置半径，确保值为正数"""
        if value <= 0:
            raise ValueError("半径必须为正数")
        self._radius = value
    
    @property
    def area(self):
        """计算圆的面积"""
        return 3.14159 * self._radius * self._radius

# 使用属性
circle = Circle(5)
print(circle.radius)  # 5
print(circle.area)    # 78.53975

circle.radius = 10
print(circle.radius)  # 10
print(circle.area)    # 314.159

try:
    circle.radius = -5  # 抛出ValueError
except ValueError as e:
    print(e)
```

### 2. @classmethod

定义类方法，接收类作为第一个参数：

```python
class Person:
    count = 0
    
    def __init__(self, name, age):
        self.name = name
        self.age = age
        Person.count += 1
    
    @classmethod
    def create_from_birth_year(cls, name, birth_year):
        """从出生年份创建Person实例"""
        age = 2023 - birth_year
        return cls(name, age)
    
    @classmethod
    def get_count(cls):
        """获取创建的Person实例数量"""
        return cls.count

# 使用类方法
person1 = Person("Alice", 30)
person2 = Person.create_from_birth_year("Bob", 1990)

print(person2.name)  # Bob
print(person2.age)   # 33 (假设当前是2023年)
print(Person.get_count())  # 2
```

### 3. @staticmethod

定义静态方法，不接收特殊的第一个参数：

```python
class MathUtils:
    @staticmethod
    def is_prime(n):
        """检查一个数是否为素数"""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True
    
    @staticmethod
    def gcd(a, b):
        """计算最大公约数"""
        while b:
            a, b = b, a % b
        return a

# 使用静态方法
print(MathUtils.is_prime(17))  # True
print(MathUtils.gcd(48, 18))   # 6
```

## 总结

装饰器是Python中一个强大而灵活的特性，它允许开发者以非侵入式的方式扩展和修改函数和类的行为。主要优点包括：

1. **代码重用**：装饰器封装了通用功能，可以应用于多个函数
2. **关注点分离**：核心逻辑和辅助功能（如日志、验证）分离
3. **干净的实现**：不修改原函数的代码就能增强其功能
4. **可读性**：使代码更加简洁和声明式

通过本文，我们学习了装饰器的基本概念、语法、工作原理以及常见的应用场景。装饰器是Python中的一个高级特性，掌握它可以大大提高代码的质量和开发效率。
