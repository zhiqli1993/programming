# Python正则表达式基础

正则表达式是一种强大的文本处理工具，用于模式匹配、搜索和替换字符串中的文本。Python通过`re`模块提供了对正则表达式的全面支持。本文详细介绍Python正则表达式的基础知识和应用。

## 正则表达式简介

正则表达式(Regular Expression，简称regex)是一种用于描述字符串模式的特殊字符序列，可以用来：

- 检查字符串是否包含特定模式
- 从字符串中提取匹配的部分
- 替换字符串中的匹配内容
- 分割字符串

## Python的re模块

Python的`re`模块提供了对正则表达式的支持。使用前需要先导入：

```python
import re
```

### re模块的主要函数

| 函数 | 描述 |
|------|------|
| `re.search(pattern, string)` | 在字符串中查找匹配的模式，返回第一个匹配对象或None |
| `re.match(pattern, string)` | 在字符串开头查找匹配的模式，返回匹配对象或None |
| `re.findall(pattern, string)` | 查找所有匹配的模式，返回匹配的字符串列表 |
| `re.finditer(pattern, string)` | 查找所有匹配的模式，返回迭代器 |
| `re.sub(pattern, repl, string)` | 用替换字符串替换所有匹配的模式 |
| `re.split(pattern, string)` | 根据模式分割字符串 |
| `re.compile(pattern)` | 编译正则表达式模式，返回正则表达式对象 |

## 基本模式匹配

### 字面字符匹配

最简单的模式是直接匹配字符：

```python
import re

text = "Hello, Python!"
result = re.search("Python", text)
print(result)  # <re.Match object; span=(7, 13), match='Python'>
```

### 特殊字符和元字符

正则表达式使用特殊字符（元字符）来表示特定的模式：

| 元字符 | 描述 |
|-------|------|
| `.` | 匹配除换行符外的任何单个字符 |
| `^` | 匹配字符串的开始 |
| `$` | 匹配字符串的结束 |
| `*` | 匹配前一个字符0次或多次 |
| `+` | 匹配前一个字符1次或多次 |
| `?` | 匹配前一个字符0次或1次 |
| `{m}` | 匹配前一个字符恰好m次 |
| `{m,n}` | 匹配前一个字符m到n次 |
| `\` | 转义字符 |
| `[]` | 字符集，匹配括号内的任一字符 |
| `\|` | 或，匹配左或右侧的表达式 |
| `()` | 分组，捕获匹配的子表达式 |

#### 示例

```python
import re

# .（点）匹配任何单个字符
print(re.search("h.t", "hat"))     # <re.Match object; span=(0, 3), match='hat'>
print(re.search("h.t", "hot"))     # <re.Match object; span=(0, 3), match='hot'>
print(re.search("h.t", "h t"))     # <re.Match object; span=(0, 3), match='h t'>
print(re.search("h.t", "hit"))     # <re.Match object; span=(0, 3), match='hit'>

# ^ 匹配字符串的开始
print(re.search("^Python", "Python is great"))  # <re.Match object; span=(0, 6), match='Python'>
print(re.search("^great", "Python is great"))   # None

# $ 匹配字符串的结束
print(re.search("great$", "Python is great"))  # <re.Match object; span=(10, 15), match='great'>
print(re.search("Python$", "Python is great")) # None

# * 匹配前一个字符0次或多次
print(re.search("ab*c", "ac"))       # <re.Match object; span=(0, 2), match='ac'>
print(re.search("ab*c", "abc"))      # <re.Match object; span=(0, 3), match='abc'>
print(re.search("ab*c", "abbc"))     # <re.Match object; span=(0, 4), match='abbc'>
print(re.search("ab*c", "abbbc"))    # <re.Match object; span=(0, 5), match='abbbc'>

# + 匹配前一个字符1次或多次
print(re.search("ab+c", "ac"))       # None
print(re.search("ab+c", "abc"))      # <re.Match object; span=(0, 3), match='abc'>
print(re.search("ab+c", "abbc"))     # <re.Match object; span=(0, 4), match='abbc'>
```

## 字符类和特殊序列

### 字符类

字符类用方括号`[]`表示，匹配括号中的任一字符：

```python
import re

# 匹配a或b或c
print(re.search("[abc]", "a"))    # <re.Match object; span=(0, 1), match='a'>
print(re.search("[abc]", "b"))    # <re.Match object; span=(0, 1), match='b'>
print(re.search("[abc]", "d"))    # None

# 范围匹配
print(re.search("[a-z]", "g"))    # <re.Match object; span=(0, 1), match='g'>
print(re.search("[0-9]", "5"))    # <re.Match object; span=(0, 1), match='5'>

# 组合范围
print(re.search("[a-zA-Z0-9]", "X"))  # <re.Match object; span=(0, 1), match='X'>

# 否定字符类
print(re.search("[^0-9]", "a"))   # <re.Match object; span=(0, 1), match='a'>
print(re.search("[^0-9]", "5"))   # None
```

### 常用特殊序列

Python的`re`模块提供了一些特殊序列来表示常见的字符集：

| 特殊序列 | 描述 |
|---------|------|
| `\d` | 匹配任何十进制数字，等价于`[0-9]` |
| `\D` | 匹配任何非数字字符，等价于`[^0-9]` |
| `\s` | 匹配任何空白字符，等价于`[ \t\n\r\f\v]` |
| `\S` | 匹配任何非空白字符，等价于`[^ \t\n\r\f\v]` |
| `\w` | 匹配任何字母数字字符，等价于`[a-zA-Z0-9_]` |
| `\W` | 匹配任何非字母数字字符，等价于`[^a-zA-Z0-9_]` |
| `\b` | 匹配单词边界 |
| `\B` | 匹配非单词边界 |

#### 示例

```python
import re

# \d 匹配数字
print(re.findall(r"\d", "Phone: 123-456-7890"))  # ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0']

# \D 匹配非数字
print(re.findall(r"\D", "Phone: 123-456-7890"))  # ['P', 'h', 'o', 'n', 'e', ':', ' ', '-', '-']

# \s 匹配空白字符
print(re.findall(r"\s", "Hello World"))  # [' ']

# \w 匹配字母数字字符
print(re.findall(r"\w", "Hello, World!"))  # ['H', 'e', 'l', 'l', 'o', 'W', 'o', 'r', 'l', 'd']

# \b 匹配单词边界
print(re.findall(r"\bworld\b", "Hello world!"))  # ['world']
print(re.findall(r"\bworld\b", "Hello worldwide!"))  # []
```

## 重复限定符

重复限定符用于指定前一个字符或组可以重复的次数：

| 限定符 | 描述 |
|-------|------|
| `*` | 匹配前一个字符0次或多次 |
| `+` | 匹配前一个字符1次或多次 |
| `?` | 匹配前一个字符0次或1次 |
| `{m}` | 匹配前一个字符恰好m次 |
| `{m,n}` | 匹配前一个字符至少m次，最多n次 |
| `{m,}` | 匹配前一个字符至少m次 |
| `{,n}` | 匹配前一个字符最多n次 |

```python
import re

# * 重复0次或多次
print(re.search(r"ab*c", "ac"))    # <re.Match object; span=(0, 2), match='ac'>
print(re.search(r"ab*c", "abbbc"))  # <re.Match object; span=(0, 5), match='abbbc'>

# + 重复1次或多次
print(re.search(r"ab+c", "ac"))    # None
print(re.search(r"ab+c", "abc"))   # <re.Match object; span=(0, 3), match='abc'>

# ? 重复0次或1次
print(re.search(r"ab?c", "ac"))    # <re.Match object; span=(0, 2), match='ac'>
print(re.search(r"ab?c", "abc"))   # <re.Match object; span=(0, 3), match='abc'>
print(re.search(r"ab?c", "abbc"))  # None

# {m} 重复恰好m次
print(re.search(r"a{3}b", "aaab"))  # <re.Match object; span=(0, 4), match='aaab'>
print(re.search(r"a{3}b", "aab"))   # None

# {m,n} 重复至少m次，最多n次
print(re.search(r"a{2,4}b", "aab"))   # <re.Match object; span=(0, 3), match='aab'>
print(re.search(r"a{2,4}b", "aaab"))  # <re.Match object; span=(0, 4), match='aaab'>
print(re.search(r"a{2,4}b", "aaaab"))  # <re.Match object; span=(0, 5), match='aaaab'>
print(re.search(r"a{2,4}b", "aaaaab"))  # None
```

### 贪婪和非贪婪重复

正则表达式的重复限定符默认是贪婪的(匹配尽可能多的字符)。可以添加`?`后缀使其变为非贪婪模式(匹配尽可能少的字符)：

```python
import re

text = "<h1>Title</h1>"

# 贪婪匹配
print(re.search(r"<.*>", text).group())  # <h1>Title</h1>

# 非贪婪匹配
print(re.search(r"<.*?>", text).group())  # <h1>
```

## 分组和捕获

正则表达式中的圆括号`()`用于分组和捕获匹配的文本：

```python
import re

# 基本分组
text = "John Smith"
match = re.search(r"(\w+) (\w+)", text)
if match:
    print(match.group())   # John Smith (整个匹配)
    print(match.group(1))  # John (第一个组)
    print(match.group(2))  # Smith (第二个组)
    print(match.groups())  # ('John', 'Smith') (所有组的元组)
```

### 命名分组

可以给分组命名，便于后续引用：

```python
import re

text = "John Smith"
match = re.search(r"(?P<first>\w+) (?P<last>\w+)", text)
if match:
    print(match.group("first"))  # John
    print(match.group("last"))   # Smith
    print(match.groupdict())     # {'first': 'John', 'last': 'Smith'}
```

### 非捕获分组

如果只需要分组而不需要捕获，可以使用非捕获分组`(?:...)`：

```python
import re

text = "John Smith"
match = re.search(r"(?:\w+) (\w+)", text)
if match:
    print(match.group(1))  # Smith (只有一个捕获组)
    print(match.groups())  # ('Smith',)
```

## 替换和分割

### 替换文本

`re.sub()`函数用于替换匹配的文本：

```python
import re

# 基本替换
text = "Hello, world!"
new_text = re.sub(r"world", "Python", text)
print(new_text)  # Hello, Python!

# 使用分组引用
text = "John Smith"
new_text = re.sub(r"(\w+) (\w+)", r"\2, \1", text)
print(new_text)  # Smith, John

# 使用命名分组引用
text = "John Smith"
new_text = re.sub(r"(?P<first>\w+) (?P<last>\w+)", r"\g<last>, \g<first>", text)
print(new_text)  # Smith, John
```

### 分割字符串

`re.split()`函数用于根据正则表达式分割字符串：

```python
import re

# 基本分割
text = "apple,banana;cherry:date"
print(re.split(r"[,;:]", text))  # ['apple', 'banana', 'cherry', 'date']

# 保留分隔符
text = "apple,banana;cherry:date"
print(re.split(r"([,;:])", text))  # ['apple', ',', 'banana', ';', 'cherry', ':', 'date']

# 限制分割次数
text = "apple,banana,cherry,date"
print(re.split(r",", text, 2))  # ['apple', 'banana', 'cherry,date']
```

## 正则表达式编译

对于频繁使用的正则表达式，最好使用`re.compile()`预编译模式以提高性能：

```python
import re

# 编译正则表达式
pattern = re.compile(r"\b\w+\b")

# 使用编译后的正则表达式
text = "Hello, world! This is a test."
words = pattern.findall(text)
print(words)  # ['Hello', 'world', 'This', 'is', 'a', 'test']

# 查找迭代器
for match in pattern.finditer(text):
    print(f"Found '{match.group()}' at position {match.start()}-{match.end()}")
```

### 正则表达式标志

编译正则表达式时可以指定不同的标志以改变匹配行为：

| 标志 | 描述 |
|------|------|
| `re.IGNORECASE` 或 `re.I` | 忽略大小写 |
| `re.MULTILINE` 或 `re.M` | 使^和$匹配每行的开始和结束 |
| `re.DOTALL` 或 `re.S` | 使.也匹配换行符 |
| `re.VERBOSE` 或 `re.X` | 允许添加注释和空白以增强可读性 |
| `re.ASCII` 或 `re.A` | 使\w, \W, \b, \B, \d, \D, \s, \S只匹配ASCII字符 |
| `re.UNICODE` 或 `re.U` | 使模式字符串被当作Unicode码点处理 |

```python
import re

# 忽略大小写
pattern = re.compile(r"python", re.IGNORECASE)
print(pattern.search("Python"))  # <re.Match object; span=(0, 6), match='Python'>

# 多行模式
text = """First line
Second line
Third line"""
pattern = re.compile(r"^.*line$", re.MULTILINE)
print(pattern.findall(text))  # ['First line', 'Second line', 'Third line']

# DOTALL模式
text = "Line 1\nLine 2"
pattern = re.compile(r"Line.*Line", re.DOTALL)
print(pattern.search(text).group())  # Line 1\nLine 2

# VERBOSE模式
pattern = re.compile(r"""
    \b          # 单词边界
    (\d{3})     # 区号
    [-.]?       # 可选的分隔符
    (\d{3})     # 前三位
    [-.]?       # 可选的分隔符
    (\d{4})     # 后四位
    \b          # 单词边界
""", re.VERBOSE)
print(pattern.search("Phone: 123-456-7890").groups())  # ('123', '456', '7890')
```

## 匹配对象方法

`re.search()`, `re.match()`等函数返回的匹配对象包含有关匹配的信息：

```python
import re

text = "Python was created in 1991"
match = re.search(r"Python (\w+) created in (\d+)", text)

if match:
    # 获取整个匹配的字符串
    print(match.group())  # Python was created in 1991
    
    # 获取特定分组
    print(match.group(1))  # was
    print(match.group(2))  # 1991
    
    # 获取所有分组
    print(match.groups())  # ('was', '1991')
    
    # 获取匹配的开始和结束位置
    print(match.start())   # 0
    print(match.end())     # 26
    print(match.span())    # (0, 26)
    
    # 获取原始字符串
    print(match.string)    # Python was created in 1991
```

## 常见正则表达式模式

以下是一些常见的正则表达式模式示例：

### 验证电子邮件地址

```python
import re

email_pattern = re.compile(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$")

# 测试
emails = ["user@example.com", "invalid@email", "name.lastname@domain.co.uk", "@example.com"]
for email in emails:
    if email_pattern.match(email):
        print(f"{email} is valid")
    else:
        print(f"{email} is invalid")
```

### 验证URL

```python
import re

url_pattern = re.compile(
    r"https?://"          # http:// 或 https://
    r"(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+[A-Z]{2,6}\.?|" # 域名
    r"localhost|"          # localhost
    r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})" # IP地址
    r"(?::\d+)?"           # 可选端口
    r"(?:/?|[/?]\S+)$",    # 路径
    re.IGNORECASE
)

# 测试
urls = ["http://www.example.com", "https://example.co.uk/path?name=value", 
        "http://localhost:8080", "ftp://invalid.com"]
for url in urls:
    if url_pattern.match(url):
        print(f"{url} is valid")
    else:
        print(f"{url} is invalid")
```

### 提取日期

```python
import re

# 匹配形如 YYYY-MM-DD 的日期
date_pattern = re.compile(r"(\d{4})-(\d{2})-(\d{2})")

text = "The event will be held on 2023-05-15 and end on 2023-05-17."
dates = date_pattern.findall(text)
print(dates)  # [('2023', '05', '15'), ('2023', '05', '17')]

# 使用命名分组
date_pattern_named = re.compile(r"(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2})")
for match in date_pattern_named.finditer(text):
    print(f"Year: {match.group('year')}, Month: {match.group('month')}, Day: {match.group('day')}")
```

### 验证密码强度

```python
import re

def check_password_strength(password):
    # 至少8个字符，包含大小写字母、数字和特殊字符
    patterns = [
        (r'.{8,}', "至少8个字符"),
        (r'[A-Z]', "至少一个大写字母"),
        (r'[a-z]', "至少一个小写字母"),
        (r'[0-9]', "至少一个数字"),
        (r'[^A-Za-z0-9]', "至少一个特殊字符")
    ]
    
    passed = True
    feedback = []
    
    for pattern, message in patterns:
        if not re.search(pattern, password):
            passed = False
            feedback.append(message)
    
    return passed, feedback

# 测试
passwords = ["weak", "Stronger1", "Str0ng3r!", "Passw0rd"]
for password in passwords:
    is_strong, feedback = check_password_strength(password)
    if is_strong:
        print(f"'{password}' 是一个强密码")
    else:
        print(f"'{password}' 不够强: {', '.join(feedback)}")
```

## 正则表达式最佳实践

### 性能考虑

1. **预编译正则表达式**：对于重复使用的模式，使用`re.compile()`
2. **避免过度使用贪婪量词**：如`.*`可能导致回溯，影响性能
3. **使用非捕获组**：如果不需要捕获内容，使用`(?:...)`而不是`(...)`
4. **精确指定匹配范围**：使用字符类`[...]`限制匹配范围，而不是使用通配符

### 可读性和可维护性

1. **使用VERBOSE模式**：对于复杂的正则表达式，使用`re.VERBOSE`并添加注释
2. **使用命名分组**：使用`(?P<name>...)`而不是数字索引，提高可读性
3. **分解复杂表达式**：将复杂的正则表达式分解为多个简单的表达式
4. **编写测试用例**：为正则表达式编写测试，确保它们按预期工作

## 总结

正则表达式是处理文本的强大工具，Python的`re`模块提供了全面的正则表达式支持。通过掌握正则表达式的基本语法和模式，可以高效地执行文本搜索、提取、替换和验证等操作。

虽然正则表达式语法看起来复杂，但通过分解和实践，可以逐步掌握这一重要的编程技能。合理使用正则表达式可以显著简化文本处理任务，提高代码的效率和可读性。
