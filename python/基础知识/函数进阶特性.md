# Python函数进阶特性

Python函数不仅仅是简单的代码封装，它还具有许多强大的特性，使得Python成为一种灵活而强大的编程语言。本文详细介绍Python函数的进阶特性，包括函数参数、闭包、高阶函数等概念。

## 函数参数高级用法

### 参数类型回顾

Python函数支持多种参数类型：

1. **位置参数**：按位置传递的参数
2. **关键字参数**：按名称传递的参数
3. **默认参数**：定义时指定默认值的参数
4. **可变位置参数**：接收任意数量位置参数的参数（`*args`）
5. **可变关键字参数**：接收任意数量关键字参数的参数（`**kwargs`）

### 位置参数和关键字参数

```python
def greet(name, message):
    return f"{message}, {name}!"

# 位置参数
print(greet("Alice", "Hello"))  # Hello, Alice!

# 关键字参数
print(greet(message="Hi", name="Bob"))  # Hi, Bob!

# 混合使用
print(greet("Charlie", message="Hey"))  # Hey, Charlie!
```

### 默认参数

```python
def greet(name, message="Hello"):
    return f"{message}, {name}!"

print(greet("Alice"))  # Hello, Alice!
print(greet("Bob", "Hi"))  # Hi, Bob!
```

**注意**：默认参数值只在函数定义时计算一次，对于可变类型的默认值要特别小心：

```python
# 错误的做法
def add_item(item, items=[]):
    items.append(item)
    return items

print(add_item("apple"))  # ['apple']
print(add_item("banana"))  # ['apple', 'banana'] - 不是预期的['banana']

# 正确的做法
def add_item_correct(item, items=None):
    if items is None:
        items = []
    items.append(item)
    return items

print(add_item_correct("apple"))  # ['apple']
print(add_item_correct("banana"))  # ['banana']
```

### 可变位置参数（*args）

`*args`参数允许函数接收任意数量的位置参数：

```python
def sum_all(*numbers):
    return sum(numbers)

print(sum_all(1, 2, 3))  # 6
print(sum_all(1, 2, 3, 4, 5))  # 15
```

### 可变关键字参数（**kwargs）

`**kwargs`参数允许函数接收任意数量的关键字参数：

```python
def print_person_info(**info):
    for key, value in info.items():
        print(f"{key}: {value}")

print_person_info(name="Alice", age=30, job="Engineer")
# 输出:
# name: Alice
# age: 30
# job: Engineer
```

### 组合使用不同类型的参数

当组合使用不同类型的参数时，参数顺序必须是：
1. 位置参数
2. `*args`
3. 关键字参数
4. `**kwargs`

```python
def complex_function(a, b, *args, c=10, d=20, **kwargs):
    print(f"a: {a}, b: {b}")
    print(f"args: {args}")
    print(f"c: {c}, d: {d}")
    print(f"kwargs: {kwargs}")

complex_function(1, 2, 3, 4, 5, c=30, e="hello", f="world")
# 输出:
# a: 1, b: 2
# args: (3, 4, 5)
# c: 30, d: 20
# kwargs: {'e': 'hello', 'f': 'world'}
```

### 仅位置参数和仅关键字参数

Python 3.8引入了更明确的参数语法：

```python
def func(a, b, /, c, d, *, e, f):
    print(a, b, c, d, e, f)
```

在这个函数中：
- `a`和`b`是仅位置参数（在`/`前）
- `c`和`d`是位置或关键字参数
- `e`和`f`是仅关键字参数（在`*`后）

```python
# 正确调用
func(1, 2, 3, d=4, e=5, f=6)
func(1, 2, c=3, d=4, e=5, f=6)

# 错误调用
# func(a=1, b=2, c=3, d=4, e=5, f=6)  # a和b不能作为关键字参数
# func(1, 2, 3, 4, 5, 6)  # e和f必须作为关键字参数
```

### 解包参数

使用`*`和`**`运算符可以解包序列和字典：

```python
def add(a, b, c):
    return a + b + c

numbers = [1, 2, 3]
print(add(*numbers))  # 6

params = {"a": 1, "b": 2, "c": 3}
print(add(**params))  # 6
```

## 闭包（Closure）

闭包是一个函数，它记住了创建它的环境中的变量，即使这些变量在外部函数执行完后不再可用。

### 基本闭包

```python
def outer_function(x):
    # 外部函数的变量
    def inner_function(y):
        # 内部函数可以访问外部函数的变量
        return x + y
    return inner_function

# 创建闭包
add_five = outer_function(5)
print(add_five(3))  # 8
print(add_five(7))  # 12
```

### 闭包的用途

闭包常用于：
1. 数据隐藏和封装
2. 实现装饰器
3. 回调函数
4. 状态保持

### 使用闭包实现计数器

```python
def create_counter(start=0):
    count = [start]  # 使用可变对象存储状态
    
    def increment(step=1):
        count[0] += step
        return count[0]
    
    def decrement(step=1):
        count[0] -= step
        return count[0]
    
    def get_count():
        return count[0]
    
    return increment, decrement, get_count

# 创建计数器
inc, dec, get = create_counter(10)
print(get())  # 10
print(inc(5))  # 15
print(dec(3))  # 12
print(get())  # 12
```

### nonlocal关键字

在闭包中修改外部函数的变量时，需要使用`nonlocal`关键字：

```python
def create_counter(start=0):
    count = start  # 不可变对象
    
    def increment(step=1):
        nonlocal count  # 声明count为非局部变量
        count += step
        return count
    
    return increment

counter = create_counter(5)
print(counter())  # 6
print(counter())  # 7
```

## 高阶函数

高阶函数是接受一个或多个函数作为参数，或者返回一个函数的函数。

### 函数作为参数

```python
def apply_function(func, value):
    return func(value)

def square(x):
    return x * x

def cube(x):
    return x * x * x

print(apply_function(square, 5))  # 25
print(apply_function(cube, 3))    # 27
```

### 返回函数

```python
def get_operation(operation_type):
    def add(x, y):
        return x + y
    
    def multiply(x, y):
        return x * y
    
    if operation_type == "add":
        return add
    elif operation_type == "multiply":
        return multiply
    else:
        raise ValueError("Unsupported operation")

# 获取并使用函数
add_func = get_operation("add")
print(add_func(5, 3))  # 8

multiply_func = get_operation("multiply")
print(multiply_func(5, 3))  # 15
```

### 内置高阶函数

Python提供了几个常用的内置高阶函数：

#### map()

`map()`函数将一个函数应用到一个可迭代对象的所有元素上：

```python
numbers = [1, 2, 3, 4, 5]
squares = list(map(lambda x: x**2, numbers))
print(squares)  # [1, 4, 9, 16, 25]

# 等效的列表推导式
squares_lc = [x**2 for x in numbers]
print(squares_lc)  # [1, 4, 9, 16, 25]
```

#### filter()

`filter()`函数根据一个函数的返回值（True或False）过滤可迭代对象的元素：

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)  # [2, 4, 6, 8, 10]

# 等效的列表推导式
even_numbers_lc = [x for x in numbers if x % 2 == 0]
print(even_numbers_lc)  # [2, 4, 6, 8, 10]
```

#### reduce()

`reduce()`函数通过一个二元函数连续地将可迭代对象的元素减少为单个值：

```python
from functools import reduce

numbers = [1, 2, 3, 4, 5]
product = reduce(lambda x, y: x * y, numbers)
print(product)  # 120 (1*2*3*4*5)

# 使用初始值
sum_with_initial = reduce(lambda x, y: x + y, numbers, 10)
print(sum_with_initial)  # 25 (10+1+2+3+4+5)
```

#### sorted()

`sorted()`函数根据一个关键函数对可迭代对象进行排序：

```python
students = [
    {"name": "Alice", "grade": 85},
    {"name": "Bob", "grade": 92},
    {"name": "Charlie", "grade": 78}
]

# 按照grade排序
sorted_by_grade = sorted(students, key=lambda s: s["grade"])
print([s["name"] for s in sorted_by_grade])  # ['Charlie', 'Alice', 'Bob']

# 按照name排序
sorted_by_name = sorted(students, key=lambda s: s["name"])
print([s["name"] for s in sorted_by_name])  # ['Alice', 'Bob', 'Charlie']

# 降序排序
sorted_desc = sorted(students, key=lambda s: s["grade"], reverse=True)
print([s["name"] for s in sorted_desc])  # ['Bob', 'Alice', 'Charlie']
```

## 函数式编程工具

### partial()

`partial()`函数用于创建一个新函数，固定原函数的部分参数：

```python
from functools import partial

def power(base, exponent):
    return base ** exponent

# 创建一个计算平方的函数
square = partial(power, exponent=2)
print(square(5))  # 25

# 创建一个计算立方的函数
cube = partial(power, exponent=3)
print(cube(5))  # 125

# 创建一个计算2的幂的函数
powers_of_two = partial(power, base=2)
print(powers_of_two(10))  # 1024
```

### lru_cache()

`lru_cache()`装饰器用于缓存函数的返回值，避免重复计算：

```python
from functools import lru_cache
import time

# 没有缓存的函数
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# 有缓存的函数
@lru_cache(maxsize=None)
def fibonacci_cached(n):
    if n <= 1:
        return n
    return fibonacci_cached(n-1) + fibonacci_cached(n-2)

# 测试性能
def measure_time(func, n):
    start = time.time()
    result = func(n)
    end = time.time()
    print(f"{func.__name__}({n}) = {result}, 用时: {end - start:.6f}秒")

# 较小的输入，两者差别不大
measure_time(fibonacci, 20)
measure_time(fibonacci_cached, 20)

# 较大的输入，有缓存的函数明显更快
# measure_time(fibonacci, 35)  # 会非常慢
measure_time(fibonacci_cached, 35)
```

### 函数式编程的优势

函数式编程的主要优势：
1. **简洁性**：减少样板代码
2. **可读性**：表达意图而非实现细节
3. **可测试性**：纯函数易于测试
4. **并行性**：无副作用的函数易于并行化

## 匿名函数（lambda）

lambda表达式是创建小型匿名函数的方式：

```python
# 普通函数
def add(x, y):
    return x + y

# 等效的lambda函数
add_lambda = lambda x, y: x + y

print(add(5, 3))        # 8
print(add_lambda(5, 3))  # 8
```

### lambda的使用场景

lambda函数最常用于需要一个简短函数的场合：

```python
# 排序
pairs = [(1, 'one'), (2, 'two'), (3, 'three')]
pairs.sort(key=lambda pair: pair[1])
print(pairs)  # [(1, 'one'), (3, 'three'), (2, 'two')]

# 过滤
numbers = list(range(10))
even = list(filter(lambda x: x % 2 == 0, numbers))
print(even)  # [0, 2, 4, 6, 8]

# 映射
squares = list(map(lambda x: x**2, numbers))
print(squares)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

### lambda的限制

lambda表达式只能包含一个表达式，不能包含语句：

```python
# 不能在lambda中使用if语句
# wrong_lambda = lambda x: if x > 0: x else -x

# 但可以使用条件表达式
abs_lambda = lambda x: x if x > 0 else -x
print(abs_lambda(-5))  # 5
```

## 递归函数

递归函数是调用自身的函数：

```python
def factorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * factorial(n-1)

print(factorial(5))  # 120
```

### 尾递归优化

尾递归是一种特殊形式的递归，函数的最后一个操作是调用自身：

```python
def factorial_tail(n, accumulator=1):
    if n == 0 or n == 1:
        return accumulator
    else:
        return factorial_tail(n-1, n * accumulator)

print(factorial_tail(5))  # 120
```

**注意**：Python不会自动进行尾递归优化，因此深度递归仍然可能导致栈溢出。

### 递归的优缺点

优点：
1. 简洁，易于理解复杂问题
2. 自然匹配分治算法

缺点：
1. 可能导致栈溢出
2. 性能开销较大

## 函数注解

函数注解是Python 3引入的特性，用于为函数的参数和返回值提供类型提示：

```python
def add(a: int, b: int) -> int:
    return a + b

# 查看函数注解
print(add.__annotations__)  # {'a': <class 'int'>, 'b': <class 'int'>, 'return': <class 'int'>}
```

### 更复杂的类型注解

使用`typing`模块可以提供更复杂的类型注解：

```python
from typing import List, Dict, Tuple, Optional, Union, Callable

def process_data(items: List[int], 
                 config: Dict[str, str], 
                 callback: Callable[[int], int] = None) -> Tuple[int, int]:
    """处理数据并返回结果。"""
    total = sum(items)
    processed = [callback(item) if callback else item for item in items]
    return total, sum(processed)

def get_user(user_id: int) -> Optional[Dict[str, Union[str, int]]]:
    """获取用户信息，如果用户不存在则返回None。"""
    users = {1: {"name": "Alice", "age": 30}}
    return users.get(user_id)
```

### 注解的用途

函数注解主要用于：
1. 代码文档
2. IDE支持（代码补全、错误检测）
3. 静态类型检查器（如mypy）
4. 运行时类型检查

**注意**：Python的类型注解是可选的，解释器不强制执行类型检查。

## 函数的属性

函数在Python中是一等公民，可以拥有属性：

```python
def greet(name):
    """返回问候语。"""
    return f"Hello, {name}!"

# 添加自定义属性
greet.author = "Alice"
greet.version = "1.0"

# 访问函数属性
print(greet.author)    # Alice
print(greet.version)   # 1.0
print(greet.__doc__)   # 返回问候语。
print(greet.__name__)  # greet
```

### 使用函数属性进行缓存

```python
def fibonacci(n):
    """计算斐波那契数列的第n个数。"""
    # 初始化缓存
    if not hasattr(fibonacci, "cache"):
        fibonacci.cache = {0: 0, 1: 1}
    
    # 检查缓存
    if n in fibonacci.cache:
        return fibonacci.cache[n]
    
    # 计算并缓存结果
    result = fibonacci(n-1) + fibonacci(n-2)
    fibonacci.cache[n] = result
    return result

print(fibonacci(10))  # 55
print(fibonacci(20))  # 6765
print(len(fibonacci.cache))  # 21 (0到20的所有结果都被缓存)
```

## 内置装饰器

### @property

`@property`装饰器用于将方法转换为属性：

```python
class Circle:
    def __init__(self, radius):
        self._radius = radius
    
    @property
    def radius(self):
        """半径属性getter。"""
        return self._radius
    
    @radius.setter
    def radius(self, value):
        """半径属性setter。"""
        if value <= 0:
            raise ValueError("半径必须为正数")
        self._radius = value
    
    @property
    def diameter(self):
        """直径属性。"""
        return self._radius * 2
    
    @property
    def area(self):
        """面积属性。"""
        return 3.14159 * self._radius ** 2

circle = Circle(5)
print(circle.radius)    # 5
print(circle.diameter)  # 10
print(circle.area)      # 78.53975

# 设置半径
circle.radius = 10
print(circle.area)      # 314.159
```

### @classmethod和@staticmethod

`@classmethod`和`@staticmethod`用于定义类方法和静态方法：

```python
class Date:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day
    
    @classmethod
    def from_string(cls, date_string):
        """从字符串创建日期对象。"""
        year, month, day = map(int, date_string.split('-'))
        return cls(year, month, day)
    
    @staticmethod
    def is_valid_date(date_string):
        """检查日期字符串是否有效。"""
        try:
            year, month, day = map(int, date_string.split('-'))
            return 1 <= month <= 12 and 1 <= day <= 31
        except:
            return False
    
    def __str__(self):
        return f"{self.year}-{self.month:02d}-{self.day:02d}"

# 使用类方法
date = Date.from_string("2023-06-15")
print(date)  # 2023-06-15

# 使用静态方法
print(Date.is_valid_date("2023-06-15"))  # True
print(Date.is_valid_date("2023-13-15"))  # False
```

## 函数进阶实战示例

### 构建简单的装饰器工厂

```python
import time
import functools

def repeat(times=1):
    """创建一个重复执行函数的装饰器。"""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            results = []
            for _ in range(times):
                results.append(func(*args, **kwargs))
            return results
        return wrapper
    return decorator

@repeat(3)
def greet(name):
    return f"Hello, {name}!"

print(greet("World"))  # ['Hello, World!', 'Hello, World!', 'Hello, World!']
```

### 创建自定义迭代器

```python
def fibonacci_generator(limit):
    """生成斐波那契数列的生成器。"""
    a, b = 0, 1
    while a < limit:
        yield a
        a, b = b, a + b

# 使用生成器
for num in fibonacci_generator(100):
    print(num, end=" ")  # 0 1 1 2 3 5 8 13 21 34 55 89
```

### 函数式数据处理管道

```python
def pipeline(*functions):
    """创建一个将数据通过多个函数传递的管道。"""
    def process(data):
        result = data
        for func in functions:
            result = func(result)
        return result
    return process

# 定义处理函数
def remove_punctuation(text):
    return ''.join(c for c in text if c.isalnum() or c.isspace())

def lowercase(text):
    return text.lower()

def tokenize(text):
    return text.split()

def remove_stopwords(tokens):
    stopwords = {'the', 'a', 'an', 'in', 'on', 'at', 'is', 'are'}
    return [token for token in tokens if token not in stopwords]

# 创建处理管道
text_processor = pipeline(
    remove_punctuation,
    lowercase,
    tokenize,
    remove_stopwords
)

# 处理文本
text = "The quick brown fox jumps over the lazy dog."
processed = text_processor(text)
print(processed)  # ['quick', 'brown', 'fox', 'jumps', 'over', 'lazy', 'dog']
```

### 实现简单的依赖注入

```python
def inject(**dependencies):
    """创建一个依赖注入装饰器。"""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # 合并依赖项和显式传递的关键字参数
            merged_kwargs = dependencies.copy()
            merged_kwargs.update(kwargs)
            return func(*args, **merged_kwargs)
        return wrapper
    return decorator

# 定义依赖项
database = {"users": {"alice": {"role": "admin"}}}
config = {"timeout": 30, "retry": 3}

# 使用依赖注入
@inject(db=database, config=config)
def get_user_role(username, db=None, config=None):
    """获取用户角色。"""
    user = db["users"].get(username)
    if user:
        return user["role"]
    return None

print(get_user_role("alice"))  # admin
```

## 总结

Python函数的进阶特性使得它成为一种非常强大和灵活的编程语言。本文介绍了以下主要概念：

1. **函数参数的高级用法**：位置参数、关键字参数、默认参数、可变参数和参数解包
2. **闭包**：函数记住并访问创建它的作用域中的变量
3. **高阶函数**：接受函数作为参数或返回函数的函数
4. **函数式编程工具**：`partial()`、`lru_cache()`等
5. **lambda表达式**：创建小型匿名函数
6. **递归函数**：调用自身的函数
7. **函数注解**：为函数参数和返回值提供类型提示
8. **函数属性**：给函数添加自定义属性
9. **内置装饰器**：`@property`、`@classmethod`、`@staticmethod`

掌握这些进阶特性可以帮助你编写更简洁、更灵活、更高效的Python代码。
