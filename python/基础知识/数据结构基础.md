# Python数据结构基础

Python提供了多种内置数据结构，使得数据的存储和操作变得高效便捷。本文详细介绍Python中的列表、元组、字典、集合等数据结构的特性和用法。

## 列表(List)

列表是Python中最常用的数据结构之一，是一种有序、可变的集合，可以存储不同类型的元素。

### 列表的创建

```python
# 空列表
empty_list = []
empty_list_alternative = list()

# 包含元素的列表
numbers = [1, 2, 3, 4, 5]
mixed = [1, "hello", 3.14, True]

# 使用list()函数从其他序列创建列表
chars = list("hello")  # 结果: ['h', 'e', 'l', 'l', 'o']
numbers_range = list(range(1, 6))  # 结果: [1, 2, 3, 4, 5]
```

### 列表的访问和切片

```python
fruits = ["apple", "banana", "cherry", "date", "elderberry"]

# 索引访问 (索引从0开始)
first_fruit = fruits[0]  # "apple"
last_fruit = fruits[-1]  # "elderberry"

# 切片 [开始:结束:步长]
first_three = fruits[0:3]  # ["apple", "banana", "cherry"]
every_other = fruits[::2]  # ["apple", "cherry", "elderberry"]
reversed_fruits = fruits[::-1]  # ["elderberry", "date", "cherry", "banana", "apple"]
```

### 列表的修改

```python
numbers = [1, 2, 3, 4, 5]

# 修改单个元素
numbers[0] = 10  # 结果: [10, 2, 3, 4, 5]

# 修改多个元素(切片赋值)
numbers[1:3] = [20, 30]  # 结果: [10, 20, 30, 4, 5]
numbers[1:3] = [200, 300, 400]  # 结果: [10, 200, 300, 400, 4, 5]
```

### 列表的常用方法

```python
fruits = ["apple", "banana", "cherry"]

# 添加元素
fruits.append("date")  # 添加到末尾: ["apple", "banana", "cherry", "date"]
fruits.insert(1, "avocado")  # 在指定位置插入: ["apple", "avocado", "banana", "cherry", "date"]
fruits.extend(["fig", "grape"])  # 扩展列表: ["apple", "avocado", "banana", "cherry", "date", "fig", "grape"]

# 删除元素
fruits.remove("banana")  # 删除指定元素: ["apple", "avocado", "cherry", "date", "fig", "grape"]
popped = fruits.pop()  # 删除并返回最后一个元素: "grape"
popped_at_index = fruits.pop(1)  # 删除并返回指定索引的元素: "avocado"
del fruits[0]  # 删除指定索引的元素: ["cherry", "date", "fig"]
fruits.clear()  # 清空列表: []

# 查找和计数
fruits = ["apple", "banana", "cherry", "banana"]
banana_index = fruits.index("banana")  # 2 (第一次出现的索引)
banana_count = fruits.count("banana")  # 2 (出现的次数)

# 排序和反转
numbers = [3, 1, 4, 1, 5, 9, 2]
numbers.sort()  # 升序排序: [1, 1, 2, 3, 4, 5, 9]
numbers.sort(reverse=True)  # 降序排序: [9, 5, 4, 3, 2, 1, 1]
numbers.reverse()  # 反转列表: [1, 1, 2, 3, 4, 5, 9]

# 复制列表
original = [1, 2, 3]
copy1 = original.copy()  # 方法1
copy2 = list(original)   # 方法2
copy3 = original[:]      # 方法3
```

### 列表的嵌套

```python
# 嵌套列表(多维列表)
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# 访问嵌套列表的元素
element = matrix[1][2]  # 6 (第2行第3列)

# 修改嵌套列表的元素
matrix[0][0] = 10  # [[10, 2, 3], [4, 5, 6], [7, 8, 9]]
```

### 列表推导式

```python
# 基本列表推导式
squares = [x**2 for x in range(1, 6)]  # [1, 4, 9, 16, 25]

# 带条件的列表推导式
even_squares = [x**2 for x in range(1, 11) if x % 2 == 0]  # [4, 16, 36, 64, 100]

# 嵌套列表推导式
flattened = [x for sublist in [[1, 2], [3, 4], [5, 6]] for x in sublist]  # [1, 2, 3, 4, 5, 6]
```

## 元组(Tuple)

元组是一种有序的不可变序列，一旦创建就不能修改其元素。

### 元组的创建

```python
# 空元组
empty_tuple = ()
empty_tuple_alternative = tuple()

# 包含元素的元组
numbers = (1, 2, 3, 4, 5)
mixed = (1, "hello", 3.14, True)

# 单元素元组(注意逗号不可少)
single_item = (42,)
not_a_tuple = (42)  # 这不是元组，而是整数42

# 使用tuple()函数从其他序列创建元组
chars = tuple("hello")  # 结果: ('h', 'e', 'l', 'l', 'o')
```

### 元组的访问和切片

```python
coordinates = (10, 20, 30, 40, 50)

# 索引访问
x = coordinates[0]  # 10
z = coordinates[2]  # 30

# 切片
first_three = coordinates[0:3]  # (10, 20, 30)
reversed_coords = coordinates[::-1]  # (50, 40, 30, 20, 10)
```

### 元组的不可变性和解包

```python
point = (10, 20, 30)

# 尝试修改元组会引发错误
# point[0] = 100  # TypeError: 'tuple' object does not support item assignment

# 元组解包
x, y, z = point
print(x, y, z)  # 10 20 30

# 使用*解包剩余元素
first, *rest = (1, 2, 3, 4, 5)
print(first, rest)  # 1 [2, 3, 4, 5]

*beginning, last = (1, 2, 3, 4, 5)
print(beginning, last)  # [1, 2, 3, 4] 5
```

### 元组的常用操作

```python
# 连接元组
tuple1 = (1, 2, 3)
tuple2 = (4, 5, 6)
combined = tuple1 + tuple2  # (1, 2, 3, 4, 5, 6)

# 重复元组
repeated = tuple1 * 3  # (1, 2, 3, 1, 2, 3, 1, 2, 3)

# 查找和计数
fruits = ("apple", "banana", "cherry", "banana")
banana_index = fruits.index("banana")  # 1 (第一次出现的索引)
banana_count = fruits.count("banana")  # 2 (出现的次数)

# 成员检查
has_apple = "apple" in fruits  # True
has_mango = "mango" in fruits  # False
```

### 元组与列表的对比

| 特性 | 元组 | 列表 |
|------|------|------|
| 可变性 | 不可变 | 可变 |
| 语法 | 使用圆括号 `()` | 使用方括号 `[]` |
| 适用场景 | 不变的数据集合，如坐标 | 需要修改的集合 |
| 性能 | 更快(不需要维护可变数据的额外内存) | 稍慢 |
| 哈希性 | 可哈希(可作为字典键或集合元素) | 不可哈希 |
| 内置方法 | 较少(仅`count`和`index`) | 较多 |

## 字典(Dictionary)

字典是Python中的键值对集合，是一种可变、无序的数据结构。

### 字典的创建

```python
# 空字典
empty_dict = {}
empty_dict_alternative = dict()

# 包含键值对的字典
person = {"name": "Alice", "age": 30, "city": "New York"}

# 使用dict()函数创建字典
person_alternative = dict(name="Alice", age=30, city="New York")

# 使用dict()和可迭代的键值对创建字典
items = [("name", "Alice"), ("age", 30), ("city", "New York")]
person_from_items = dict(items)

# 使用字典推导式创建
squares = {x: x**2 for x in range(1, 6)}  # {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
```

### 字典的访问和修改

```python
person = {"name": "Alice", "age": 30, "city": "New York"}

# 访问字典值
name = person["name"]  # "Alice"

# 使用get()方法访问(不存在的键不会引发错误)
age = person.get("age")  # 30
height = person.get("height")  # None
height_default = person.get("height", 165)  # 165 (提供默认值)

# 修改和添加键值对
person["age"] = 31  # 修改现有键值对
person["height"] = 170  # 添加新键值对

# 删除键值对
del person["city"]  # 删除指定键值对
popped_value = person.pop("age")  # 删除并返回"age"对应的值: 31
last_item = person.popitem()  # 删除并返回最后添加的键值对: ("height", 170)
person.clear()  # 清空字典: {}
```

### 字典的常用方法

```python
person = {"name": "Alice", "age": 30, "city": "New York"}

# 获取所有键、值、键值对
keys = person.keys()  # dict_keys(['name', 'age', 'city'])
values = person.values()  # dict_values(['Alice', 30, 'New York'])
items = person.items()  # dict_items([('name', 'Alice'), ('age', 30), ('city', 'New York')])

# 注意: keys(), values(), items()返回的是视图对象，会随字典变化而变化
person["height"] = 170
print(keys)  # dict_keys(['name', 'age', 'city', 'height'])

# 合并字典
person.update({"email": "alice@example.com", "age": 31})  # 更新现有键，添加新键

# 复制字典
copy1 = person.copy()  # 方法1
copy2 = dict(person)   # 方法2
```

### 字典的嵌套

```python
# 嵌套字典
users = {
    "alice": {
        "age": 30,
        "email": "alice@example.com",
        "active": True
    },
    "bob": {
        "age": 25,
        "email": "bob@example.com",
        "active": False
    }
}

# 访问嵌套字典
alice_email = users["alice"]["email"]  # "alice@example.com"

# 修改嵌套字典
users["bob"]["active"] = True
users["alice"].update({"phone": "123-456-7890"})
```

### 字典推导式

```python
# 基本字典推导式
squares = {x: x**2 for x in range(1, 6)}  # {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

# 带条件的字典推导式
even_squares = {x: x**2 for x in range(1, 11) if x % 2 == 0}  # {2: 4, 4: 16, 6: 36, 8: 64, 10: 100}

# 变换键值对
original = {"a": 1, "b": 2, "c": 3}
inverted = {v: k for k, v in original.items()}  # {1: 'a', 2: 'b', 3: 'c'}
```

## 集合(Set)

集合是Python中的无序、可变的集合，其元素不重复且必须是可哈希的。

### 集合的创建

```python
# 空集合(注意: {}创建的是空字典，不是空集合)
empty_set = set()

# 包含元素的集合
fruits = {"apple", "banana", "cherry"}

# 使用set()函数从其他可迭代对象创建集合
letters = set("hello")  # 结果: {'h', 'e', 'l', 'o'} (注意：重复的'l'只保留一个)
numbers = set([1, 2, 2, 3, 3, 3])  # 结果: {1, 2, 3} (自动去重)

# 集合推导式
squares = {x**2 for x in range(1, 6)}  # {1, 4, 9, 16, 25}
```

### 集合的操作

```python
fruits = {"apple", "banana", "cherry"}

# 添加元素
fruits.add("date")  # {"apple", "banana", "cherry", "date"}

# 删除元素
fruits.remove("banana")  # {"apple", "cherry", "date"} (如果元素不存在，会引发KeyError)
fruits.discard("mango")  # 移除元素，如果不存在不会引发错误
popped = fruits.pop()  # 随机移除并返回一个元素(因为集合是无序的)
fruits.clear()  # 清空集合: set()
```

### 集合的集合操作

```python
set1 = {1, 2, 3, 4, 5}
set2 = {4, 5, 6, 7, 8}

# 并集
union1 = set1 | set2  # {1, 2, 3, 4, 5, 6, 7, 8}
union2 = set1.union(set2)  # 同上

# 交集
intersection1 = set1 & set2  # {4, 5}
intersection2 = set1.intersection(set2)  # 同上

# 差集
difference1 = set1 - set2  # {1, 2, 3}
difference2 = set1.difference(set2)  # 同上

# 对称差集(在一个集合中但不在两个集合交集中的元素)
sym_diff1 = set1 ^ set2  # {1, 2, 3, 6, 7, 8}
sym_diff2 = set1.symmetric_difference(set2)  # 同上

# 子集和超集检查
is_subset = {1, 2}.issubset(set1)  # True
is_superset = set1.issuperset({1, 2})  # True

# 不相交检查
are_disjoint = {1, 2}.isdisjoint({3, 4})  # True (没有共同元素)
```

### 集合的应用

```python
# 去除列表中的重复元素
duplicates = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
unique = list(set(duplicates))  # [1, 2, 3, 4]

# 成员检查(比列表更快)
large_set = set(range(10000))
is_present = 9999 in large_set  # 非常快

# 找出两个列表的共同元素
list1 = [1, 2, 3, 4, 5]
list2 = [4, 5, 6, 7, 8]
common = set(list1) & set(list2)  # {4, 5}

# 找出唯一元素
text = "hello world"
unique_chars = set(text)  # {'h', 'e', 'l', 'o', ' ', 'w', 'r', 'd'}
```

## 不可变集合(frozenset)

frozenset是不可变的集合，可以作为字典的键或其他集合的元素。

```python
# 创建frozenset
immutable = frozenset([1, 2, 3, 4, 5])

# 尝试修改会引发错误
# immutable.add(6)  # AttributeError: 'frozenset' object has no attribute 'add'

# 可以作为字典键
set_dict = {immutable: "This is a frozen set"}

# 支持常规集合操作
another_set = frozenset([3, 4, 5, 6, 7])
union = immutable | another_set  # frozenset({1, 2, 3, 4, 5, 6, 7})
```

## 数据结构的选择

根据使用场景选择合适的数据结构：

| 数据结构 | 特点 | 适用场景 |
|---------|------|---------|
| 列表(list) | 有序、可变、可重复 | 需要保持顺序并可能修改的数据集合 |
| 元组(tuple) | 有序、不可变、可重复 | 不应修改的数据集合，如配置、多返回值 |
| 字典(dict) | 键值对、可变、无序 | 需要通过键快速查找值的场景 |
| 集合(set) | 无序、可变、不重复 | 需要唯一性或执行集合操作的场景 |
| 不可变集合(frozenset) | 无序、不可变、不重复 | 需要不可变性和唯一性的场景 |

## 内置数据结构的性能

不同操作的时间复杂度：

| 操作 | 列表 | 元组 | 字典 | 集合 |
|------|------|------|------|------|
| 索引访问 | O(1) | O(1) | O(1) | N/A |
| 追加元素 | O(1) | N/A | O(1) | O(1) |
| 插入元素 | O(n) | N/A | O(1) | O(1) |
| 删除元素 | O(n) | N/A | O(1) | O(1) |
| 查找元素 | O(n) | O(n) | O(1) | O(1) |
| 长度获取 | O(1) | O(1) | O(1) | O(1) |

## 数据结构的嵌套和组合

在实际应用中，经常需要组合使用不同的数据结构：

```python
# 复杂数据结构的示例 - 表示学生成绩单
grades = {
    "Alice": {
        "math": [85, 90, 92],
        "science": [88, 85, 90],
        "history": [92, 95, 88]
    },
    "Bob": {
        "math": [75, 80, 85],
        "science": [90, 92, 88],
        "history": [85, 88, 90]
    }
}

# 计算Alice的数学平均分
alice_math_avg = sum(grades["Alice"]["math"]) / len(grades["Alice"]["math"])

# 添加新学生
grades["Charlie"] = {
    "math": [95, 92, 90],
    "science": [88, 90, 92],
    "history": [85, 87, 90]
}

# 添加新科目
for student in grades:
    grades[student]["english"] = []

# 使用列表推导式计算所有学生的科学平均分
science_avgs = {
    student: sum(data["science"]) / len(data["science"])
    for student, data in grades.items()
}

# 使用嵌套结构表示更复杂的数据
school_data = {
    "students": [
        {"id": 1, "name": "Alice", "grade": 10},
        {"id": 2, "name": "Bob", "grade": 11},
        {"id": 3, "name": "Charlie", "grade": 10}
    ],
    "teachers": [
        {"id": 101, "name": "Mr. Smith", "subjects": ["Math", "Physics"]},
        {"id": 102, "name": "Ms. Johnson", "subjects": ["English", "History"]}
    ],
    "classes": {
        "Math101": {"teacher_id": 101, "student_ids": [1, 2]},
        "English101": {"teacher_id": 102, "student_ids": [1, 3]},
        "History101": {"teacher_id": 102, "student_ids": [2, 3]}
    }
}
```

## 总结

Python的内置数据结构为不同的编程需求提供了灵活而强大的解决方案：

- **列表(list)** 适合存储和处理有序、可变的集合
- **元组(tuple)** 适合表示不应被修改的数据集合
- **字典(dict)** 适合需要通过键快速查找值的场景
- **集合(set)** 适合需要保证元素唯一性或执行集合操作的场景
- **不可变集合(frozenset)** 适合需要不可变性和唯一性的场景

通过合理选择和组合这些数据结构，可以高效地解决各种数据处理和存储问题。掌握这些数据结构的特性、操作和性能特点，是编写高效Python代码的基础。
