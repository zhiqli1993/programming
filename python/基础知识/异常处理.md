# Python异常处理

异常处理是Python中处理错误和异常情况的重要机制。合理使用异常处理可以使程序更加健壮，同时保持代码的可读性和可维护性。本文详细介绍Python异常处理的基本概念和高级技巧。

## 异常基础

### 什么是异常

异常是程序执行过程中发生的错误或异常情况，会中断程序的正常执行流程。例如：

- 尝试打开不存在的文件
- 除以零
- 访问列表或字典中不存在的索引或键
- 调用对象不支持的方法
- 导入不存在的模块

### Python异常的类型结构

Python中所有的异常都是从`BaseException`类派生的。常见的异常层次结构如下：

```
BaseException
 ├── SystemExit                # 解释器请求退出
 ├── KeyboardInterrupt         # 用户中断执行(通常是Ctrl+C)
 ├── GeneratorExit             # 生成器或协程被关闭
 └── Exception                 # 常规错误的基类
      ├── StopIteration        # 迭代器没有更多的值
      ├── ArithmeticError      # 数值计算错误的基类
      │    ├── FloatingPointError  # 浮点计算错误
      │    ├── OverflowError       # 数值运算超出最大限制
      │    └── ZeroDivisionError   # 除(或取模)零
      ├── AssertionError       # assert语句失败
      ├── AttributeError       # 对象没有这个属性
      ├── EOFError             # 没有内容可读取
      ├── ImportError          # 导入模块/对象失败
      │    └── ModuleNotFoundError # 找不到模块
      ├── LookupError          # 无效数据查询的基类
      │    ├── IndexError      # 序列中没有此索引
      │    └── KeyError        # 映射中没有此键
      ├── NameError            # 未声明/初始化对象
      │    └── UnboundLocalError # 访问未初始化的本地变量
      ├── OSError              # 操作系统错误
      │    ├── FileExistsError    # 创建已存在的文件
      │    ├── FileNotFoundError  # 请求不存在的文件
      │    ├── PermissionError    # 没有权限
      │    └── TimeoutError       # 系统函数超时
      ├── RuntimeError         # 一般的运行时错误
      │    └── RecursionError  # 超过最大递归深度
      ├── SyntaxError          # 语法错误
      │    └── IndentationError    # 缩进错误
      ├── TypeError            # 操作或函数应用于不适当类型
      ├── ValueError           # 操作或函数收到类型正确但值不适当的参数
      │    └── UnicodeError    # Unicode相关的错误
      └── Warning              # 警告的基类
```

## 基本异常处理

### try-except 结构

使用`try-except`结构来捕获和处理异常：

```python
try:
    # 可能会引发异常的代码
    result = 10 / 0
except ZeroDivisionError:
    # 处理特定类型的异常
    print("除数不能为零！")
```

### 捕获多种异常

可以捕获多种异常，并针对不同异常执行不同的处理代码：

```python
try:
    # 可能会引发不同类型异常的代码
    value = int(input("请输入一个整数: "))
    result = 100 / value
except ValueError:
    # 处理值错误
    print("输入必须是整数！")
except ZeroDivisionError:
    # 处理除零错误
    print("输入不能为零！")
```

### 在一个except子句中捕获多种异常

可以在一个except子句中捕获多种异常：

```python
try:
    # 可能会引发不同类型异常的代码
    value = int(input("请输入一个整数: "))
    result = 100 / value
except (ValueError, ZeroDivisionError):
    # 处理值错误或除零错误
    print("输入必须是非零整数！")
```

### 捕获所有异常

可以使用不带具体异常类型的`except`语句捕获所有异常，但这不是最佳实践：

```python
try:
    # 可能会引发异常的代码
    x = 1 / 0
except:
    # 捕获所有异常
    print("发生了异常！")
```

更好的做法是捕获`Exception`类，它能捕获大多数异常但排除系统退出异常如`KeyboardInterrupt`：

```python
try:
    # 可能会引发异常的代码
    x = 1 / 0
except Exception as e:
    # 捕获所有常规异常
    print(f"发生了异常: {e}")
```

### 访问异常对象

使用`as`关键字可以捕获异常对象，从而获取更多关于异常的信息：

```python
try:
    with open("不存在的文件.txt", "r") as file:
        content = file.read()
except FileNotFoundError as e:
    print(f"错误信息: {e}")
    print(f"错误类型: {type(e).__name__}")
```

### else子句

`else`子句用于在没有异常发生时执行代码：

```python
try:
    value = int(input("请输入一个整数: "))
except ValueError:
    print("不是有效的整数！")
else:
    # 只有当没有异常发生时才会执行
    print(f"你输入的是: {value}")
```

### finally子句

`finally`子句用于无论异常是否发生都必须执行的代码，通常用于清理资源：

```python
try:
    file = open("example.txt", "r")
    content = file.read()
except FileNotFoundError:
    print("文件不存在")
finally:
    # 确保文件被关闭，即使发生异常
    if 'file' in locals():
        file.close()
    print("清理工作完成")
```

## 高级异常处理

### 使用with语句（上下文管理器）

对于支持上下文管理协议的对象（如文件），使用`with`语句可以自动处理资源的获取和释放：

```python
try:
    with open("example.txt", "r") as file:
        content = file.read()
except FileNotFoundError:
    print("文件不存在")
# 不需要手动关闭文件，with语句会自动处理
```

### 自定义异常

可以通过继承`Exception`类（或其子类）来创建自定义异常：

```python
class CustomError(Exception):
    """自定义异常的基类"""
    pass

class ValueTooSmallError(CustomError):
    """当输入值小于最小值时引发"""
    def __init__(self, message, value):
        self.message = message
        self.value = value
        super().__init__(self.message)

# 使用自定义异常
def process_value(value):
    min_value = 10
    if value < min_value:
        raise ValueTooSmallError(f"值不能小于{min_value}", value)
    return value * 2

try:
    result = process_value(5)
except ValueTooSmallError as e:
    print(f"错误: {e.message}, 提供的值是: {e.value}")
```

### 异常链（异常上下文）

从Python 3开始，可以在引发新异常时保留原始异常的上下文：

```python
try:
    # 可能会引发OSError的操作
    file = open("不存在的文件.txt", "r")
except OSError as e:
    # 引发新异常，同时保留原始异常
    raise RuntimeError("无法处理文件") from e
```

或者可以禁用自动异常链接：

```python
try:
    # 尝试一些操作
    int("非整数")
except ValueError as e:
    # 引发新异常，但不保留原始异常
    raise RuntimeError("发生了处理错误") from None
```

## 异常处理的最佳实践

### 1. 只捕获预期的特定异常

捕获具体的异常类型，而不是笼统地捕获所有异常：

```python
# 好的做法
try:
    value = int(input("请输入数字: "))
except ValueError:
    print("输入必须是数字")

# 避免的做法
try:
    value = int(input("请输入数字: "))
except:  # 捕获所有异常
    print("输入有误")
```

### 2. 尽早失败，优雅地恢复

检测并处理错误条件应该尽早进行，并以优雅的方式恢复：

```python
def divide(a, b):
    if b == 0:
        raise ValueError("除数不能为零")
    return a / b

try:
    result = divide(10, 0)
except ValueError as e:
    print(f"错误: {e}")
    result = None  # 设置默认值或执行替代操作
```

### 3. 保持异常处理代码简洁

异常处理块应该简短，主要逻辑不应该被异常处理代码掩盖：

```python
# 好的做法
try:
    process_data(data)
except DataError as e:
    logger.error(f"数据处理错误: {e}")
    send_error_notification(e)
```

### 4. 不要使用异常进行流程控制

异常应该用于处理异常情况，不应该用于正常的程序流程控制：

```python
# 不好的做法
try:
    value = dict_data["key"]
except KeyError:
    value = default_value

# 更好的做法
value = dict_data.get("key", default_value)
```

### 5. 记录异常信息

在生产环境中，应记录异常信息以便后续分析：

```python
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

try:
    # 一些可能会失败的操作
    result = risky_operation()
except Exception as e:
    logger.exception(f"操作失败: {e}")
    # 处理异常
```

### 6. 合理使用异常层次结构

在设计自定义异常时，应合理使用异常的层次结构：

```python
class AppError(Exception):
    """应用程序错误的基类"""
    pass

class ConfigError(AppError):
    """配置错误"""
    pass

class DatabaseError(AppError):
    """数据库错误"""
    pass

class NetworkError(AppError):
    """网络错误"""
    pass

# 使用时，可以按需捕获特定或通用异常
try:
    # 可能引发不同类型异常的操作
    setup_app()
except ConfigError as e:
    # 处理配置错误
    print(f"配置错误: {e}")
except DatabaseError as e:
    # 处理数据库错误
    print(f"数据库错误: {e}")
except AppError as e:
    # 处理其他应用程序错误
    print(f"应用错误: {e}")
```

## 实际应用示例

### 文件处理

```python
def read_config_file(file_path):
    try:
        with open(file_path, 'r') as file:
            return file.read()
    except FileNotFoundError:
        print(f"配置文件 {file_path} 不存在")
        return None
    except PermissionError:
        print(f"没有权限读取文件 {file_path}")
        return None
    except IOError as e:
        print(f"读取文件时发生IO错误: {e}")
        return None
```

### 网络请求

```python
import requests
import time

def fetch_data(url, max_retries=3):
    """获取URL的数据，支持重试"""
    retries = 0
    while retries < max_retries:
        try:
            response = requests.get(url, timeout=10)
            response.raise_for_status()  # 如果响应状态码不是200，引发HTTPError
            return response.json()
        except requests.exceptions.HTTPError as e:
            print(f"HTTP错误: {e}")
            if response.status_code == 404:  # 资源不存在
                return None
            # 其他HTTP错误可能是临时的，可以重试
        except requests.exceptions.ConnectionError:
            print("连接错误，可能是网络问题")
        except requests.exceptions.Timeout:
            print("请求超时")
        except requests.exceptions.RequestException as e:
            print(f"请求异常: {e}")
            return None  # 其他请求异常，不再重试
        except ValueError as e:
            print(f"无效的JSON响应: {e}")
            return None
            
        retries += 1
        if retries < max_retries:
            # 指数退避策略
            wait_time = 2 ** retries
            print(f"等待{wait_time}秒后重试...")
            time.sleep(wait_time)
    
    print(f"达到最大重试次数({max_retries})，操作失败")
    return None
```

### 数据库操作

```python
import sqlite3

class DatabaseManager:
    def __init__(self, db_path):
        self.db_path = db_path
        self.connection = None
        
    def connect(self):
        try:
            self.connection = sqlite3.connect(self.db_path)
            return True
        except sqlite3.Error as e:
            print(f"数据库连接错误: {e}")
            return False
            
    def execute_query(self, query, params=()):
        if not self.connection:
            if not self.connect():
                return None
                
        try:
            cursor = self.connection.cursor()
            cursor.execute(query, params)
            self.connection.commit()
            return cursor
        except sqlite3.Error as e:
            print(f"查询执行错误: {e}")
            self.connection.rollback()
            return None
            
    def fetch_data(self, query, params=()):
        cursor = self.execute_query(query, params)
        if cursor:
            try:
                return cursor.fetchall()
            except sqlite3.Error as e:
                print(f"获取数据错误: {e}")
                return None
        return None
        
    def close(self):
        if self.connection:
            self.connection.close()
            self.connection = None

# 使用示例
def get_user_data(user_id):
    db = DatabaseManager("users.db")
    try:
        query = "SELECT * FROM users WHERE id = ?"
        results = db.fetch_data(query, (user_id,))
        if results:
            return results[0]
        else:
            print(f"未找到ID为{user_id}的用户")
            return None
    finally:
        db.close()
```

### 用户输入验证

```python
def get_positive_integer(prompt):
    while True:
        try:
            value = int(input(prompt))
            if value <= 0:
                print("请输入正整数")
                continue
            return value
        except ValueError:
            print("无效输入，请输入一个整数")
        except KeyboardInterrupt:
            print("\n操作被用户中断")
            return None
        except EOFError:
            print("\n没有更多输入")
            return None
```

## 异常和性能

### 异常处理对性能的影响

异常处理在Python中是一种相对昂贵的操作，特别是当异常被频繁引发时。因此，在性能关键的代码中，应当遵循以下原则：

1. **不要使用异常进行流程控制**：如前所述，使用正常的控制结构而不是异常来处理预期的情况。

2. **EAFP vs LBYL**：
   - EAFP (Easier to Ask for Forgiveness than Permission): 先尝试操作，捕获可能的异常。
   - LBYL (Look Before You Leap): 在执行操作前检查条件。

   在Python中，通常推荐EAFP风格，但在性能关键的循环中，LBYL可能更高效。

```python
# EAFP风格
def get_value_eafp(dictionary, key):
    try:
        return dictionary[key]
    except KeyError:
        return None

# LBYL风格
def get_value_lbyl(dictionary, key):
    if key in dictionary:
        return dictionary[key]
    else:
        return None
```

3. **避免过多的try-except嵌套**：嵌套的异常处理可能导致代码难以理解，并增加性能开销。

## 总结

异常处理是Python编程中不可或缺的一部分，它允许程序优雅地处理错误和异常情况。本文介绍了Python异常处理的基础知识和高级技巧，包括：

- 异常的基本概念和类型结构
- 基本的try-except-else-finally结构
- 捕获和处理多种异常
- 自定义异常类
- 异常链接
- 异常处理的最佳实践
- 实际应用示例

通过合理使用异常处理，可以提高程序的健壮性和可维护性，同时保持代码的简洁和可读性。
