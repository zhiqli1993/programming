# Python文件操作

文件操作是几乎所有程序都需要的基本功能，Python提供了简单而强大的文件处理机制。本文档介绍了Python中处理文件的各种方法和最佳实践。

## 文件打开与关闭

### 打开文件

Python使用内置的`open()`函数打开文件，它返回一个文件对象：

```python
# 基本语法
file = open(filename, mode)
```

参数说明：
- `filename`：要打开的文件路径（字符串）
- `mode`：打开模式（字符串），指定文件的访问模式

常用的文件打开模式：

| 模式 | 描述 |
|------|------|
| `'r'` | 只读模式（默认） |
| `'w'` | 写入模式（覆盖已有内容） |
| `'a'` | 追加模式（在文件末尾添加内容） |
| `'x'` | 独占创建模式（如果文件已存在则失败） |
| `'b'` | 二进制模式（与其他模式结合使用，如`'rb'`、`'wb'`） |
| `'t'` | 文本模式（默认，与其他模式结合使用，如`'rt'`、`'wt'`） |
| `'+'` | 读写模式（与其他模式结合使用，如`'r+'`、`'w+'`） |

### 关闭文件

在使用完文件后，应该始终关闭文件以释放系统资源：

```python
file = open('example.txt', 'r')
# 进行文件操作
file.close()  # 关闭文件
```

### 使用with语句（推荐方式）

更好的实践是使用`with`语句，它会自动处理文件的关闭操作，即使发生异常也能确保文件被关闭：

```python
with open('example.txt', 'r') as file:
    # 进行文件操作
    content = file.read()
    print(content)
# 文件在with块结束时自动关闭
```

## 文件读取

Python提供了多种方法来读取文件内容：

### 读取整个文件

```python
with open('example.txt', 'r') as file:
    content = file.read()  # 读取整个文件内容为一个字符串
    print(content)
```

### 按行读取

```python
# 读取所有行到一个列表
with open('example.txt', 'r') as file:
    lines = file.readlines()  # 返回一个包含所有行的列表
    for line in lines:
        print(line.strip())  # 使用strip()去除行末的换行符

# 逐行读取（内存效率更高）
with open('example.txt', 'r') as file:
    for line in file:  # 文件对象是可迭代的
        print(line.strip())
```

### 读取指定字节数

```python
with open('example.txt', 'r') as file:
    chunk = file.read(100)  # 读取前100个字符
    print(chunk)
```

### 读取一行

```python
with open('example.txt', 'r') as file:
    line = file.readline()  # 读取一行
    print(line)
```

## 文件写入

### 写入字符串

```python
with open('output.txt', 'w') as file:
    file.write('Hello, World!\n')  # 写入一行文本
    file.write('This is a new line.')  # 写入第二行
```

### 写入多行

```python
lines = ['Line 1\n', 'Line 2\n', 'Line 3\n']

with open('output.txt', 'w') as file:
    file.writelines(lines)  # 写入多行
```

注意：`writelines()`不会自动添加换行符，需要在每行文本中包含换行符。

### 追加内容

使用`'a'`模式可以在文件末尾追加内容，而不覆盖已有内容：

```python
with open('output.txt', 'a') as file:
    file.write('\nThis line is appended.')
```

## 文件定位

可以使用`seek()`和`tell()`方法操作文件指针的位置：

```python
with open('example.txt', 'r') as file:
    position = file.tell()  # 获取当前位置
    print(f"当前位置: {position}")
    
    file.seek(10)  # 移动到第10个字节
    data = file.read(5)  # 从第10个字节开始读取5个字节
    print(data)
    
    file.seek(0)  # 回到文件开头
    beginning = file.read(10)
    print(beginning)
```

`seek(offset, whence)`方法参数说明：
- `offset`：偏移量（字节数）
- `whence`：可选，指定偏移起始位置
  - `0`：从文件开头（默认）
  - `1`：从当前位置
  - `2`：从文件末尾

## 二进制文件操作

对于图像、音频等二进制文件，需要使用二进制模式：

```python
# 读取二进制文件
with open('image.jpg', 'rb') as file:
    binary_data = file.read()
    # 处理二进制数据

# 写入二进制文件
with open('output.jpg', 'wb') as file:
    file.write(binary_data)
```

## 文件编码

在处理文本文件时，可以指定文件编码：

```python
# 读取UTF-8编码的文件
with open('example.txt', 'r', encoding='utf-8') as file:
    content = file.read()

# 使用特定编码写入文件
with open('output.txt', 'w', encoding='utf-8') as file:
    file.write('这是中文内容')
```

常用编码：
- `'utf-8'`：Unicode编码，支持多种语言
- `'ascii'`：ASCII编码，仅支持英文和基本符号
- `'gbk'`、`'gb2312'`：中文编码
- `'latin-1'`：西欧语言编码

## 文件和目录管理

### os模块

Python的`os`模块提供了与操作系统交互的函数，包括文件和目录操作：

```python
import os

# 检查文件是否存在
if os.path.exists('example.txt'):
    print('文件存在')

# 获取文件大小
size = os.path.getsize('example.txt')
print(f'文件大小: {size} 字节')

# 检查是文件还是目录
if os.path.isfile('example.txt'):
    print('这是一个文件')
if os.path.isdir('my_folder'):
    print('这是一个目录')

# 获取绝对路径
abs_path = os.path.abspath('example.txt')
print(f'绝对路径: {abs_path}')

# 分离路径和文件名
dir_name, file_name = os.path.split(abs_path)
print(f'目录: {dir_name}, 文件名: {file_name}')

# 分离文件名和扩展名
base_name, ext = os.path.splitext(file_name)
print(f'文件名: {base_name}, 扩展名: {ext}')
```

### 目录操作

```python
import os

# 获取当前工作目录
current_dir = os.getcwd()
print(f'当前目录: {current_dir}')

# 创建目录
if not os.path.exists('new_folder'):
    os.mkdir('new_folder')  # 创建单个目录
    os.makedirs('path/to/nested/folder', exist_ok=True)  # 创建多级目录

# 列出目录内容
files = os.listdir('.')  # 列出当前目录下的所有文件和子目录
print(files)

# 修改当前工作目录
os.chdir('new_folder')
print(f'新的当前目录: {os.getcwd()}')

# 删除目录
os.rmdir('empty_folder')  # 删除空目录
import shutil
shutil.rmtree('non_empty_folder')  # 删除非空目录（需要shutil模块）
```

### 文件操作

```python
import os
import shutil

# 重命名文件
os.rename('old_name.txt', 'new_name.txt')

# 删除文件
os.remove('unwanted.txt')

# 复制文件
shutil.copy('source.txt', 'destination.txt')  # 复制文件
shutil.copy2('source.txt', 'destination.txt')  # 复制文件，保留元数据

# 移动文件
shutil.move('source.txt', 'new/location/source.txt')
```

## 文件遍历

### 遍历目录树

`os.walk()`函数可以递归遍历目录树：

```python
import os

for root, dirs, files in os.walk('my_folder'):
    print(f'当前目录: {root}')
    print(f'子目录: {dirs}')
    print(f'文件: {files}')
    print('-' * 30)
```

### 使用glob模块匹配文件

`glob`模块支持使用通配符匹配文件：

```python
import glob

# 列出所有.py文件
python_files = glob.glob('*.py')
print(python_files)

# 递归查找所有.txt文件
text_files = glob.glob('**/*.txt', recursive=True)
print(text_files)
```

## 临时文件和目录

`tempfile`模块提供了创建临时文件和目录的函数：

```python
import tempfile

# 创建临时文件
with tempfile.TemporaryFile() as temp:
    temp.write(b'Some binary data')
    temp.seek(0)
    data = temp.read()
    print(data)

# 创建命名临时文件
with tempfile.NamedTemporaryFile(delete=False) as temp:
    print(f'临时文件名: {temp.name}')
    temp.write(b'More data')

# 创建临时目录
temp_dir = tempfile.TemporaryDirectory()
print(f'临时目录: {temp_dir.name}')
temp_dir.cleanup()  # 删除临时目录
```

## 文件压缩和解压

Python提供了处理各种压缩格式的模块：

### zipfile模块

```python
import zipfile

# 创建zip文件
with zipfile.ZipFile('archive.zip', 'w') as zip_file:
    zip_file.write('file1.txt')
    zip_file.write('file2.txt')

# 列出zip文件内容
with zipfile.ZipFile('archive.zip', 'r') as zip_file:
    print(zip_file.namelist())

# 解压zip文件
with zipfile.ZipFile('archive.zip', 'r') as zip_file:
    zip_file.extractall('extracted_folder')
```

### tarfile模块

```python
import tarfile

# 创建tar文件
with tarfile.open('archive.tar.gz', 'w:gz') as tar:
    tar.add('file1.txt')
    tar.add('file2.txt')

# 列出tar文件内容
with tarfile.open('archive.tar.gz', 'r:gz') as tar:
    print(tar.getnames())

# 解压tar文件
with tarfile.open('archive.tar.gz', 'r:gz') as tar:
    tar.extractall('extracted_folder')
```

## 路径处理：pathlib模块

Python 3.4引入了`pathlib`模块，提供了面向对象的文件系统路径处理方式：

```python
from pathlib import Path

# 创建Path对象
path = Path('example.txt')
directory = Path('my_folder')

# 检查是否存在
if path.exists():
    print('文件存在')

# 文件属性
print(f'是文件: {path.is_file()}')
print(f'是目录: {path.is_dir()}')
print(f'大小: {path.stat().st_size} 字节')

# 路径操作
parent = path.parent  # 父目录
name = path.name  # 文件名
stem = path.stem  # 不带扩展名的文件名
suffix = path.suffix  # 扩展名
absolute = path.absolute()  # 绝对路径

# 路径组合
new_path = directory / 'subdir' / 'file.txt'
print(new_path)

# 创建目录
new_dir = Path('new_directory')
new_dir.mkdir(exist_ok=True)

# 递归创建目录
nested_dir = Path('parent/child/grandchild')
nested_dir.mkdir(parents=True, exist_ok=True)

# 读写文件
content = path.read_text(encoding='utf-8')  # 读取文本
path.write_text('New content', encoding='utf-8')  # 写入文本

binary_data = path.read_bytes()  # 读取二进制数据
path.write_bytes(b'Binary content')  # 写入二进制数据

# 遍历目录
for item in directory.iterdir():
    print(item)

# 查找文件
python_files = list(directory.glob('**/*.py'))  # 递归查找所有.py文件
```

## 文件操作的最佳实践

1. **使用`with`语句**：总是使用`with`语句打开文件，确保文件被正确关闭。

2. **指定编码**：处理文本文件时，明确指定文件编码，避免编码问题。

3. **异常处理**：添加适当的异常处理代码，处理可能的文件操作错误。
   ```python
   try:
       with open('file.txt', 'r') as file:
           content = file.read()
   except FileNotFoundError:
       print('文件不存在')
   except PermissionError:
       print('没有权限读取文件')
   except Exception as e:
       print(f'发生错误: {e}')
   ```

4. **逐行处理大文件**：处理大文件时，逐行读取而不是一次读取整个文件，以减少内存使用。

5. **使用`pathlib`**：在Python 3.4+中，优先使用`pathlib`模块而不是`os.path`，代码更简洁易读。

6. **考虑性能**：对于频繁的文件操作，考虑使用缓冲或内存映射文件提高性能。

7. **检查文件存在性**：在操作文件前先检查文件是否存在，避免不必要的错误。

8. **使用临时文件**：对于临时数据，使用`tempfile`模块创建临时文件和目录。

Python的文件操作接口简洁而强大，掌握这些基本操作可以处理大多数文件相关的任务。随着经验的积累，可以探索更高级的文件处理技术，如内存映射文件、异步文件I/O等。
