# Python迭代器与生成器基础

迭代器和生成器是Python中非常重要的概念，它们提供了一种优雅的方式来处理序列数据，特别是当处理大量数据或无限序列时。本文详细介绍Python迭代器和生成器的基本概念和用法。

## 迭代与可迭代对象

### 什么是迭代

迭代是指重复执行一系列操作的过程，在Python中通常是指逐个访问集合（如列表、元组、字典等）中的元素。Python的`for`循环就是迭代的一个例子：

```python
for element in [1, 2, 3, 4]:
    print(element)
```

### 可迭代对象(Iterable)

可迭代对象是Python中可以被迭代的任何对象。简单来说，可迭代对象是能够一次返回其中一个成员的对象。Python中的许多内置类型都是可迭代的：

- 列表(`list`)
- 元组(`tuple`)
- 字符串(`str`)
- 字典(`dict`)
- 集合(`set`)
- 文件对象(`file`)

可迭代对象实现了`__iter__`方法，该方法返回一个迭代器对象。

```python
# 检查对象是否可迭代
def is_iterable(obj):
    try:
        iter(obj)
        return True
    except TypeError:
        return False

print(is_iterable([1, 2, 3]))     # True
print(is_iterable("Hello"))       # True
print(is_iterable(123))           # False
```

## 迭代器(Iterator)

### 什么是迭代器

迭代器是一个表示数据流的对象，它实现了迭代器协议，包含`__iter__`和`__next__`两个方法：

- `__iter__`: 返回迭代器对象本身
- `__next__`: 返回下一个值，如果没有更多值可返回，则引发`StopIteration`异常

迭代器跟踪序列中的位置，并知道如何获取下一个值。

### 迭代器示例

可以使用`iter()`函数从可迭代对象创建迭代器，然后使用`next()`函数获取下一个元素：

```python
# 创建迭代器
my_list = [1, 2, 3, 4, 5]
iterator = iter(my_list)

# 使用next()获取元素
print(next(iterator))  # 1
print(next(iterator))  # 2
print(next(iterator))  # 3

# 迭代完所有元素后再调用next()会引发StopIteration异常
# 可以使用try-except捕获这个异常
try:
    while True:
        item = next(iterator)
        print(item)
except StopIteration:
    print("迭代完成")
```

### 迭代器的特点

1. **惰性求值**：迭代器只在需要时才计算下一个值，不会一次性计算所有值
2. **一次性**：迭代器只能遍历一次，遍历后就会耗尽
3. **无法重置**：一旦迭代器被耗尽，无法重置它（除非重新创建）
4. **节省内存**：迭代器不需要将所有元素存储在内存中，适合处理大数据集

### 自定义迭代器

通过实现`__iter__`和`__next__`方法，可以创建自定义迭代器：

```python
class CountDown:
    """一个从n倒数到1的迭代器"""
    
    def __init__(self, start):
        self.start = start
    
    def __iter__(self):
        # 返回迭代器对象本身
        return self
    
    def __next__(self):
        # 如果计数器小于等于0，抛出StopIteration异常
        if self.start <= 0:
            raise StopIteration
        
        # 否则返回当前值并递减
        current = self.start
        self.start -= 1
        return current

# 使用自定义迭代器
for i in CountDown(5):
    print(i)  # 输出: 5, 4, 3, 2, 1
```

## 生成器(Generator)

### 什么是生成器

生成器是创建迭代器的一种简单而强大的方式。它是一个特殊的函数，使用`yield`语句而不是`return`语句返回值。每次调用`next()`时，生成器会从上次离开的地方恢复执行，直到遇到下一个`yield`语句。

生成器函数在调用时不会立即执行，而是返回一个生成器对象，这个对象遵循迭代器协议。

### 生成器函数

使用`yield`关键字定义的函数就是生成器函数：

```python
def simple_generator():
    yield 1
    yield 2
    yield 3

# 创建生成器对象
gen = simple_generator()

# 生成器对象是迭代器
print(next(gen))  # 1
print(next(gen))  # 2
print(next(gen))  # 3
# print(next(gen))  # StopIteration异常

# 使用for循环迭代生成器
for value in simple_generator():
    print(value)  # 输出: 1, 2, 3
```

### 生成器表达式

生成器表达式是创建生成器的简洁方式，语法类似于列表推导式，但使用圆括号而不是方括号：

```python
# 列表推导式 - 立即计算所有值并存储在内存中
squares_list = [x**2 for x in range(10)]

# 生成器表达式 - 惰性计算，按需生成值
squares_gen = (x**2 for x in range(10))

print(squares_list)  # 输出完整列表: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
print(squares_gen)   # 输出生成器对象: <generator object <genexpr> at 0x...>

# 迭代生成器表达式
for square in squares_gen:
    print(square)
```

### 生成器的优势

1. **内存效率**：生成器不会一次性加载所有数据到内存中
2. **按需计算**：只在需要时才计算下一个值
3. **代码简洁**：比定义迭代器类更简洁
4. **无限序列**：可以表示无限序列，如自然数序列

### 生成器的实际应用

#### 处理大文件

生成器适合处理大文件，避免一次性将整个文件读入内存：

```python
def read_large_file(file_path):
    with open(file_path, 'r') as file:
        for line in file:
            yield line.strip()

# 处理大文件的每一行
for line in read_large_file("large_file.txt"):
    print(line)
```

#### 斐波那契数列

生成器可以轻松创建无限序列，如斐波那契数列：

```python
def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

# 获取前10个斐波那契数
fib_gen = fibonacci()
for _ in range(10):
    print(next(fib_gen))  # 输出: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34
```

#### 数据转换管道

生成器可以用于创建数据处理管道：

```python
def read_data(file_path):
    with open(file_path, 'r') as file:
        for line in file:
            yield line.strip()

def parse_data(lines):
    for line in lines:
        # 假设每行是CSV格式
        yield line.split(',')

def filter_data(rows, keyword):
    for row in rows:
        if keyword in row[0]:  # 假设关键字在第一列
            yield row

def process_file(file_path, keyword):
    lines = read_data(file_path)
    rows = parse_data(lines)
    filtered_rows = filter_data(rows, keyword)
    
    for row in filtered_rows:
        print(row)

# 处理文件
process_file("data.csv", "Python")
```

## `yield from`语句

`yield from`是Python 3.3引入的语法，用于简化嵌套生成器：

```python
# 不使用yield from
def chain_generators_old(gen1, gen2):
    for item in gen1:
        yield item
    for item in gen2:
        yield item

# 使用yield from
def chain_generators(gen1, gen2):
    yield from gen1
    yield from gen2

# 示例
def gen1():
    yield 1
    yield 2

def gen2():
    yield 3
    yield 4

# 链接生成器
for item in chain_generators(gen1(), gen2()):
    print(item)  # 输出: 1, 2, 3, 4
```

`yield from`不仅可以代理生成器，还可以代理任何可迭代对象：

```python
def flatten(nested_list):
    """扁平化嵌套列表"""
    for item in nested_list:
        if isinstance(item, list):
            # 如果item是列表，递归生成其元素
            yield from flatten(item)
        else:
            # 否则直接生成item
            yield item

# 示例
nested = [1, [2, [3, 4], 5], 6]
for num in flatten(nested):
    print(num)  # 输出: 1, 2, 3, 4, 5, 6
```

## 生成器方法

生成器除了`__next__`方法外，还支持以下方法：

### send()方法

`send()`方法允许向生成器发送值，这个值会成为`yield`表达式的结果：

```python
def echo_generator():
    while True:
        received = yield
        print(f"Received: {received}")

# 创建生成器
gen = echo_generator()

# 首先启动生成器（执行到第一个yield）
next(gen)  # 或者 gen.send(None)

# 发送值
gen.send("Hello")  # 输出: Received: Hello
gen.send("World")  # 输出: Received: World
```

### throw()方法

`throw()`方法用于在生成器暂停的位置引发异常：

```python
def sample_generator():
    try:
        yield 1
        yield 2
        yield 3
    except ValueError:
        yield 'Exception caught'

# 创建生成器
gen = sample_generator()

print(next(gen))  # 1
print(gen.throw(ValueError))  # Exception caught
```

### close()方法

`close()`方法用于关闭生成器，它会在生成器暂停的位置引发`GeneratorExit`异常：

```python
def closeable_generator():
    try:
        yield 1
        yield 2
        yield 3
    except GeneratorExit:
        print("Generator closed")

# 创建生成器
gen = closeable_generator()

print(next(gen))  # 1
gen.close()  # 输出: Generator closed
```

## 迭代工具

Python的`itertools`模块提供了许多用于处理迭代器的函数：

```python
import itertools

# 创建无限迭代器
count = itertools.count(1)  # 从1开始计数
print(next(count))  # 1
print(next(count))  # 2

# 获取有限元素
first_five = list(itertools.islice(count, 5))
print(first_five)  # [3, 4, 5, 6, 7]

# 循环迭代器
cycle = itertools.cycle(['A', 'B', 'C'])
print(next(cycle))  # A
print(next(cycle))  # B
print(next(cycle))  # C
print(next(cycle))  # A (循环)

# 重复迭代器
repeat = itertools.repeat('X', 3)
print(list(repeat))  # ['X', 'X', 'X']

# 组合迭代器
combinations = itertools.combinations('ABC', 2)
print(list(combinations))  # [('A', 'B'), ('A', 'C'), ('B', 'C')]

# 排列迭代器
permutations = itertools.permutations('ABC', 2)
print(list(permutations))  # [('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')]

# 笛卡尔积
product = itertools.product('AB', '12')
print(list(product))  # [('A', '1'), ('A', '2'), ('B', '1'), ('B', '2')]

# 分组
data = [('A', 1), ('A', 2), ('B', 1), ('B', 2)]
for key, group in itertools.groupby(data, lambda x: x[0]):
    print(key, list(group))
# 输出:
# A [('A', 1), ('A', 2)]
# B [('B', 1), ('B', 2)]
```

## 迭代器与生成器的比较

| 特性 | 迭代器 | 生成器 |
|------|--------|--------|
| 创建方式 | 实现`__iter__`和`__next__`方法的类 | 使用`yield`语句的函数或生成器表达式 |
| 内存使用 | 惰性计算，按需生成值 | 惰性计算，按需生成值 |
| 实现难度 | 相对复杂，需要定义类 | 相对简单，只需编写函数 |
| 状态保存 | 必须手动在对象属性中保存状态 | 自动保存函数的本地变量状态 |
| 功能 | 可以实现更复杂的逻辑和更多的控制 | 简洁但功能可能有限 |
| 适用场景 | 需要更多控制和更复杂状态管理的场景 | 简单的序列生成和数据转换场景 |

## 最佳实践

### 什么时候使用迭代器

- 需要复杂的状态管理
- 需要多个方法来控制迭代行为
- 创建可重用的迭代逻辑

### 什么时候使用生成器

- 处理大型数据集，避免一次性加载所有数据
- 创建数据处理管道
- 表示无限序列
- 简化迭代逻辑

### 性能考虑

- 使用生成器表达式替代列表推导式，特别是处理大数据集时
- 避免不必要的列表转换，尽可能直接使用迭代器
- 在函数中返回迭代器或生成器，而不是返回完整列表

```python
# 效率低（对大列表）
def process_items_bad(items):
    result = []
    for item in items:
        result.append(item * 2)
    return result

# 效率高
def process_items_good(items):
    for item in items:
        yield item * 2
```

## 总结

迭代器和生成器是Python中强大的工具，它们提供了一种内存高效的方式来处理序列数据。

- **迭代器**是实现迭代器协议的对象，通过`__iter__`和`__next__`方法实现惰性迭代
- **生成器**是一种特殊的函数，使用`yield`语句创建迭代器，提供简洁的方式来定义迭代逻辑
- **生成器表达式**是创建生成器的简洁语法，类似于列表推导式

掌握迭代器和生成器的概念及用法，可以帮助你编写更高效、更优雅的Python代码，特别是在处理大数据集或无限序列时。
